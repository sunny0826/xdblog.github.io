<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>微服务 on GuoXD Blog</title>
    <link>https://guoxudong.io/en/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</link>
    <description>Recent content in 微服务 on GuoXD Blog</description>
    <generator>Source Themes academia (https://sourcethemes.com/academic/)</generator>
    <language>en-us</language>
    <copyright>&lt;a rel=&#39;license&#39; href=&#39;http://creativecommons.org/licenses/by-nc/4.0/&#39; target=&#39;_blank&#39;&gt;知识共享署名-非商业性使用 4.0 国际许可协议&lt;/a&gt;</copyright>
    <lastBuildDate>Thu, 09 Apr 2020 09:06:57 +0800</lastBuildDate>
    
	    <atom:link href="https://guoxudong.io/en/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>导致你的微服务走向失败的11个原因</title>
      <link>https://guoxudong.io/en/post/11-reasons-why-you-are-going-to-fail-with-microservices/</link>
      <pubDate>Thu, 09 Apr 2020 09:06:57 +0800</pubDate>
      
      <guid>https://guoxudong.io/en/post/11-reasons-why-you-are-going-to-fail-with-microservices/</guid>
      <description>

&lt;p&gt;在过去的几年里，我对多个正在进行数字化转型的产品团队进行了架构审查。发现大多数团队都会使用微服务架构来构建产品，他们使用微服务架构的意图都是正确的：更快的开发速度、更好的可扩展性、更小的独立团队、独立的部署、使用合适的技术来完成工作等等。但大多数时候，我发现团队在使用微服务时都很不顺利，他们没能利用微服务的优势。在这篇文章中，我将分享导致你的微服务走向失败的11个原因。&lt;/p&gt;

&lt;p&gt;对于刚接触微服务的人来说，我推荐阅读 Martin Fowler 的&lt;a href=&#34;https://martinfowler.com/articles/microservices.html&#34; target=&#34;_blank&#34;&gt;《微服务》&lt;/a&gt;一文。文章中对微服务架构定义非常好。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;微服务架构风格这种开发方法，是以开发一组小型服务的方式来开发一个独立的应用系统。其中每个小型服务都运行在自己的进程中，并经常采用 HTTP 资源 API 这样轻量的机制来相互通信。这些服务围绕业务功能进行构建，并能通过全自动的部署机制来进行独立部署。这些微服务可以使用不同的语言来编写，并且可以使用不同的数据存储技术。对这些微服务，我们仅做最低限度的集中管理。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;原因一-管理层低估了微服务开发的复杂性&#34;&gt;原因一：管理层低估了微服务开发的复杂性&lt;/h2&gt;

&lt;p&gt;我曾与多个非常看好微服务客户合作过，对他们来说，微服务是解决他们所有问题的&lt;strong&gt;银弹&lt;/strong&gt;。在我看来，大多数团队及其管理层都低估了微服务开发的复杂性。&lt;/p&gt;

&lt;p&gt;要开发微服务，开发人员首先需要一个高效的本地开发环境。&lt;/p&gt;

&lt;p&gt;当你的系统中的服务开始增加时，在一台机器上运行应用程序的多个子程序就会变得很困难。特别是当你使用像 Java 这样消耗相对较多内存的语言来构建应用程序时，这种情况就更容易发生。&lt;/p&gt;

&lt;p&gt;以下是关于本地开发环境配置的相关要点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;本地开发首先需要一台好的开发机器。然而，大多数公司都想使用所有最新的、最先进的技术，但又不想换掉可怜的 Windows 开发机。我见过开发人员使用 VDI 虚拟云桌面或配置很差的机器来构建基于微服务的系统，开发人员受限于他们的开发机器，这降低了他们的工作效率，他们无法完全按照自己的想法在本地运行程序。而另一个副作用就是，开发人员不能快速得到反馈。如果你必须等待几分钟才能运行集成测试套件，那么你宁愿不写更多的集成测试套件来增加你的痛苦。糟糕的开发机助长了糟糕的开发实践。&lt;/li&gt;
&lt;li&gt;当为开发人员配备了合适的机器，接下来的事情就是确保所有的服务都使用统一的构建工具。你应该能够在一个新的机器上构建整个应用程序，而不需要太多的配置。根据我的经验，即使是使用微服务，使用一个可以构建整个应用程序的根构建脚本也是有帮助的。&lt;/li&gt;
&lt;li&gt;而下一点很重要，就是要让开发者能够在系统上轻松运行部分应用。在配置好所有的端口和存储卷的情况下，使用多个 &lt;code&gt;docker-compose&lt;/code&gt; 文件来启动不同的服务。&lt;/li&gt;
&lt;li&gt;接下来，如果你使用了 Kubernetes 这样的容器调度工具，那么你应该使用像 &lt;code&gt;Telepresence&lt;/code&gt; 这样的工具，它可以让你在 Kubernetes 集群中轻松调试应用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果一个团队不了解微服务开发的复杂性，那么随着时间的推移，团队的开发速度会明显下降。&lt;/p&gt;

&lt;h2 id=&#34;原因二-没有将依赖和工具更新到最新版本的程序&#34;&gt;原因二：没有将依赖和工具更新到最新版本的程序&lt;/h2&gt;

&lt;p&gt;在架构审查时我发现有些新的平台居然已经出现了遗留问题。团队没有确保依赖包版本最新，也没有确保数据库等工具处于最新版本。所以，两年前才开始的项目到今天发现居然已经欠了几个月的技术债了。&lt;/p&gt;

&lt;p&gt;很多团队在几年前就开始使用 Spring Cloud Netflix OSS 项目构建微服务。而现在他们开始使用像 Kubernetes 这样的容器调度工具，但由于他们之前使用的是 Netflix OSS，所以他们并没有使用 Kubernetes 提供的所有功能。当 Kubernetes 内置了服务发现功能后，他们仍然在使用 Eureka 作为服务发现。另外，使用 Istio 这样的服务网格，使你可以摆脱 Netflix OSS 提供的大部分功能。这有助于降低代码复杂性，而将更多很复杂的问题交给基础设施平台来解决。&lt;/p&gt;

&lt;p&gt;还有一点要记住，就是要保持所有服务的依赖版本同步。我最近在帮助一个使用 Spring Boot 构建微服务的客户，在过去两年中，他们已经构建了 20 多个 Spring Boot 服务。在他们的环境中，他们使用的 Spring Boot 版本从 1.5 到 2.1 不等。这意味着，当有人配置他们的机器时，他们必须下载多个版本的 Spring Boot。此外，他们还缺少了 Spring Boot 自 1.5 版本以来的许多改进。&lt;/p&gt;

&lt;p&gt;我们的建议是，各团队应为这些升级问题设立专门的技术债务项目。这些技术债务项目应该作为架构委员会会议的一部分进行讨论并定期解决。在我的上一个项目中，我们每三个月进行一次一周的 sprint，来将所有的依赖项更新到最新版本。&lt;/p&gt;

&lt;p&gt;同时，团队也应该投入时间将数据库、消息队列和缓存等工具升级到最新版本。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;译者按：这里的最新版本应该是最新的稳定版本，即 &lt;code&gt;stable&lt;/code&gt; 版本，而不是 &lt;code&gt;latest&lt;/code&gt; 版本。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;原因三-在本地开发中使用公共服务&#34;&gt;原因三：在本地开发中使用公共服务&lt;/h2&gt;

&lt;p&gt;由于本地开发效果的不理想，大多数团队开始依赖共享环境来提供关键服务。其中第一个就是数据库，大多数年轻的开发者并没有意识到基于数据库的共享开发并不好。以下是我认为共享数据库主要的问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;团队成员需要建立一个约定，以免一个开发者把另一个开发者写的数据抹掉。这种工作方式是痛苦且容易失败的，迟早会拖累整个团队。&lt;/li&gt;
&lt;li&gt;导致开发人员害怕实验性测试，因为他们的工作会影响到其他一些团队成员的工作。我们都知道，更好的学习方式是实验和快速反馈。有了公共数据库后，实验就会变得十分困难。&lt;/li&gt;
&lt;li&gt;另一个副作用是，独立地测试变化变得困难。这使你的集成测试变得很不稳定，从而进一步降低了开发速度。&lt;/li&gt;
&lt;li&gt;公共数据库要像对待宠物一样对待，因为你不希望它出现哪怕一个不一致的、不可预测的状态。你可能会有一个开发人员想在表是空的时候测试边缘情况，但其他人则需要这个表的记录。&lt;/li&gt;
&lt;li&gt;只有公共数据库才有系统工作所需的所有数据。团队成员会随着时间的推移失去了更改的可追溯性，所以没有人知道他们是如何在自己的机器上复制同样的设置的。唯一的办法就是将完整的数据库转储，并与它一起工作。&lt;/li&gt;
&lt;li&gt;当你没有连接到网络时，很难工作。这种情况一般发生在长时间的通勤或坐飞机时。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;数据库只是公共服务的一个例子，它也可以是消息队列、像 Redis 这样的集中式缓存或者其他任何一个服务可能变化的服务。&lt;/p&gt;

&lt;p&gt;解决这个问题的最好方法是让开发人员在自己的机器上运行数据库（使用 docker 运行），并创建 SQL 脚本来设置模式和初始化主数据。这些 SQL 脚本应该像其他代码一样被保存在版本控制中，并像其他代码一样进行维护。&lt;/p&gt;

&lt;h2 id=&#34;原因四-版本控制托管平台缺乏可视性&#34;&gt;原因四：版本控制托管平台缺乏可视性&lt;/h2&gt;

&lt;p&gt;我的一个客户，他们使用的是 Gitlab 版本控制平台，其中有 5 个产品，1000 多个版本库，每个产品都由多个微服务组成。而我问他们的第一个问题是：哪些服务和代码库是产品 A 的一部分。&lt;/p&gt;

&lt;p&gt;解决这个问题的最好方法是在一开始就以某种方式对你的微服务进行分组，这样你就可以随时了解你的产品生态系统。Gitlab提供了创建组的方式，然后在其中创建项目仓库。Github 没有分组功能，你可以使用主题或命名惯例来实现。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;我个人更喜欢单库，因为我觉得真的很方便。而大多数开发者都认为这是一种反模式。我同意 &lt;a href=&#34;https://danluu.com/monorepo/&#34; target=&#34;_blank&#34;&gt;Dan Lua 的帖子&lt;/a&gt;，他在帖子中提到了以下好处:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;简化的组织结构&lt;/li&gt;
&lt;li&gt;简化了依赖性&lt;/li&gt;
&lt;li&gt;工具化&lt;/li&gt;
&lt;li&gt;跨项目变更&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;原因五-没有明确的服务定义&#34;&gt;原因五：没有明确的服务定义&lt;/h2&gt;

&lt;p&gt;大多数团队都不知道如何划分微服务。围绕微服务的划分，产生了很多混乱和迷惑。让我们举个例子，你的应用程序有一个类似于插件的机制，将与多个第三方服务进行集成。每个集成是否应该是一个微服务？我见过多个团队走的是每个集成都要创建一个微服务的道路。随着集成数量的增加，这种做法很快就变得难以管理。这些服务通常都太小了，以至于它们作为一个单独的流程来运行会增加更多的开销。&lt;/p&gt;

&lt;p&gt;我认为大服务少，总比小服务多好。在一个企业组织内创建一个部门的模型，按照 DDD 的要求，将一个域分为子域和有边界的内容。有边界的内容代表了公司内部的一个部门，比如财务和营销部门。你可能会认为这可能会导致出现大型的微服务，认为这样做是不对的。但是，根据我的经验，将单体重构到微服务总是比反过来更容易。随着你获得更多的信息，你可以进行更细粒度的微服务划分。你可以应用单一责任原则来了解你的微服务是否变得太大，做的事情太多，然后将其分解成更小的独立服务。任何服务都不应该直接与另一个服务的数据库进行连接，它们只应该通过公开的接口进行通信。你可以在 Microservices.io 网站上阅读更多关于&lt;a href=&#34;https://microservices.io/patterns/decomposition/decompose-by-subdomain.html&#34; target=&#34;_blank&#34;&gt;按子域模式分解&lt;/a&gt;的内容。&lt;/p&gt;

&lt;p&gt;我也遵循了 &lt;a href=&#34;https://github.com/fpereiro/backendlore&#34; target=&#34;_blank&#34;&gt;backendlore&lt;/a&gt; 文档中提到的建议。这个建议可以帮助限制服务与服务之间的通信，而这是导致基于微服务的系统中性能低下的首要原因。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果两块信息是相互依存的，那么它们应该属于一个服务。换句话说，一个服务的自然边界应该是其数据的自然边界。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;原因六-没有明确的代码复用策略&#34;&gt;原因六：没有明确的代码复用策略&lt;/h2&gt;

&lt;p&gt;我的一个客户，他们在所有基于 Java 的微服务中都复制了四个与一个特定的功能有关 Java 文件。所以，如果在那个基础代码上发现了一个 bug，就需要修改所有的项目。而在时间压力下，会有些项目没有被修复。这样就会浪费更多的时间，同时也增加了挫折感。&lt;/p&gt;

&lt;p&gt;并不是说开发团队都不知道怎么做是正确的，但组织架构总会让人们使用默认的容易出错的方式做事。&lt;/p&gt;

&lt;p&gt;正确的方法是使用 Bintray 或 Nexus 这样的智能管理器，并在那里发布依赖关系。然后，每个微服务都应该依赖该库。当发布新版本的库时，所有的微服务都应该被更新和重新部署。&lt;/p&gt;

&lt;p&gt;使用微服务并不意味着你要抛弃迄今为止对我们有效的最佳实践。你需要在构建工具方面投入更多精力，让微服务升级变得容易且自动化，这样就不需要人手工去做这些事情了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在没有合适的工具和自动化的情况下使用微服务是灾难性的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;原因七-多语言方案&#34;&gt;原因七：多语言方案&lt;/h2&gt;

&lt;p&gt;我发现有的团队以最佳实践的名义使用多种编程语言、多种数据库、多种缓存。这一切在项目的初始阶段都是可行的，但当你的产品投入生产后，弊端就会展露。就像我们在使用 Java 的 Spring Boot 框架构建应用，但当我们意识到 Java 消耗的内存比较多，性能也比较差时，就决定改用 Node.js。这个理由是站不住脚的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Node.js 的性能比 Java 更好。&lt;/strong&gt;如果你有基于 IO 的工作负载，Node.js 的性能通常会更好。但在任何计算密集型的工作负载上，Java 都能&lt;a href=&#34;https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/javascript.html&#34; target=&#34;_blank&#34;&gt;击败&lt;/a&gt; node.js。通过调整，也可以使 Java 对 IO 工作负载有更好的性能。Spring Boot Reactor 在 IO 工作负载方面的性能就相当于 Node.js。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Node.js 的内存消耗比 Java 少。&lt;/strong&gt;这是部分事实，因为 Node.js 应用程序通常比 Java 消耗的内存少。Java 的 Spring Boot 应用程序并不像大多数人想象的那样糟糕。我在其中一个 Spring Boot Java Microservice 上运行了一个加载测试，内存消耗仍然不到 1GB。你可以通过 OpenJ9 JVM，限制类路径上的依赖性，以及调整默认的 JVM 参数来优化 Java 的内存利用率。另外，在 Java 中还有一些新的 Spring Boot 的替代品，如 Micronaut 和 Quarkus，其内存消耗相当于 Node.js。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Node.js 比 Java 更有生产力。&lt;/strong&gt;这取决于写代码的开发人员。使用静态分析工具的 Java 可以帮助在开发生命周期的早期发现问题。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;大多数时候，这一切都取决于具体情况。如果你的开发人员不成熟，那么无论你使用什么编程语言，你都会开发出糟糕的产品。&lt;/p&gt;

&lt;p&gt;我建议一个公司公布一个团队可以使用的语言列表。我认为 2-3 种语言是个不错的数字。另外，请列举一下为什么应该使用一种语言而不是另一种语言的原因。&lt;/p&gt;

&lt;p&gt;在选择语言之前，你应该考虑多种因素：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;是否容易找到成熟的企业级软件开发者？&lt;/li&gt;
&lt;li&gt;重新培训开发人员学习新技术是否容易？我们发现，Java 开发人员相对来说比较容易学习 Golang。&lt;/li&gt;
&lt;li&gt;初始团队之外的开发人员是否能够轻松地维护他人编写的代码？&lt;/li&gt;
&lt;li&gt;工具和依赖库方面的生态体系是否成熟？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这不仅限于编程语言，也适用于数据库。如果你的系统中已经有 MongoDB，那么你为什么要在你的系统中再引入 ArangoDB 呢？它们都主要是文档数据库。&lt;/p&gt;

&lt;h2 id=&#34;原因八-人的依赖性&#34;&gt;原因八：人的依赖性&lt;/h2&gt;

&lt;p&gt;这不是微服务所特有的，但在微服务生态中却变得更加猖獗。原因是大多数团队都专注于自己的具体服务，所以他们并不了解整个系统。在与不同客户的合作中，我发现只有一小部分架构师了解整体情况。但这些架构师的问题是，他们在日常工作中并不活跃，所以他们对开发的影响也是有限的。&lt;/p&gt;

&lt;p&gt;我认为最好的办法是确保所有的团队都有一个成员来自架构组，这样他们就可以使自己的团队与整个架构团队的路线图和目标保持一致，扁平化的管理有助于整个团队的成熟。&lt;/p&gt;

&lt;h2 id=&#34;原因九-缺乏文档&#34;&gt;原因九：缺乏文档&lt;/h2&gt;

&lt;p&gt;过去的几年中，我接触的大多数团队都在文档方面挣扎。很多开发人员和架构师要么不写文档，要么他们写的文档没有用。即使他们想写，也不知道应该如何记录他们的架构。&lt;/p&gt;

&lt;p&gt;我们至少应记录以下内容：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;设计文件&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://c4model.com/&#34; target=&#34;_blank&#34;&gt;C4 模型&lt;/a&gt;中的内容图和容器图&lt;/li&gt;
&lt;li&gt;以&lt;a href=&#34;(http://thinkrelevance.com/blog/2011/11/15/documenting-architecture-decisions)&#34; target=&#34;_blank&#34;&gt;架构决策记录&lt;/a&gt;的形式跟踪关键的架构决策&lt;/li&gt;
&lt;li&gt;开发人员入职指南&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我建议所有的文件都要在版本控制系统中进行维护。&lt;/p&gt;

&lt;h2 id=&#34;原因十-功能盖过平台成熟度&#34;&gt;原因十：功能盖过平台成熟度&lt;/h2&gt;

&lt;p&gt;这个原因我在其他地方已经简单地提到过，但我认为这个原因值得作为一个顶层原因来提及。微服务比传统的单体应用要复杂得多，因为你正在构建一个分布式系统，里面有很多组件，而大多数开发人员还不能理解系统的不同故障模式。大多数微服务在构建时都太过乐观，如果管理层过早的专注于业务功能，而忽略了系统平台本身的成熟度，那么必将失败。在一个薄弱的平台上构建的功能是无法提供价值的。&lt;/p&gt;

&lt;p&gt;企业需要进入平台思维。平台思维并不只是指使用容器和 Kubernetes。它们是解决方案的一部分，但其本身不是完整的解决方案。你需要考虑分布式跟踪、可观察性、混沌测试、函数调用与网络调用、安全服务与服务之间的通信、可调试性等问题。这需要认真的努力和调试，建立成熟可靠的平台和工具团队。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果你是一个资源有限的初创企业，我的建议是重新思考你的微服务战略。请你明白你正在进入的是什么。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;原因十一-缺乏自动化测试&#34;&gt;原因十一：缺乏自动化测试&lt;/h2&gt;

&lt;p&gt;大多数团队都知道自动化测试对产品的整体质量有多重要，但他们仍然没有做。微服务架构为测试的地点和方式提供了更多的选择。如果你不做彻底的自动化测试，那么你将会失败得很惨。&lt;/p&gt;

&lt;p&gt;关于这一点，我就不多写了，因为网上很多文章都有涉及该问题。下图是我从 Martin Fowler 网站上发表的&lt;a href=&#34;https://martinfowler.com/articles/microservice-testing/&#34; target=&#34;_blank&#34;&gt;《微服务测试》&lt;/a&gt;文章中摘录的，讲的是基于微服务系统的测试金字塔。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tvax3.sinaimg.cn/large/ad5fbf65gy1gdnnsqieu8j20bb0913yo.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;原文地址：&lt;a href=&#34;https://medium.com/xebia-engineering/11-reasons-why-you-are-going-to-fail-with-microservices-29b93876268b&#34; target=&#34;_blank&#34;&gt;https://medium.com/xebia-engineering/11-reasons-why-you-are-going-to-fail-with-microservices-29b93876268b&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>语义化版本控制规范（SemVer）</title>
      <link>https://guoxudong.io/en/post/semver/</link>
      <pubDate>Sat, 06 Jul 2019 09:40:42 +0800</pubDate>
      
      <guid>https://guoxudong.io/en/post/semver/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&#34;https://semver.org/lang/zh-CN/&#34; target=&#34;_blank&#34;&gt;https://semver.org/lang/zh-CN/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;语义化版本 2.0.0&lt;/p&gt;

&lt;p&gt;提供多种语言，语义化版本控制的规范是由 Gravatars 创办者兼 GitHub 共同创办者 &lt;a href=&#34;http://tom.preston-werner.com/&#34; target=&#34;_blank&#34;&gt;Tom Preston-Werner&lt;/a&gt; 所建立。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;摘要&#34;&gt;摘要&lt;/h2&gt;

&lt;p&gt;版本格式：主版本号.次版本号.修订号，版本号递增规则如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;主版本号：当你做了不兼容的 API 修改，&lt;/li&gt;
&lt;li&gt;次版本号：当你做了向下兼容的功能性新增，&lt;/li&gt;
&lt;li&gt;修订号：当你做了向下兼容的问题修正。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;先行版本号及版本编译元数据可以加到“主版本号.次版本号.修订号”的后面，作为延伸。&lt;/p&gt;

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;在软件管理的领域里存在着被称作“依赖地狱”的死亡之谷，系统规模越大，加入的包越多，你就越有可能在未来的某一天发现自己已深陷绝望之中。&lt;/p&gt;

&lt;p&gt;在依赖高的系统中发布新版本包可能很快会成为噩梦。如果依赖关系过高，可能面临版本控制被锁死的风险（必须对每一个依赖包改版才能完成某次升级）。而如果依赖关系过于松散，又将无法避免版本的混乱（假设兼容于未来的多个版本已超出了合理数量）。当你专案的进展因为版本依赖被锁死或版本混乱变得不够简便和可靠，就意味着你正处于依赖地狱之中。&lt;/p&gt;

&lt;p&gt;作为这个问题的解决方案之一，我提议用一组简单的规则及条件来约束版本号的配置和增长。这些规则是根据（但不局限于）已经被各种封闭、开放源码软件所广泛使用的惯例所设计。为了让这套理论运作，你必须先有定义好的公共 API 。这可以透过文件定义或代码强制要求来实现。无论如何，这套 API 的清楚明了是十分重要的。一旦你定义了公共 API，你就可以透过修改相应的版本号来向大家说明你的修改。考虑使用这样的版本号格式：X.Y.Z （主版本号.次版本号.修订号）修复问题但不影响API 时，递增修订号；API 保持向下兼容的新增及修改时，递增次版本号；进行不向下兼容的修改时，递增主版本号。&lt;/p&gt;

&lt;p&gt;我称这套系统为“语义化的版本控制”，在这套约定下，版本号及其更新方式包含了相邻版本间的底层代码和修改内容的信息。&lt;/p&gt;

&lt;h2 id=&#34;语义化版本控制规范-semver&#34;&gt;语义化版本控制规范（SemVer）&lt;/h2&gt;

&lt;p&gt;以下关键词 MUST、MUST NOT、REQUIRED、SHALL、SHALL NOT、SHOULD、SHOULD NOT、 RECOMMENDED、MAY、OPTIONAL 依照 RFC 2119 的叙述解读。（译注：为了保持语句顺畅， 以下文件遇到的关键词将依照整句语义进行翻译，在此先不进行个别翻译。）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用语义化版本控制的软件必须（MUST）定义公共 API。该 API 可以在代码中被定义或出现于严谨的文件内。无论何种形式都应该力求精确且完整。&lt;/li&gt;
&lt;li&gt;标准的版本号必须（MUST）采用 X.Y.Z 的格式，其中 X、Y 和 Z 为非负的整数，且禁止（MUST NOT）在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须（MUST）以数值来递增。例如：1.9.1 -&amp;gt; 1.10.0 -&amp;gt; 1.11.0。&lt;/li&gt;
&lt;li&gt;标记版本号的软件发行后，禁止（MUST NOT）改变该版本软件的内容。任何修改都必须（MUST）以新版本发行。&lt;/li&gt;
&lt;li&gt;主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。&lt;/li&gt;
&lt;li&gt;1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。&lt;/li&gt;
&lt;li&gt;修订号 Z（x.y.Z | x &amp;gt; 0）必须（MUST）在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。&lt;/li&gt;
&lt;li&gt;次版本号 Y（x.Y.z | x &amp;gt; 0）必须（MUST）在有向下兼容的新功能出现时递增。在任何公共 API 的功能被标记为弃用时也必须（MUST）递增。也可以（MAY）在内部程序有大量新功能或改进被加入时递增，其中可以（MAY）包括修订级别的改变。每当次版本号递增时，修订号必须（MUST）归零。&lt;/li&gt;
&lt;li&gt;主版本号 X（X.y.z | X &amp;gt; 0）必须（MUST）在有任何不兼容的修改被加入公共 API 时递增。其中可以（MAY）包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号必须（MUST）归零。&lt;/li&gt;
&lt;li&gt;先行版本号可以（MAY）被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。数字型的标识符禁止（MUST NOT）在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法满足预期的兼容性需求。范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。&lt;/li&gt;
&lt;li&gt;版本编译元数据可以（MAY）被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。当判断版本的优先层级时，版本编译元数据可（SHOULD）被忽略。因此当两个版本只有在版本编译元数据有差别时，属于相同的优先层级。范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。&lt;/li&gt;
&lt;li&gt;版本的优先层级指的是不同版本在排序时如何比较。判断优先层级时，必须（MUST）把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译元数据不在这份比较的列表中）。由左到右依序比较每个标识符，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较，例如：1.0.0 &amp;lt; 2.0.0 &amp;lt; 2.1.0 &amp;lt; 2.1.1。当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。例如：1.0.0-alpha &amp;lt; 1.0.0。有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级必须（MUST）透过由左到右的每个被句点分隔的标识符来比较，直到找到一个差异值后决定：只有数字的标识符以数值高低比较，有字母或连接号时则逐字以 ASCII 的排序来比较。数字的标识符比非数字的标识符优先层级低。若开头的标识符都相同时，栏位比较多的先行版本号优先层级比较高。范例：1.0.0-alpha &amp;lt; 1.0.0-alpha.1 &amp;lt; 1.0.0-alpha.beta &amp;lt; 1.0.0-beta &amp;lt; 1.0.0-beta.2 &amp;lt; 1.0.0-beta.11 &amp;lt; 1.0.0-rc.1 &amp;lt; 1.0.0。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;为什么要使用语义化的版本控制&#34;&gt;为什么要使用语义化的版本控制？&lt;/h2&gt;

&lt;p&gt;这并不是一个新的或者革命性的想法。实际上，你可能已经在做一些近似的事情了。问题在于只是“近似”还不够。如果没有某个正式的规范可循，版本号对于依赖的管理并无实质意义。将上述的想法命名并给予清楚的定义，让你对软件使用者传达意向变得容易。一旦这些意向变得清楚，弹性（但又不会太弹性）的依赖规范就能达成。&lt;/p&gt;

&lt;p&gt;举个简单的例子就可以展示语义化的版本控制如何让依赖地狱成为过去。假设有个名为“救火车”的函式库，它需要另一个名为“梯子”并已经有使用语义化版本控制的包。当救火车创建时，梯子的版本号为 3.1.0。因为救火车使用了一些版本 3.1.0 所新增的功能， 你可以放心地指定依赖于梯子的版本号大等于 3.1.0 但小于 4.0.0。这样，当梯子版本 3.1.1 和 3.2.0 发布时，你可以将直接它们纳入你的包管理系统，因为它们能与原有依赖的软件兼容。&lt;/p&gt;

&lt;p&gt;作为一位负责任的开发者，你理当确保每次包升级的运作与版本号的表述一致。现实世界是复杂的，我们除了提高警觉外能做的不多。你所能做的就是让语义化的版本控制为你提供一个健全的方式来发行以及升级包，而无需推出新的依赖包，节省你的时间及烦恼。&lt;/p&gt;

&lt;p&gt;如果你对此认同，希望立即开始使用语义化版本控制，你只需声明你的函式库正在使用它并遵循这些规则就可以了。请在你的 README 文件中保留此页连结，让别人也知道这些规则并从中受益。&lt;/p&gt;

&lt;h2 id=&#34;faq&#34;&gt;FAQ&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;在 0.y.z 初始开发阶段，我该如何进行版本控制？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最简单的做法是以 0.1.0 作为你的初始化开发版本，并在后续的每次发行时递增次版本号。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何判断发布 1.0.0 版本的时机？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当你的软件被用于正式环境，它应该已经达到了 1.0.0 版。如果你已经有个稳定的 API 被使用者依赖，也会是 1.0.0 版。如果你很担心向下兼容的问题，也应该算是 1.0.0 版了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这不会阻碍快速开发和迭代吗？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;主版本号为零的时候就是为了做快速开发。如果你每天都在改变 API，那么你应该仍在主版本号为零的阶段（0.y.z），或是正在下个主版本的独立开发分支中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于公共 API，若即使是最小但不向下兼容的改变都需要产生新的主版本号，岂不是很快就达到 42.0.0 版？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这是开发的责任感和前瞻性的问题。不兼容的改变不应该轻易被加入到有许多依赖代码的软件中。升级所付出的代价可能是巨大的。要递增主版本号来发行不兼容的改版，意味着你必须为这些改变所带来的影响深思熟虑，并且评估所涉及的成本及效益比。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为整个公共 API 写文件太费事了！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为供他人使用的软件编写适当的文件，是你作为一名专业开发者应尽的职责。保持专案高效一个非常重要的部份是掌控软件的复杂度，如果没有人知道如何使用你的软件或不知道哪些函数的调用是可靠的，要掌控复杂度会是困难的。长远来看，使用语义化版本控制以及对于公共 API 有良好规范的坚持，可以让每个人及每件事都运行顺畅。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一旦发现自己破坏了语义化版本控制的规范，就要修正这个问题，并发行一个新的次版本号来更正这个问题并且恢复向下兼容。即使是这种情况，也不能去修改已发行的版本。可以的话，将有问题的版本号记录到文件中，告诉使用者问题所在，让他们能够意识到这是有问题的版本。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果我更新了自己的依赖但没有改变公共 API 该怎么办？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于没有影响到公共 API，这可以被认定是兼容的。若某个软件和你的包有共同依赖，则它会有自己的依赖规范，作者也会告知可能的冲突。要判断改版是属于修订等级或是次版等级，是依据你更新的依赖关系是为了修复问题或是加入新功能。对于后者，我经常会预期伴随着更多的代码，这显然会是一个次版本号级别的递增。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果我变更了公共 API 但无意中未遵循版本号的改动怎么办呢？（意即在修订等级的发布中，误将重大且不兼容的改变加到代码之中）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;自行做最佳的判断。如果你有庞大的使用者群在依照公共 API 的意图而变更行为后会大受影响，那么最好做一次主版本的发布，即使严格来说这个修复仅是修订等级的发布。记住， 语义化的版本控制就是透过版本号的改变来传达意义。若这些改变对你的使用者是重要的，那就透过版本号来向他们说明。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我该如何处理即将弃用的功能？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;弃用现存的功能是软件开发中的家常便饭，也通常是向前发展所必须的。当你弃用部份公共 API 时，你应该做两件事：（1）更新你的文件让使用者知道这个改变，（2）在适当的时机将弃用的功能透过新的次版本号发布。在新的主版本完全移除弃用功能前，至少要有一个次版本包含这个弃用信息，这样使用者才能平顺地转移到新版 API。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;语义化版本对于版本的字串长度是否有限制呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;没有，请自行做适当的判断。举例来说，长到 255 个字元的版本已过度夸张。再者，特定的系统对于字串长度可能会有他们自己的限制。&lt;/p&gt;

&lt;h2 id=&#34;关于&#34;&gt;关于&lt;/h2&gt;

&lt;p&gt;语义化版本控制的规范是由 Gravatars 创办者兼 GitHub 共同创办者 &lt;a href=&#34;http://tom.preston-werner.com/&#34; target=&#34;_blank&#34;&gt;Tom Preston-Werner&lt;/a&gt; 所建立。&lt;/p&gt;

&lt;p&gt;如果您有任何建议，请到 &lt;a href=&#34;https://github.com/mojombo/semver/issues&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt; 上提出您的问题。&lt;/p&gt;

&lt;h2 id=&#34;许可证&#34;&gt;许可证&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://creativecommons.org/licenses/by/3.0/&#34; target=&#34;_blank&#34;&gt;知识共享 署名 3.0 (CC BY 3.0)&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
