<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>istio on GuoXD Blog</title>
    <link>https://guoxudong.io/en/categories/istio/</link>
    <description>Recent content in istio on GuoXD Blog</description>
    <generator>Source Themes academia (https://sourcethemes.com/academic/)</generator>
    <language>en-us</language>
    <copyright>&lt;a rel=&#39;license&#39; href=&#39;http://creativecommons.org/licenses/by-nc/4.0/&#39; target=&#39;_blank&#39;&gt;知识共享署名-非商业性使用 4.0 国际许可协议&lt;/a&gt;</copyright>
    <lastBuildDate>Thu, 21 Mar 2019 09:42:18 +0800</lastBuildDate>
    
	    <atom:link href="https://guoxudong.io/en/categories/istio/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Istio初探之Bookinfo样例部署</title>
      <link>https://guoxudong.io/en/post/istio-bookinfo-demo/</link>
      <pubDate>Thu, 21 Mar 2019 09:42:18 +0800</pubDate>
      
      <guid>https://guoxudong.io/en/post/istio-bookinfo-demo/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;之前介绍了 Istio 和 Service Mesh 能给我们带来什么，我们为什么要用 Istio ，但大家对 Istio 的认识可能还没有那么深刻。正如Linux 的创始人 &lt;a href=&#34;https://en.wikipedia.org/wiki/Linus_Torvalds&#34; target=&#34;_blank&#34;&gt;Linus Torvalds&lt;/a&gt; 的那句话：&lt;strong&gt;Talk is cheap. Show me the code.&lt;/strong&gt; 这里我们部署一个demo，由四个单独的微服务构成&lt;strong&gt;（注意这里的四个微服务是由不同的语言编写的）&lt;/strong&gt;，用来演示多种 Istio 特性。这个应用模仿在线书店的一个分类，显示一本书的信息。页面上会显示一本书的描述，书籍的细节（ISBN、页数等），以及关于这本书的一些评论。&lt;/p&gt;

&lt;h2 id=&#34;bookinfo-应用&#34;&gt;Bookinfo 应用&lt;/h2&gt;

&lt;p&gt;Bookinfo 应用分为四个单独的微服务：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;pre&gt;&lt;code class=&#34;language-productpage```&#34;&gt;- ```details``` ：这个微服务包含了书籍的信息。
- ```reviews``` ：这个微服务包含了书籍相关的评论。它还会调用 ratings 微服务。
- ```ratings``` ：ratings 微服务中包含了由书籍评价组成的评级信息。

这里主要使用```reviews```来演示 Istio 特性，```reviews``` 微服务有 3 个版本：

- v1 版本不会调用 ```ratings``` 服务。
- v2 版本会调用 ```ratings``` 服务，并使用 1 到 5 个黑色星形图标来显示评分信息。
- v3 版本会调用 ```ratings``` 服务，并使用 1 到 5 个红色星形图标来显示评分信息。

下图展示了这个应用的端到端架构。
![Istio 注入之前的 Bookinfo 应用](https://istio.io/docs/examples/bookinfo/noistio.svg)
&amp;lt;center&amp;gt;Istio 注入之前的 Bookinfo 应用&amp;lt;/center&amp;gt;

Bookinfo 是一个异构应用，几个微服务是由不同的语言编写的。这些服务对 Istio **并无依赖**，但是构成了一个有代表性的服务网格的例子：它由多个服务、多个语言构成，并且 reviews 服务具有多个版本。

## 部署应用
这里 Istio 的安装部署就不在赘述了。

值得注意的是：如果使用的是**阿里云**容器服务安装的 Istio ，需要在 ```容器服务```-```市场```-```应用目录``` 中选择 ```gateway``` 进行安装，这里提供了多种 ```gateway``` ，我们选择 ```istio-ingressgateway```，选择直接安装的话会默认创建 ```LoadBalancer``` 类型的Service，会自动创建一个经典网络SLB，这里是可以调整的，会在后续的文章中进行详细讲解，这里不做赘述。

在 Istio 中运行这一应用，无需对应用自身做出任何改变。我们只要简单的在 Istio 环境中对服务进行配置和运行，具体一点说就是把 Envoy sidecar 注入到每个服务之中。这个过程所需的具体命令和配置方法由运行时环境决定，而部署结果较为一致，如下图所示：

![Bookinfo 应用](https://istio.io/docs/examples/bookinfo/withistio.svg)
&amp;lt;center&amp;gt;Bookinfo 应用&amp;lt;/center&amp;gt;

所有的微服务都和 Envoy sidecar 集成在一起，被集成服务所有的出入流量都被 sidecar 所劫持，这样就为外部控制准备了所需的 Hook，然后就可以利用 Istio 控制平面为应用提供服务路由、遥测数据收集以及策略实施等功能。

### 下载安装
到 GitHub 中 istio 的 [release](https://github.com/istio/istio/releases) 中下载相应版本的 istio 包，下载后将 ```bin``` 目录配置到环境变量 ```PATH``` 中 ```export PATH=&amp;quot;/istio/bin:$PATH&amp;quot;``` ，这里我们使用的是 ```istio 1.0.5``` 版本

Bookinfo 这个应用就在 ```samples/```目录下

## 在 阿里云容器服务（kubernetes） 中运行

启动应用容器，这里提供两种注入方法：**手工注入**和**自动注入**

- 自动注入

需要修改 namespace ，为其添加 label 标签，这样所以在这个 namespace 中创建的应用都会被自动注入 sidecar 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bash
$ kubectl label namespace {inject-namespace} istio-injection=enabled
$ kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
- 手工注入

需要使用 istioctl 命令生成注入后应用的配置，然后在部署应用

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bash
$ istioctl kube-inject -f samples/bookinfo/platform/kube/bookinfo.yaml | kubectl apply -f -&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
由于是测试，这里我们使用手工注入的方法。
上面的命令会启动全部的四个服务，其中也包括了 ```reviews``` 服务的三个版本（```v1```、```v2``` 以及 ```v3```）

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bash&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$ istioctl kube-inject -f bookinfo.yaml | kubectl apply -f -
service/details created
deployment.extensions/details-v1 configured
service/ratings created
deployment.extensions/ratings-v1 created
service/reviews created
deployment.extensions/reviews-v1 created
deployment.extensions/reviews-v2 created
deployment.extensions/reviews-v3 created
service/productpage created
deployment.extensions/productpage-v1 created
$ kubectl get po
NAME                              READY   STATUS    RESTARTS   AGE
details-v1-8685d68cf9-8fwdb       &lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;     Running   0          1h
productpage-v1-5fd9fddc97-tx88z   &lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;     Running   0          1h
ratings-v1-7c4d756c55-cn76d       &lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;     Running   0          1h
reviews-v1-5d868db586-w28q5       &lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;     Running   0          1h
reviews-v2-787647c7d9-7sc52       &lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;     Running   0          1h
reviews-v3-6964c86584-8728m       &lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;     Running   0          1h
$ kubectl get svc
NAME                 TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)            AGE
details              ClusterIP   10.11.224.17    &lt;none&gt;        9080/TCP           1h
productpage          ClusterIP   10.11.16.86     &lt;none&gt;        9080/TCP           1h
ratings              ClusterIP   10.11.244.59    &lt;none&gt;        9080/TCP           1h
reviews              ClusterIP   10.11.162.37    &lt;none&gt;        9080/TCP           1h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
可以看到 Bookinfo 应用已经正常运行

### 指定 ingress 和 IP 的端口

1. 为为应用程序定义入口网关：

    ```bash
    $ kubectl apply -f samples/bookinfo/networking/bookinfo-gateway.yaml
    ```

2. 确认网关创建完成

    ```bash
    $ kubectl get gateway
    NAME               AGE
    bookinfo-gateway   1h
    ```

3. 快速查询访问地址，这里的是之前在阿里云上创建的 ```LoadBalancer``` 类型的 Service

    ```bash
    $ kubectl get svc istio-ingressgateway -n istio-system
    NAME                   TYPE           CLUSTER-IP    EXTERNAL-IP       PORT(S)                  AGE
    istio-ingressgateway   LoadBalancer   10.11.18.83   xxx.xxx.xxx.xxx   80:xxx/TCP,443:xxx/TCP   2h
    ```

### 查看效果
访问 http://{EXTERNAL-IP}/productpage 注意：这里最后不能有/，否则将找不到页面
![image](http://wx4.sinaimg.cn/large/ad5fbf65ly1g1ad2jg6p3j21g90mxgo7.jpg)
多次刷新浏览器，将在 ```productpage``` 中看到评论的不同的版本，它们会按照 round robin（红星、黑星、没有星星）的方式展现，这三个展示分来来自```v1```、```v2```和```v3```版本，因为还没有使用 Istio 来控制版本的路由，所以这里显示的是以轮询的负载均衡算法进行展示。

### 请求路由
BookInfo示例部署了三个版本的reviews服务，因此需要设置一个缺省路由。否则当多次访问该应用程序时，会发现有时输出会包含带星级的评价内容，有时又没有。出现该现象的原因是当没有为应用显式指定缺省路由时，Istio会将请求随机路由到该服务的所有可用版本上。

在使用 Istio 控制 Bookinfo 版本路由之前，你需要在目标规则中定义好可用的版本 。

运行以下命令为 Bookinfo 服务创建的默认的目标规则：

- 如果不需要启用双向TLS，请执行以下命令：

    ```bash
    $ kubectl apply -f samples/bookinfo/networking/destination-rule-all.yaml
    ```

- 如果需要启用双向 TLS，请执行以下命令：

    ```bash
    $ kubectl apply -f samples/bookinfo/networking/destination-rule-all-mtls.yaml
    ```

    等待几秒钟，等待目标规则生效。你可以使用以下命令查看目标规则：

    ```bash
    kubectl get destinationrules
    NAME          AGE
    details       28s
    productpage   28s
    ratings       28s
    reviews       28s
    ```

### 将所有微服务的缺省版本设置为v1
通过运行如下命令，将所有微服务的缺省版本设置为v1：

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bash
$ kubectl apply -f samples/bookinfo/networking/virtual-service-all-v1.yaml&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
可以通过下面的命令来显示所有已创建的路由规则：

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bash
$ kubectl get virtualservices
NAME       AGE
bookinfo      33m
details       8s
productpage   8s
ratings       8s
reviews       8s&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
显示已创建的详细路由规划：

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bash
$ kubectl get virtualservices -o yaml&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
由于路由规则是通过异步方式分发到代理的，过一段时间后规则才会同步到所有pod上。因此需要等几秒钟后再尝试访问应用。

在浏览器中打开 Bookinfo 应用程序的URL: http://{EXTERNAL-IP}/productpage。

![image](http://wx4.sinaimg.cn/large/ad5fbf65ly1g1adqyf9dej21g70oitbd.jpg)

可以看到 Bookinfo 应用程序的 ```productpage``` 页面，显示的内容中不包含带星的评价信息，这是因为 ```reviews:v1``` 服务不会访问ratings服务。

### 将来自特定用户的请求路由到reviews:v2
本例中，首先使用 Istio 将100%的请求流量都路由到了 Bookinfo 服务的```v1```版本；然后再设置了一条路由规则，路由规则基于请求的 header（例如一个用户cookie）选择性地将特定的流量路由到了 ```reviews``` 服务的```v2```版本。

通过运行如下命令，把来自测试用户&amp;quot;jason&amp;quot;的请求路由到 ```reviews:v2 ```，以启用ratings服务。

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bash
$ kubectl apply -f samples/bookinfo/networking/virtual-service-reviews-test-v2.yaml&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
通过如下命令确认规则是否创建：

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bash
$ kubectl get virtualservice reviews -o yaml
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
    {&amp;ldquo;apiVersion&amp;rdquo;:&amp;ldquo;networking.istio.io/v1alpha3&amp;rdquo;,&amp;ldquo;kind&amp;rdquo;:&amp;ldquo;VirtualService&amp;rdquo;,&amp;ldquo;metadata&amp;rdquo;:{&amp;ldquo;annotations&amp;rdquo;:{},&amp;ldquo;name&amp;rdquo;:&amp;ldquo;reviews&amp;rdquo;,&amp;ldquo;namespace&amp;rdquo;:&amp;ldquo;default&amp;rdquo;},&amp;ldquo;spec&amp;rdquo;:{&amp;ldquo;hosts&amp;rdquo;:[&amp;ldquo;reviews&amp;rdquo;],&amp;ldquo;http&amp;rdquo;:[{&amp;ldquo;match&amp;rdquo;:[{&amp;ldquo;headers&amp;rdquo;:{&amp;ldquo;end-user&amp;rdquo;:{&amp;ldquo;exact&amp;rdquo;:&amp;ldquo;jason&amp;rdquo;}}}],&amp;ldquo;route&amp;rdquo;:[{&amp;ldquo;destination&amp;rdquo;:{&amp;ldquo;host&amp;rdquo;:&amp;ldquo;reviews&amp;rdquo;,&amp;ldquo;subset&amp;rdquo;:&amp;ldquo;v2&amp;rdquo;}}]},{&amp;ldquo;route&amp;rdquo;:[{&amp;ldquo;destination&amp;rdquo;:{&amp;ldquo;host&amp;rdquo;:&amp;ldquo;reviews&amp;rdquo;,&amp;ldquo;subset&amp;rdquo;:&amp;ldquo;v1&amp;rdquo;}}]}]}}
creationTimestamp: &amp;ldquo;2019-03-21T06:01:10Z&amp;rdquo;
generation: 1
name: reviews
namespace: default
resourceVersion: &amp;ldquo;62486214&amp;rdquo;
selfLink: /apis/networking.istio.io/v1alpha3/namespaces/default/virtualservices/reviews
uid: b9e41681-4b9e-11e9-a679-00163e045478
spec:
hosts:
- reviews
http:
- match:
    - headers:
        end-user:
        exact: jason
    route:
    - destination:
        host: reviews
        subset: v2
- route:
    - destination:
        host: reviews
        subset: v1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
确认规则已创建之后，在浏览器中打开BookInfo应用程序的URL: http://{EXTERNAL-IP}/productpage。

以&amp;quot;jason&amp;quot;用户登录 ```productpage``` 页面，您可以在每条评价后面看到星级信息。

这里登录用户名为 ```jason``` ，密码随便输入即可

![image](http://wx4.sinaimg.cn/large/ad5fbf65ly1g1adtjugp3j21gb0iygoa.jpg)

### 流量转移
除了基于内容的路由，Istio还支持基于权重的路由规则。

首先，将所有微服务的缺省版本设置为v1：

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bash
$ kubectl replace -f samples/bookinfo/networking/virtual-service-all-v1.yaml&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
其次，使用下面的命令把50%的流量从reviews:v1转移到reviews:v3:

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bash
$ kubectl replace -f samples/bookinfo/networking/virtual-service-reviews-50-v3.yaml&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
在浏览器中多次刷新productpage页面，大约有50%的几率会看到页面中出现带红星的评价内容。

说明： 注意该方式和使用容器编排平台的部署特性来进行版本迁移是完全不同的。容器编排平台使用了实例scaling来对流量进行管理。而通过Istio，两个版本的reviews服务可以独立地进行扩容和缩容，并不会影响这两个版本服务之间的流量分发。

如果觉得 ```reviews：v3``` 微服务已经稳定，你可以通过以下命令， 将 ```virtual service``` 100％的流量路由到 ```reviews：v3```，从而实现一个灰度发布的功能。

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bash
$ kubectl replace -f samples/bookinfo/networking/virtual-service-reviews-v3.yaml
```&lt;/p&gt;

&lt;h2 id=&#34;在华为云-cce-上运行&#34;&gt;在华为云（CCE）上运行&lt;/h2&gt;

&lt;p&gt;华为云率先将 Istio 作为产品投入到公有云中进行商业应用，开通方式十分简单，只要在华为云CCE上创建集群，然后申请 Istio 公测即可。&lt;/p&gt;

&lt;p&gt;为了方便测试 Bookinfo 应用在华为云上提供了一键体验应用，点击即可省去刚刚那一系列的 &lt;code&gt;kubectl&lt;/code&gt; 操作&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://wx4.sinaimg.cn/large/ad5fbf65ly1g1afbs7oq4j21g90id0vv.jpg&#34; alt=&#34;image&#34; /&gt;
&lt;center&gt;一键创建体验应用&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://wx4.sinaimg.cn/large/ad5fbf65ly1g1afgth1cgj219b0a7tb1.jpg&#34; alt=&#34;image&#34; /&gt;
&lt;center&gt;点击灰度发布即可&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://wx4.sinaimg.cn/large/ad5fbf65ly1g1afjc5hvgj21fv0o1q6q.jpg&#34; alt=&#34;image&#34; /&gt;
&lt;center&gt;创建金丝雀发布&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://wx4.sinaimg.cn/large/ad5fbf65ly1g1afnqyqlhj20ze0o00vl.jpg&#34; alt=&#34;image&#34; /&gt;
&lt;center&gt;选择灰度发布的组件&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://wx4.sinaimg.cn/large/ad5fbf65ly1g1afp1c5ltj20zk0le765.jpg&#34; alt=&#34;image&#34; /&gt;
&lt;center&gt;填写版本号&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://wx4.sinaimg.cn/large/ad5fbf65ly1g1afq846bjj20z80nowgl.jpg&#34; alt=&#34;image&#34; /&gt;
&lt;center&gt;选择镜像版本&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://wx4.sinaimg.cn/large/ad5fbf65ly1g1afra8rmhj21050mfgpb.jpg&#34; alt=&#34;image&#34; /&gt;
&lt;center&gt;版本创建完成后配置灰度策略&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://wx4.sinaimg.cn/large/ad5fbf65ly1g1afwpan6qj21090mste1.jpg&#34; alt=&#34;image&#34; /&gt;
&lt;center&gt;选择相应策略，策略下发即可&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;总的来说，华为云的 Istio 确实已经是商业化应用，这里只是展示了部分灰度发布的功能。其他比如流量治理，流量监控等功能还没展示，这些功能做的十分细致，值得尝试。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://help.aliyun.com/document_detail/90563.html?spm=a2c4g.11186623.6.759.5dbd1f5fSB2m9T&#34; target=&#34;_blank&#34;&gt;在Kubernetes上基于Istio实现Service Mesh智能路由&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://support.huaweicloud.com/bestpractice-cce/cce_bestpractice_0012.html&#34; target=&#34;_blank&#34;&gt;基于ISTIO服务网格的灰度发布&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>浅析ServiceMesh &amp; Istio</title>
      <link>https://guoxudong.io/en/post/istio-share/</link>
      <pubDate>Wed, 20 Mar 2019 09:12:28 +0800</pubDate>
      
      <guid>https://guoxudong.io/en/post/istio-share/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;公司于&lt;strong&gt;18年10月&lt;/strong&gt;正式确认服务容器化，到&lt;strong&gt;18年12月4日&lt;/strong&gt;第一个服务正式部署到生产环境kubernetes集群，再到&lt;strong&gt;如今&lt;/strong&gt;已有&lt;strong&gt;23&lt;/strong&gt;个服务完成了生产环境容器化的切换，更多的服务在测试环境容器化部署随时可以切换到生产环境。目前新项目的开发，大部分都直接在测试环境容器化部署，不再需要新购ECS搭建测试环境。随着容器化的深入，服务间的通信和联系变的更加复杂，其中通信的可视化、流量的控制和服务质量的评估问题日益凸显，成为了微服务方案的短板。这个时候&lt;code&gt;Service mesh&lt;/code&gt;就进入了我们的视野。&lt;/p&gt;

&lt;h2 id=&#34;service-mesh是什么&#34;&gt;Service mesh是什么&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-Service&#34;&gt;
**这里注意：**```istio```只是```Service mesh```服务网格的一种。

### 服务网格的特点

服务网格有如下几个特点：

- 应用程序间通讯的中间层
- 轻量级网络代理
- 应用程序无感知
- 解耦应用程序的重试/超时、监控、追踪和服务发现

目前两款流行的服务网格开源软件 [Linkerd](https://linkerd.io) 和 [Istio](https://Istio.io) 都可以直接在 Kubernetes 中集成，其中 Linkerd 已经成为 CNCF 成员，Istio 在 2018年7月31日宣布 [1.0](https://istio.io/zh/blog/2018/announcing-1.0/)。

### 服务网格的发展历史

* Spring Cloud

    Spring Cloud 诞生于2015年，Spring Cloud 最早在功能层面为微服务治理定义了一系列标准特性，比如：智能路由、服务熔断、服务注册于发现等这些名词我最早看到都是在 Sprint Cloud 相关文章中。同时也有一些缺点，比如：需要在代码级别对诸多组件进行控制，并且都依赖于 Java 的实现，这与微服务的多语言协作背道而驰；没有对资源的调度、devops等提供相关支持，需要借助平台来完成；众所周知的Eureka闭源等。

* Linkerd

    Service mesh 这个命名就是来源于Linkerd。Linkerd 很好地结合了 kubernetes 所提供的功能，于2017年加入CNCF。

* Istio

    2017年5月， Google、 IBM 和 Lyft 宣布了Istio的诞生。一经发布，便立即获得Red Hat、F5等大厂响应，社区活跃度高涨，很快超越了 Linkerd，成为了 Service mesh 的代表产品。

* 国内服务网格

    这里不得不提的是国内服务网格的兴起，在 Service mesh 概念具体定义以前，国内的许多厂商就已经开始了微服务进程，同时在做自己的微服务治理产品。而在 Service mesh 概念普及之后，厂商意识到了自己产品也具有 Service mesh 的特点，将自己的服务治理平台进行了改造和完善，推出了自己的 Service mesh 产品。例如，微博、腾讯和华为都有自己的服务网格产品，华为更是已经将产品投入到公有云中进行商业应用。蚂蚁金服的 SOFAMesh 则是针对大流量的生产场景，在 Istio 的架构基础上进行修改并推广。

## Istio又是什么
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Istio``` 提供了一个完整的解决方案，通过为整个服务网格提供行为洞察和操作控制来满足微服务应用程序的多样化需求。Istio 允许您连接、保护、控制和观测服务。在较高的层次上，Istio 有助于降低这些部署的复杂性，并减轻开发团队的压力。它是一个完全开源的服务网格，可以透明地分层到现有的分布式应用程序上。它也是一个平台，包括允许它集成到任何日志记录平台、遥测或策略系统的 API。Istio 的多样化功能集使您能够成功高效地运行分布式微服务架构，并提供保护、连接和监控微服务的统一方法。&lt;/p&gt;

&lt;h3 id=&#34;istio的架构&#34;&gt;Istio的架构&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Istio&lt;/code&gt;总的来说由两部分组成：&lt;strong&gt;控制平面&lt;/strong&gt;和&lt;strong&gt;数据平面&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;数据平面由一组以 sidecar 方式部署的智能代理（Envoy）组成。sidecar通过注入的方式和业务容器共存于一个 Pod 中，会劫业务容器的流量，接受控制面组件的控制，可以调节和控制微服务及 Mixer 之间所有的网络通信。&lt;/li&gt;
&lt;li&gt;控制平面是 Istio 的核心，负责管理和配置代理来路由流量。此外控制平面配置 Mixer 以实施策略和收集遥测数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下图显示了构成每个面板的不同组件：
&lt;img src=&#34;http://wx4.sinaimg.cn/large/ad5fbf65ly1g199o3s4g5j20lw0kijux.jpg&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;图片为原创，转载请标记出处&lt;a href=&#34;https://blog.maoxianplay.com/&#34; target=&#34;_blank&#34;&gt;https://blog.maoxianplay.com/&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h4 id=&#34;envoy&#34;&gt;Envoy&lt;/h4&gt;

&lt;p&gt;Istio 使用 Envoy 代理的扩展版本，Envoy 是以 C++ 开发的高性能代理，用于调解服务网格中所有服务的所有入站和出站流量。Envoy 的许多内置功能被 Istio 发扬光大，例如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;动态服务发现&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;TLS 终止&lt;/li&gt;
&lt;li&gt;HTTP/2 &amp;amp; gRPC 代理&lt;/li&gt;
&lt;li&gt;熔断器&lt;/li&gt;
&lt;li&gt;健康检查、基于百分比流量拆分的灰度发布&lt;/li&gt;
&lt;li&gt;故障注入&lt;/li&gt;
&lt;li&gt;丰富的度量指标&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Envoy 被部署为 sidecar，和对应服务在同一个 Kubernetes pod 中。这允许 Istio 将大量关于流量行为的信号作为属性提取出来，而这些属性又可以在 Mixer 中用于执行策略决策，并发送给监控系统，以提供整个网格行为的信息。&lt;/p&gt;

&lt;p&gt;Sidecar 代理模型还可以将 Istio 的功能添加到现有部署中，而无需重新构建或重写代码。可以阅读更多来了解为什么我们在设计目标中选择这种方式。&lt;/p&gt;

&lt;h4 id=&#34;mixer&#34;&gt;Mixer&lt;/h4&gt;

&lt;p&gt;Mixer 是一个独立于平台的组件，负责在服务网格上执行访问控制和使用策略，并从 Envoy 代理和其他服务收集遥测数据。代理提取请求级属性，发送到 Mixer 进行评估。&lt;/p&gt;

&lt;p&gt;Mixer 中包括一个灵活的插件模型，使其能够接入到各种主机环境和基础设施后端，从这些细节中抽象出 Envoy 代理和 Istio 管理的服务。&lt;/p&gt;

&lt;h4 id=&#34;pilot&#34;&gt;Pilot&lt;/h4&gt;

&lt;p&gt;Pilot 为 Envoy sidecar 提供服务发现功能，为智能路由（例如 A/B 测试、金丝雀部署等）和弹性（超时、重试、熔断器等）提供流量管理功能。它将控制流量行为的高级路由规则转换为特定于 Envoy 的配置，并在运行时将它们传播到 sidecar。&lt;/p&gt;

&lt;p&gt;Pilot 将平台特定的服务发现机制抽象化并将其合成为符合 Envoy 数据平面 API 的任何 sidecar 都可以使用的标准格式。这种松散耦合使得 Istio 能够在多种环境下运行（例如，Kubernetes、Consul、Nomad），同时保持用于流量管理的相同操作界面。&lt;/p&gt;

&lt;h4 id=&#34;citadel&#34;&gt;Citadel&lt;/h4&gt;

&lt;p&gt;Citadel 通过内置身份和凭证管理赋能强大的服务间和最终用户身份验证。可用于升级服务网格中未加密的流量，并为运维人员提供基于服务标识而不是网络控制的强制执行策略的能力。从 0.5 版本开始，Istio 支持基于角色的访问控制，以控制谁可以访问您的服务，而不是基于不稳定的三层或四层网络标识。&lt;/p&gt;

&lt;h4 id=&#34;galley-1-1版本新增&#34;&gt;Galley(1.1版本新增)&lt;/h4&gt;

&lt;p&gt;Galley 代表其他的 Istio 控制平面组件，用来验证用户编写的 Istio API 配置。随着时间的推移，Galley 将接管 Istio 获取配置、 处理和分配组件的顶级责任。它将负责将其他的 Istio 组件与从底层平台（例如 Kubernetes）获取用户配置的细节中隔离开来。&lt;/p&gt;

&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;

&lt;p&gt;在云原生架构下，容器的使用给予了异构应用程序的更多可行性，Kubernetes 增强了应用的横向扩容能力，用户可以快速的编排出复杂环境、复杂依赖关系的应用程序，Istio可以使开发者又无须过分关心应用程序的监控、扩展性、服务发现和分布式追踪这些繁琐的事情而专注于程序开发，赋予开发者更多的创造性。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/zh/&#34; target=&#34;_blank&#34;&gt;Istio 官方文档 - istio.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/fleeto/istio-for-beginner&#34; target=&#34;_blank&#34;&gt;《深入浅出istio》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>阿里云环境Istio初探</title>
      <link>https://guoxudong.io/en/post/istio-demo/</link>
      <pubDate>Wed, 13 Mar 2019 15:45:43 +0800</pubDate>
      
      <guid>https://guoxudong.io/en/post/istio-demo/</guid>
      <description>

&lt;h1 id=&#34;istio应用部署样例&#34;&gt;istio应用部署样例&lt;/h1&gt;

&lt;p&gt;该实例为一套istio服务上线流程：&lt;code&gt;注入&lt;/code&gt;-&amp;gt;&lt;code&gt;部署&lt;/code&gt;-&amp;gt;&lt;code&gt;创建目标规则&lt;/code&gt;-&amp;gt;&lt;code&gt;创建默认路由&lt;/code&gt;。就大多数istio服务网格应用均可基于这一流程上线。&lt;/p&gt;

&lt;h3 id=&#34;部署istio&#34;&gt;部署istio&lt;/h3&gt;

&lt;p&gt;istio有多种部署方式，阿里云、华为云等云服务商均提供一键安装，同时也可以通过GitHub下载release包，使用&lt;code&gt;install/kubernetes/istio-demo.yaml&lt;/code&gt;部署，或者使用helm部署。&lt;strong&gt;这里采用阿里云容器服务一键部署istio&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://wx4.sinaimg.cn/large/ad5fbf65ly1g117xxixlvj20a00ajdgb.jpg&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;部署两个版本的服务&#34;&gt;部署两个版本的服务&lt;/h3&gt;

&lt;p&gt;这里选择一个简单的Python项目作为服务端，这里使用&lt;a href=&#34;https://github.com/fleeto&#34; target=&#34;_blank&#34;&gt;崔秀龙&lt;/a&gt;老哥的&lt;a href=&#34;https://github.com/fleeto/flaskapp/blob/master/app/main.py&#34; target=&#34;_blank&#34;&gt;flaskapp&lt;/a&gt;服务，该服务的作用就是提供2个url路径：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个是/env，用户获取容器中的环境变量，例如 &lt;a href=&#34;http://flaskapp/env/version&#34; target=&#34;_blank&#34;&gt;http://flaskapp/env/version&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;另一个是/fetch ，用于获取在参数url中指定的网址的内容，例如 &lt;a href=&#34;http://flaskapp/fetch?url=http://weibo.com&#34; target=&#34;_blank&#34;&gt;http://flaskapp/fetch?url=http://weibo.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;创建2个Deployment，分别命名为 flaskapp-v1 和 flaskapp-v2 ，同时创建一个 Service ,将其命名为flaskapp。代码文件为 &lt;code&gt;flaskapp.istio.yaml&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;image:
  caption: &amp;quot;Image from: [**Pexels**](https://www.pexels.com)&amp;quot;
  focal_point: &amp;quot;&amp;quot;
  preview_only: false
---
apiVersion: v1
kind: Service
metadata:
name: flaskapp
labels:
    app: flaskapp
spec:
selector:
    app: flaskapp
ports:
- name: http
    port: 80
image:
  caption: &amp;quot;Image from: [**Pexels**](https://www.pexels.com)&amp;quot;
  focal_point: &amp;quot;&amp;quot;
  preview_only: false
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
name: flaskapp-v1
spec:
replicas: 1
template:
    metadata:
    labels:
        app: flaskapp
        version: v1
    spec:
    containers:
    - name: flaskapp
        image: dustise/flaskapp
        imagePullPolicy: IfNotPresent
        env:
        - name: version
        value: v1
image:
  caption: &amp;quot;Image from: [**Pexels**](https://www.pexels.com)&amp;quot;
  focal_point: &amp;quot;&amp;quot;
  preview_only: false
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
name: flaskapp-v2
spec:
replicas: 1
template:
    metadata:
    labels:
        app: flaskapp
        version: v2
    spec:
    containers:
    - name: flaskapp
        image: dustise/flaskapp
        imagePullPolicy: IfNotPresent
        env:
        - name: version
        value: v2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;两个版本Deployment的镜像一致，但是使用了不同的version标签区分，分别为 v1 和 v2 。实际环境中的镜像是不同的&lt;/li&gt;
&lt;li&gt;在两个Deployment中都有一个名为version的环境变量，分别为 v1 和 v2 。这里设置是为了方便后续区分服务。&lt;/li&gt;
&lt;li&gt;两个Deployment中都使用了 app 和 version 标签，在 istio 网格应用中通常会使用这两个标签作为应用和版本的标识。&lt;/li&gt;
&lt;li&gt;Service 中的 Selector 仅使用了一个 app 标签，这意味着该 Service 对两个 Deployment 都是有效的。&lt;/li&gt;
&lt;li&gt;将在 Service 中定义的端口根据 &lt;strong&gt;istio 规范&lt;/strong&gt;命名为http。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;istio注入并部署服务端&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ istioctl kube-inject -f flask.istio.yaml | kubectl apply -f -
service/flaskapp created
deployment.extensions/flaskapp-v1 created
deployment.extensions/flaskapp-v2 created
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在rancher查看注入情况&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://wx4.sinaimg.cn/large/ad5fbf65ly1g1045ku3dcj20cj05kglp.jpg&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这里也可以使用&lt;code&gt;kubectl describe po flaskapp-v1-7d4f9b8459-2ncnf&lt;/code&gt;命令查看Pod容器，这里可以看到Pod中多了一个容器，名为&lt;code&gt;istio-proxy&lt;/code&gt;，这就表示注入成功了。而前面&lt;code&gt;istio-init&lt;/code&gt;的初始化容器，这个容器是用于初始化劫持的。&lt;/p&gt;

&lt;h3 id=&#34;部署客户端&#34;&gt;部署客户端&lt;/h3&gt;

&lt;p&gt;这里的客户端是一个安装了测试工具的镜像，测试的内容可以在容器内通过shell完成。代码文件为 &lt;code&gt;sleep.istio.yaml&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;image:
  caption: &amp;quot;Image from: [**Pexels**](https://www.pexels.com)&amp;quot;
  focal_point: &amp;quot;&amp;quot;
  preview_only: false
---
apiVersion: v1
kind: Service
metadata:
name: sleep
labels:
    app: sleep
    version: v1
spec:
selector:
    app: sleep
    version: v1
ports:
- name: ssh
    port: 80
image:
  caption: &amp;quot;Image from: [**Pexels**](https://www.pexels.com)&amp;quot;
  focal_point: &amp;quot;&amp;quot;
  preview_only: false
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
name: sleep
spec:
replicas: 1
template:
    metadata:
    labels:
        app: sleep
        version: v1
    spec:
    containers:
    - name: sleep
        image: dustise/sleep
        imagePullPolicy: IfNotPresent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;istio注入并部署客户端&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ istioctl kube-inject -f sleep.istio.yaml | kubectl apply -f -
service/sleep created
deployment.extensions/sleep created
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;sleep&lt;/code&gt;应用的Pod进入Running状态就可以进行验证了&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;验证服务&#34;&gt;验证服务&lt;/h3&gt;

&lt;p&gt;直接在sleep容器中执行命令行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ for i in `seq 10`;do http --body http://flaskapp/env/version;done
v1
v2
...
v1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该命令使用一个for循环，重复访问 &lt;a href=&#34;http://flaskapp/env/version&#34; target=&#34;_blank&#34;&gt;http://flaskapp/env/version&lt;/a&gt; ，查看内容，结果为 v1 和 v2 随机出现，各占一半。出现 v1 和 v2 版本轮流调用的效果，达到了基本的负载均衡的功能。&lt;/p&gt;

&lt;h3 id=&#34;创建目标规则&#34;&gt;创建目标规则&lt;/h3&gt;

&lt;p&gt;目标规则代码 &lt;code&gt;flaskapp-destinationrule.yaml&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
name: flaskapp
spec:
host: flaskapp
subsets:
- name: v1
    labels:
    version: v1
- name: v2
    labels:
    version: v2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;部署目标规则（这里使用kubectl和istioctl均可）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl apply -f flaskapp-destinationrule.yaml
Created config destination-rule/default/flaskapp at revision 59183403
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;创建默认路由&#34;&gt;创建默认路由&lt;/h3&gt;

&lt;p&gt;默认路由代码 &lt;code&gt;flaskapp-default-vs-v2.yaml&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: flaskapp-default-v2
spec:
hosts: 
- flaskapp
http:
- route:
    - destination:
    host: flaskapp
    subset: v2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;部署默认路由&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl apply -f flaskapp-default-vs-v2.yaml
Created config virtual-service/default/flaskapp-default-v2 at revision 59185583
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;验证路由规则是否生效&#34;&gt;验证路由规则是否生效&lt;/h3&gt;

&lt;p&gt;再次在sleep容器中执行命令，查看新定义的流量管理规则是否生效&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ for i in `seq 10`;do http --body http://flaskapp/env/version;done
v2
v2
v2
v2
v2
v2
v2
v2
v2
v2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里就可以看到，设置的默认路由已经生效了，多次重复访问，返回的内容都是来自环境变量 version 设置为 v2 的版本，也就是v2版本。&lt;/p&gt;

&lt;h4 id=&#34;kiali查看调用情况&#34;&gt;kiali查看调用情况&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;http://wx4.sinaimg.cn/large/ad5fbf65ly1g104tydblxj21az0li40i.jpg&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到流量都进入了v2版本中&lt;/p&gt;

&lt;h3 id=&#34;小结&#34;&gt;小结&lt;/h3&gt;

&lt;p&gt;这里实现了一个极简的istio应用，可以帮助新手快速入门，官网提供的Bookinfo应用较为复杂。这里提供的小例子更为简洁易懂，非常利于入门。&lt;/p&gt;

&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/fleeto/istio-for-beginner&#34; target=&#34;_blank&#34;&gt;《深入浅出Istio》&lt;/a&gt;    &amp;mdash;   崔秀龙&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
