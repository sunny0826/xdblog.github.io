<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kubernetes on GuoXD Blog</title>
    <link>https://guoxudong.io/en/categories/kubernetes/</link>
    <description>Recent content in Kubernetes on GuoXD Blog</description>
    <generator>Source Themes academia (https://sourcethemes.com/academic/)</generator>
    <language>en-us</language>
    <copyright>&lt;a rel=&#39;license&#39; href=&#39;http://creativecommons.org/licenses/by-nc/4.0/&#39; target=&#39;_blank&#39;&gt;知识共享署名-非商业性使用 4.0 国际许可协议&lt;/a&gt;</copyright>
    <lastBuildDate>Thu, 02 Jul 2020 13:51:14 +0800</lastBuildDate>
    
	    <atom:link href="https://guoxudong.io/en/categories/kubernetes/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>基于 Flagger 和 Nginx-Ingress 实现金丝雀发布</title>
      <link>https://guoxudong.io/en/post/flagger-nginx-ingress/</link>
      <pubDate>Thu, 02 Jul 2020 13:51:14 +0800</pubDate>
      
      <guid>https://guoxudong.io/en/post/flagger-nginx-ingress/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;很久之前我写过一篇介绍使用 Nginx-Ingress 实现蓝绿部署和金丝雀发布的文章，但那篇文章只是介绍了 nginx-ingress 具备这些能力，真正应用还要很多额外的配置和操作，况且现在能实现这些功能的并不只有 nginx-ingress，Service Mesh 工具如：Istio，App Mesh，Linkerd；Ingress Controller 如：Contour，Gloo，NGINX 都能实现，而我们需要的更多是进行金丝雀发布之后指标的监控，流量的调整以及出现问题后的及时回滚。而 Flagger 就是这样一个帮助我们解决上面这些问题的开源工具。&lt;/p&gt;
&lt;h2 id=&#34;flagger&#34;&gt;Flagger&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/weaveworks/flagger&#34;&gt;Flagger&lt;/a&gt; 是一种渐进式交付工具，可自动控制 Kubernetes 上应用程序的发布过程。通过指标监控和运行一致性测试，将流量逐渐切换到新版本，降低在生产环境中发布新软件版本导致的风险。&lt;/p&gt;
&lt;p&gt;Flagger 使用 Service Mesh（App Mesh，Istio，Linkerd）或 Ingress Controller（Contour，Gloo，NGINX）来实现多种部署策略（金丝雀发布，A/B 测试，蓝绿发布）。对于发布分析，Flagger 可以查询 Prometheus、Datadog 或 CloudWatch，并使用 Slack、MS Teams、Discord 和 Rocket 来发出告警通知。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文主要介绍 Flagger 使用 Nginx-Ingress 进行金丝雀发布并监控发布状态，更多内容见&lt;a href=&#34;https://docs.flagger.app/&#34;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://tvax4.sinaimg.cn/large/ad5fbf65ly1ggclsv45tqj21ok0skwfb.jpg&#34; alt=&#34;Flagger NGINX Ingress Controller&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;前提条件&#34;&gt;前提条件&lt;/h3&gt;
&lt;h4 id=&#34;版本要求&#34;&gt;版本要求&lt;/h4&gt;
&lt;p&gt;安装 Flagger 需要 Kubernetes 版本高于 &lt;strong&gt;v1.14&lt;/strong&gt;，NGINX ingress 版本高于 &lt;strong&gt;0.24&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;安装-nginx-ingress&#34;&gt;安装 NGINX ingress&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ kubectl create ns ingress-nginx
$ helm upgrade -i nginx-ingress stable/nginx-ingress &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;--namespace ingress-nginx &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;--set controller.metrics.enabled&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;true &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;--set controller.podAnnotations.&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;prometheus\.io/scrape&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;true &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;--set controller.podAnnotations.&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;prometheus\.io/port&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10254&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;安装部署&#34;&gt;安装部署&lt;/h3&gt;
&lt;h4 id=&#34;flagger-安装&#34;&gt;Flagger 安装&lt;/h4&gt;
&lt;p&gt;Flagger 提供了 Hlem 和 Kustomize 两种安装方式，这里使用 Helm 3 安装：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ helm repo add flagger https://flagger.app
$ helm upgrade -i flagger flagger/flagger &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;--namespace ingress-nginx &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;--set prometheus.install&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;true &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;--set meshProvider&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;nginx &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;--set slack.url&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;--set slack.channel&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;flagger &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;--set slack.user&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;flagger
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;值得注意的是这里我选择了 Slack 作为通知软件，需要在自己的 &lt;code&gt;#channel&lt;/code&gt; 内新增一个 APP，并将该 APP 的 &lt;code&gt;url&lt;/code&gt;、&lt;code&gt;channel&lt;/code&gt;、&lt;code&gt;user&lt;/code&gt; 填入上面的命令中。这里设置的是全局通知，集群中的 Flagger 被触发后都会进行通知，当然也可以为单个 Flagger 配置专门的通知，这里就不做过多介绍，详情见&lt;a href=&#34;https://docs.flagger.app/usage/alerting&#34;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&#34;示例安装&#34;&gt;示例安装&lt;/h4&gt;
&lt;p&gt;新建测试 namespace：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ kubectl create ns test
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;部署示例 deployment 和 horizontal pod autoscaler：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ kubectl apply -k github.com/weaveworks/flagger//kustomize/podinfo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;部署负载测试器，以便在金丝雀发布时进行流量分析：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ helm upgrade -i flagger-loadtester flagger/loadtester --namespace&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;test
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;部署 ingress，这里的 &lt;code&gt;app.example.com&lt;/code&gt; 需要改成你自己的域名，如果是在本地进行测试，则修改本机和负载测试器所在节点的 &lt;code&gt;/ect/hosts&lt;/code&gt;，将其指向你的 ADDRESS，否则将无法进行流量分析，导致部署失败。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;apiVersion&lt;/span&gt;: networking.k8s.io/v1beta1
&lt;span style=&#34;color:#66d9ef&#34;&gt;kind&lt;/span&gt;: Ingress
&lt;span style=&#34;color:#66d9ef&#34;&gt;metadata&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: podinfo
  &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt;: test
  &lt;span style=&#34;color:#66d9ef&#34;&gt;labels&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;app&lt;/span&gt;: podinfo
  &lt;span style=&#34;color:#66d9ef&#34;&gt;annotations&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;kubernetes.io/ingress.class&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;nginx&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;spec&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;rules&lt;/span&gt;:
    - &lt;span style=&#34;color:#66d9ef&#34;&gt;host&lt;/span&gt;: app.example.com
      &lt;span style=&#34;color:#66d9ef&#34;&gt;http&lt;/span&gt;:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;paths&lt;/span&gt;:
          - &lt;span style=&#34;color:#66d9ef&#34;&gt;backend&lt;/span&gt;:
              &lt;span style=&#34;color:#66d9ef&#34;&gt;serviceName&lt;/span&gt;: podinfo
              &lt;span style=&#34;color:#66d9ef&#34;&gt;servicePort&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;80&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将以上内容另存为 &lt;code&gt;podinfo-ingress.yaml&lt;/code&gt;，然后应用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ kubectl apply -f ./podinfo-ingress.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;创建一个 Canary 资源：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;apiVersion&lt;/span&gt;: flagger.app/v1beta1
&lt;span style=&#34;color:#66d9ef&#34;&gt;kind&lt;/span&gt;: Canary
&lt;span style=&#34;color:#66d9ef&#34;&gt;metadata&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: podinfo
  &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt;: test
&lt;span style=&#34;color:#66d9ef&#34;&gt;spec&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;provider&lt;/span&gt;: nginx
  &lt;span style=&#34;color:#75715e&#34;&gt;# deployment reference&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;targetRef&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;apiVersion&lt;/span&gt;: apps/v1
    &lt;span style=&#34;color:#66d9ef&#34;&gt;kind&lt;/span&gt;: Deployment
    &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: podinfo
  &lt;span style=&#34;color:#75715e&#34;&gt;# ingress reference&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;ingressRef&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;apiVersion&lt;/span&gt;: networking.k8s.io/v1beta1
    &lt;span style=&#34;color:#66d9ef&#34;&gt;kind&lt;/span&gt;: Ingress
    &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: podinfo
  &lt;span style=&#34;color:#75715e&#34;&gt;# HPA reference (optional)&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;autoscalerRef&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;apiVersion&lt;/span&gt;: autoscaling/v2beta1
    &lt;span style=&#34;color:#66d9ef&#34;&gt;kind&lt;/span&gt;: HorizontalPodAutoscaler
    &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: podinfo
  &lt;span style=&#34;color:#75715e&#34;&gt;# the maximum time in seconds for the canary deployment&lt;/span&gt;
  &lt;span style=&#34;color:#75715e&#34;&gt;# to make progress before it is rollback (default 600s)&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;progressDeadlineSeconds&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;60&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;service&lt;/span&gt;:
    &lt;span style=&#34;color:#75715e&#34;&gt;# ClusterIP port number&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;port&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;80&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;# container port number or name&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;targetPort&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;9898&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;analysis&lt;/span&gt;:
    &lt;span style=&#34;color:#75715e&#34;&gt;# 时间间隔 (默认 60s)&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;interval&lt;/span&gt;: 10s
    &lt;span style=&#34;color:#75715e&#34;&gt;# 回滚前的最大失败指标检查次数&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;threshold&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;# 路由到金丝雀副本的最大流量百分比&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;# 百分比 (0-100)&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;maxWeight&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;# 金丝雀每次递增的百分比&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;# 百分比 (0-100)&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;stepWeight&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;# NGINX Prometheus checks&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;metrics&lt;/span&gt;:
    - &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: request-success-rate
      &lt;span style=&#34;color:#75715e&#34;&gt;# minimum req success rate (non 5xx responses)&lt;/span&gt;
      &lt;span style=&#34;color:#75715e&#34;&gt;# percentage (0-100)&lt;/span&gt;
      &lt;span style=&#34;color:#66d9ef&#34;&gt;thresholdRange&lt;/span&gt;:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;min&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;99&lt;/span&gt;
      &lt;span style=&#34;color:#66d9ef&#34;&gt;interval&lt;/span&gt;: 1m
    &lt;span style=&#34;color:#75715e&#34;&gt;# testing (optional)&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;webhooks&lt;/span&gt;:
      - &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: acceptance-test
        &lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt;: pre-rollout
        &lt;span style=&#34;color:#66d9ef&#34;&gt;url&lt;/span&gt;: http://flagger-loadtester.test/
        &lt;span style=&#34;color:#66d9ef&#34;&gt;timeout&lt;/span&gt;: 30s
        &lt;span style=&#34;color:#66d9ef&#34;&gt;metadata&lt;/span&gt;:
          &lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt;: bash
          &lt;span style=&#34;color:#66d9ef&#34;&gt;cmd&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;curl -sd &amp;#39;test&amp;#39; http://podinfo-canary/token | grep token&amp;#34;&lt;/span&gt;
      - &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: load-test
        &lt;span style=&#34;color:#66d9ef&#34;&gt;url&lt;/span&gt;: http://flagger-loadtester.test/
        &lt;span style=&#34;color:#66d9ef&#34;&gt;timeout&lt;/span&gt;: 5s
        &lt;span style=&#34;color:#66d9ef&#34;&gt;metadata&lt;/span&gt;:
          &lt;span style=&#34;color:#66d9ef&#34;&gt;cmd&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hey -z 1m -q 10 -c 2 http://app.example.com/&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将以上内容另存为 &lt;code&gt;podinfo-canary.yaml&lt;/code&gt;，然后应用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ kubectl apply -f ./podinfo-canary.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;目前可以看到示例应用 &lt;code&gt;podinfo&lt;/code&gt; 已经安装完毕，并出现了 &lt;code&gt;podinfo&lt;/code&gt; 和 &lt;code&gt;podinfo-primary&lt;/code&gt; 两个版本，并且 &lt;code&gt;http://app.example.com/&lt;/code&gt; 已经可以访问：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ kubectl get deploy,svc,ing -n test
NAME                                 READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/flagger-loadtester   1/1     &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;           29h
deployment.apps/podinfo              0/0     &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;           29h
deployment.apps/podinfo-primary      2/2     &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;           29s

NAME                         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;S&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;   AGE
service/flagger-loadtester   ClusterIP   10.43.116.74    &amp;lt;none&amp;gt;        80/TCP    29h
service/podinfo              ClusterIP   10.43.155.193   &amp;lt;none&amp;gt;        80/TCP    9s
service/podinfo-canary       ClusterIP   10.43.194.226   &amp;lt;none&amp;gt;        80/TCP    29s
service/podinfo-primary      ClusterIP   10.43.254.13    &amp;lt;none&amp;gt;        80/TCP    29s

NAME                                HOSTS             ADDRESS                       PORTS   AGE
ingress.extensions/podinfo          app.example.com   192.168.1.129,192.168.4.210   &lt;span style=&#34;color:#ae81ff&#34;&gt;80&lt;/span&gt;      5h17m
ingress.extensions/podinfo-canary   app.example.com                                 &lt;span style=&#34;color:#ae81ff&#34;&gt;80&lt;/span&gt;      9s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个页面会展示 &lt;code&gt;podinfo&lt;/code&gt; 的版本已经其正在访问的 pod 名称：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva4.sinaimg.cn/large/ad5fbf65ly1ggcndtuqzsj21ha0q940s.jpg&#34; alt=&#34;app.example.com&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;自动金丝雀发布&#34;&gt;自动金丝雀发布&lt;/h3&gt;
&lt;p&gt;现在起发布由 Flagger 控制，在部署新版本后，Flagger 自动将流量按照比例切换到新版本上，同时监控性能指标，例如 HTTP 请求的成功率、请求的平均持续时间和 pod 运行状态，经过分析后提升流量或者回滚，并通知到 Slack。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva4.sinaimg.cn/large/ad5fbf65ly1ggcng8c8vnj21q40t6q3n.jpg&#34; alt=&#34;自动金丝雀发布&#34;&gt;&lt;/p&gt;
&lt;p&gt;通过更新镜像版本触发金丝雀部署：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ kubectl -n test set image deployment/podinfo podinfod&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;stefanprodan/podinfo:3.1.1
deployment.apps/podinfo image updated
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到初始化完成后已经有 5% 的流量切换到新版本了&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ kubectl -n test describe canary/podinfo
...
Status:
  Canary Weight:  &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;
  Conditions:
    Last Transition Time:  2020-07-02T07:21:26Z
    Last Update Time:      2020-07-02T07:21:26Z
    Message:               New revision detected, progressing canary analysis.
    Reason:                Progressing
    Status:                Unknown
    Type:                  Promoted
  Failed Checks:           &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
  Iterations:              &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
  Last Applied Spec:       c8bdf98d5
  Last Transition Time:    2020-07-02T07:22:05Z
  Phase:                   Progressing
  Tracked Configs:
Events:
  Type     Reason  Age                From     Message
  ----     ------  ----               ----     -------
  Warning  Synced  10m                flagger  podinfo-primary.test not ready: waiting &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; rollout to finish: observed deployment generation less &lt;span style=&#34;color:#66d9ef&#34;&gt;then&lt;/span&gt; desired generation
  Warning  Synced  10m                flagger  podinfo-primary.test not ready: waiting &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; rollout to finish: &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; of &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; updated replicas are available
  Normal   Synced  10m &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;x3 over 10m&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;  flagger  all the metrics providers are available!
  Normal   Synced  10m                flagger  Initialization &lt;span style=&#34;color:#66d9ef&#34;&gt;done&lt;/span&gt;! podinfo.test
  Normal   Synced  41s                flagger  New revision detected! Scaling up podinfo.test
  Warning  Synced  31s                flagger  canary deployment podinfo.test not ready: waiting &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; rollout to finish: &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; of &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; updated replicas are available
  Warning  Synced  21s                flagger  canary deployment podinfo.test not ready: waiting &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; rollout to finish: &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; of &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; updated replicas are available
  Warning  Synced  11s                flagger  canary deployment podinfo.test not ready: waiting &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; rollout to finish: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; of &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; updated replicas are available
  Normal   Synced  1s                 flagger  Starting canary analysis &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; podinfo.test
  Normal   Synced  1s                 flagger  Pre-rollout check acceptance-test passed
  Normal   Synced  1s                 flagger  Advance podinfo.test canary weight &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用 &lt;code&gt;watch&lt;/code&gt; 也能实时看到部署流量的权重，根据上面的设置，新版本权重大于 50% 就认为部署成功，流量将全部切换到新版本，并完成金丝雀部署：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ watch kubectl get canaries --all-namespaces
Every 2.0s: kubectl get canaries --all-namespaces                                     guoxudongdeMacBook-Pro.local: Thu Jul  &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; 15:23:35 &lt;span style=&#34;color:#ae81ff&#34;&gt;2020&lt;/span&gt;

NAMESPACE   NAME      STATUS        WEIGHT   LASTTRANSITIONTIME
test        podinfo   Progressing   &lt;span style=&#34;color:#ae81ff&#34;&gt;45&lt;/span&gt;       2020-07-02T07:23:25Z
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;开始部署时的 Slack 通知：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tvax3.sinaimg.cn/large/ad5fbf65ly1ggcnsojp0kj20kj07kdgc.jpg&#34; alt=&#34;Slack 通知&#34;&gt;&lt;/p&gt;
&lt;p&gt;页面上也能看出变化，访问到新版本的概率会越来越高，以蓝色和绿色的圆代表新版本和老版本：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tvax2.sinaimg.cn/large/ad5fbf65ly1ggco0nxzdrj21h80q8gnu.jpg&#34; alt=&#34;金丝雀发布&#34;&gt;&lt;/p&gt;
&lt;p&gt;发布成功后，会收到 Slack 通知：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva2.sinaimg.cn/large/ad5fbf65ly1ggco2mdlphj20kq01h0sn.jpg&#34; alt=&#34;Slack 通知&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;自动回滚&#34;&gt;自动回滚&lt;/h3&gt;
&lt;p&gt;当然，有自动发布就会有自动回滚，下面就通过手动触发状态码 500 异常，演示暂停发布并回滚。&lt;/p&gt;
&lt;p&gt;部署一个新版本：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ kubectl -n test set image deployment/podinfo podinfod&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;stefanprodan/podinfo:3.1.2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;触发状态码 500 异常：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ watch curl http://app.example.com/status/500
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;等待一会儿，就可以看到部署失败并回滚：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ watch kubectl get canaries --all-namespaces
Every 2.0s: kubectl get canaries --all-namespaces                                     guoxudongdeMacBook-Pro.local: Thu Jul  &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; 15:45:24 &lt;span style=&#34;color:#ae81ff&#34;&gt;2020&lt;/span&gt;

NAMESPACE   NAME      STATUS   WEIGHT   LASTTRANSITIONTIME
test        podinfo   Failed   &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;        2020-07-02T07:45:16Z
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;发布失败，也会收到 Slack 通知：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva3.sinaimg.cn/large/ad5fbf65ly1ggcobt1f0bj20kd01vmx1.jpg&#34; alt=&#34;失败 Slack 通知&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;ab-测试&#34;&gt;A/B 测试&lt;/h3&gt;
&lt;p&gt;除了加权路由，Flagger 还可以根据 HTTP 匹配条件将流量路由到新版本（当然，这个 Nginx-Ingress 的功能，Flagger 只是简化了操作）。可以根据 HTTP header 和 cookie 来定位用户并细分受众，对于需要关联会话的前端应用十分有用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/ad5fbf65ly1ggcoglbmnyj217q0q0q3h.jpg&#34; alt=&#34;A/B 测试&#34;&gt;&lt;/p&gt;
&lt;p&gt;修改 Canary 资源：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;apiVersion&lt;/span&gt;: flagger.app/v1beta1
&lt;span style=&#34;color:#66d9ef&#34;&gt;kind&lt;/span&gt;: Canary
&lt;span style=&#34;color:#66d9ef&#34;&gt;metadata&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: podinfo
  &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt;: test
&lt;span style=&#34;color:#66d9ef&#34;&gt;spec&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;provider&lt;/span&gt;: nginx
  &lt;span style=&#34;color:#75715e&#34;&gt;# deployment reference&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;targetRef&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;apiVersion&lt;/span&gt;: apps/v1
    &lt;span style=&#34;color:#66d9ef&#34;&gt;kind&lt;/span&gt;: Deployment
    &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: podinfo
  &lt;span style=&#34;color:#75715e&#34;&gt;# ingress reference&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;ingressRef&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;apiVersion&lt;/span&gt;: networking.k8s.io/v1beta1
    &lt;span style=&#34;color:#66d9ef&#34;&gt;kind&lt;/span&gt;: Ingress
    &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: podinfo
  &lt;span style=&#34;color:#75715e&#34;&gt;# HPA reference (optional)&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;autoscalerRef&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;apiVersion&lt;/span&gt;: autoscaling/v2beta1
    &lt;span style=&#34;color:#66d9ef&#34;&gt;kind&lt;/span&gt;: HorizontalPodAutoscaler
    &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: podinfo
  &lt;span style=&#34;color:#75715e&#34;&gt;# the maximum time in seconds for the canary deployment&lt;/span&gt;
  &lt;span style=&#34;color:#75715e&#34;&gt;# to make progress before it is rollback (default 600s)&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;progressDeadlineSeconds&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;60&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;service&lt;/span&gt;:
    &lt;span style=&#34;color:#75715e&#34;&gt;# ClusterIP port number&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;port&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;80&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;# container port number or name&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;targetPort&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;9898&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;analysis&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;interval&lt;/span&gt;: 1m
    &lt;span style=&#34;color:#66d9ef&#34;&gt;threshold&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;iterations&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;match&lt;/span&gt;:
      &lt;span style=&#34;color:#75715e&#34;&gt;# curl -H &amp;#39;X-Canary: insider&amp;#39; http://app.example.com&lt;/span&gt;
      - &lt;span style=&#34;color:#66d9ef&#34;&gt;headers&lt;/span&gt;:
          &lt;span style=&#34;color:#66d9ef&#34;&gt;x-canary&lt;/span&gt;:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;exact&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;insider&amp;#34;&lt;/span&gt;
      &lt;span style=&#34;color:#75715e&#34;&gt;# curl -b &amp;#39;canary=always&amp;#39; http://app.example.com&lt;/span&gt;
      - &lt;span style=&#34;color:#66d9ef&#34;&gt;headers&lt;/span&gt;:
          &lt;span style=&#34;color:#66d9ef&#34;&gt;cookie&lt;/span&gt;:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;exact&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;canary&amp;#34;&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;metrics&lt;/span&gt;:
    - &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: request-success-rate
      &lt;span style=&#34;color:#66d9ef&#34;&gt;thresholdRange&lt;/span&gt;:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;min&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;99&lt;/span&gt;
      &lt;span style=&#34;color:#66d9ef&#34;&gt;interval&lt;/span&gt;: 1m
    &lt;span style=&#34;color:#66d9ef&#34;&gt;webhooks&lt;/span&gt;:
      - &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: load-test
        &lt;span style=&#34;color:#66d9ef&#34;&gt;url&lt;/span&gt;: http://flagger-loadtester.test/
        &lt;span style=&#34;color:#66d9ef&#34;&gt;timeout&lt;/span&gt;: 5s
        &lt;span style=&#34;color:#66d9ef&#34;&gt;metadata&lt;/span&gt;:
          &lt;span style=&#34;color:#66d9ef&#34;&gt;cmd&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hey -z 1m -q 10 -c 2 -H &amp;#39;Cookie: canary=always&amp;#39; http://app.example.com/&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从上面的配置可以看到，将 headers 为 &lt;code&gt;X-Canary: insider&lt;/code&gt; 或 cookie 为 &lt;code&gt;canary=always&lt;/code&gt; 的请求路由到新版本。&lt;/p&gt;
&lt;p&gt;部署一个新版本：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ kubectl -n test set image deployment/podinfo podinfod&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;stefanprodan/podinfo:3.1.3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以收到 Slack 通知：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva4.sinaimg.cn/large/ad5fbf65gy1ggcorvilrrj20kb07wdgb.jpg&#34; alt=&#34;A/B 测试 Slack 通知&#34;&gt;&lt;/p&gt;
&lt;p&gt;正常访问，还是访问到老的 &lt;code&gt;v3.1.1&lt;/code&gt; 版：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ curl http://app.example.com
&lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hostname&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;podinfo-primary-5dc6b76bd5-8sbh8&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;version&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;3.1.1&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;revision&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;7b6f11780ab1ce8c7399da32ec6966215b8e43aa&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;color&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;#34577c&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;logo&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;https://raw.githubusercontent.com/stefanprodan/podinfo/gh-pages/cuddle_clap.gif&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;message&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;greetings from podinfo v3.1.1&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;goos&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;linux&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;goarch&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;amd64&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;runtime&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;go1.13.1&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;num_goroutine&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;11&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;num_cpu&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;6&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;请求添加指定 header，访问到新的 &lt;code&gt;v3.1.3&lt;/code&gt; 版：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ curl -H &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;X-Canary: insider&amp;#39;&lt;/span&gt; http://app.example.com
&lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hostname&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;podinfo-58bdd78d6f-m9bsc&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;version&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;3.1.3&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;revision&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;7b6f11780ab1ce8c7399da32ec6966215b8e43aa&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;color&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;#34577c&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;logo&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;https://raw.githubusercontent.com/stefanprodan/podinfo/gh-pages/cuddle_clap.gif&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;message&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;greetings from podinfo v3.1.3&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;goos&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;linux&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;goarch&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;amd64&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;runtime&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;go1.13.1&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;num_goroutine&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;10&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;num_cpu&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;6&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;请求添加指定 cookie，访问到新的 &lt;code&gt;v3.1.3&lt;/code&gt; 版：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ curl -b &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;canary=always&amp;#39;&lt;/span&gt; http://app.example.com
&lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hostname&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;podinfo-58bdd78d6f-m9bsc&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;version&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;3.1.3&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;revision&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;7b6f11780ab1ce8c7399da32ec6966215b8e43aa&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;color&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;#34577c&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;logo&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;https://raw.githubusercontent.com/stefanprodan/podinfo/gh-pages/cuddle_clap.gif&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;message&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;greetings from podinfo v3.1.3&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;goos&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;linux&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;goarch&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;amd64&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;runtime&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;go1.13.1&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;num_goroutine&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;10&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;num_cpu&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;6&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在浏览器中访问也能得到相同的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva3.sinaimg.cn/large/ad5fbf65gy1ggcoy65l47j20yb0dvq49.jpg&#34; alt=&#34;添加 cookie 在浏览器中访问&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;
&lt;p&gt;最早了解 Flagger 其实是因为其与 Istio 的关系，Flagger 默认的 meshProvider 就是 Istio。但是在深入了解后，发现其对市面上常见的 Service Mesh 和 Ingress Controller 都有较好的支持，通过与 Prometheus 以及负载测试器的配合可以进行细粒度的分析，从而提高了发布质量，同时还降低了人工操作出错的可能性。&lt;/p&gt;
&lt;p&gt;最近 &lt;a href=&#34;https://oam.dev/&#34;&gt;OAM 社区&lt;/a&gt;也放出了基于 Flagger 的部署 Trait 的示例，相信之后与 OAM 结合使用可以在持续部署和应用管理领域发挥更大的作用。&lt;/p&gt;
&lt;p&gt;想了解 OAM 可以查看我之前的文章：&lt;a href=&#34;../start-oam&#34;&gt;《以应用为中心：开放应用模型（OAM）初探》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva3.sinaimg.cn/large/ad5fbf65gy1gfm3j2vo79g20b90b9x6r.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>告别手写 Helm Chart README</title>
      <link>https://guoxudong.io/en/post/helm-docs/</link>
      <pubDate>Fri, 08 May 2020 11:20:01 +0800</pubDate>
      
      <guid>https://guoxudong.io/en/post/helm-docs/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;随着云原生应用的普及，Helm 的作用也日益凸显，越来越多的云原生应用以 Helm Chart 的形式发布，可以说现在如果没有一个 Helm Chart 都不好意思说自己是云原生应用。&lt;/p&gt;
&lt;p&gt;一个好的应用必定有一套好的文档，文档的质量往往和代码的质量成正比。而 Helm Chart 中的 &lt;code&gt;README.md&lt;/code&gt; 文件就承担了文档的作用，该文件会介绍这个 Helm Chart 的基本信息、使用方式以及参数配置等，用户可以通过该文档的指引，配置符合自己需求的参数，最终完成云原生应用的部署。&lt;/p&gt;
&lt;p&gt;但这也给云原生应用的开发者提出了挑战，开发者不但需要把 &lt;code&gt;value.yaml&lt;/code&gt; 和 &lt;code&gt;Chart.yaml&lt;/code&gt; 等文件的参数以 Markdown 的形式搬运到 &lt;code&gt;README.md&lt;/code&gt; 文件中，同时还要将参数的默认值，以及介绍填入表格中。但如果参数出现了变动，往往无法及时更新文档。这就导致了用户明明根据文档配置了参数，但是部署的效果就是无法达到预期。&lt;/p&gt;
&lt;h2 id=&#34;helm-docs&#34;&gt;Helm-docs&lt;/h2&gt;
&lt;p&gt;helm-docs 可以根据 charts 内容自动生成 markdown 文件。该文件会包含有关 charts 的元数据，以及 &lt;code&gt;value.yaml&lt;/code&gt; 中的参数，同时还可以引用子模板（默认为 &lt;code&gt;README.md.gotmpl&lt;/code&gt;），进一步定制生成的内容。&lt;/p&gt;
&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/norwoodj/helm-docs&#34;&gt;helm-docs&lt;/a&gt; 使用 golang 开发，支持多平台：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MacOS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以使用 homebrew 安装：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;brew install norwoodj/tap/helm-docs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;下载可执行文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;到 &lt;a href=&#34;https://github.com/norwoodj/helm-docs/releases&#34;&gt;release&lt;/a&gt; 页面下载对应平台的可执行文件。&lt;/p&gt;
&lt;h3 id=&#34;快速开始&#34;&gt;快速开始&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;直接使用可执行文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用方法也很简单，直接进入到 Chart 所在目录，执行命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm-docs
&lt;span style=&#34;color:#75715e&#34;&gt;# 或者&lt;/span&gt;
helm-docs --dry-run &lt;span style=&#34;color:#75715e&#34;&gt;# 不生成 README.md 文件，而是将生成的内容打印到控制台&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;使用 docker&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果不想安装可执行文件，也可以使用 docker，将 Chart 目录挂载到 docker 镜像中，实现相同的效果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker run -v &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;pwd&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;:/helm-docs&amp;#34;&lt;/span&gt; jnorwood/helm-docs:latest
&lt;span style=&#34;color:#75715e&#34;&gt;# 或者&lt;/span&gt;
docker run -v &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;pwd&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;:/helm-docs&amp;#34;&lt;/span&gt; jnorwood/helm-docs:latest --dry-run
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;进阶实践&#34;&gt;进阶实践&lt;/h3&gt;
&lt;p&gt;下面就以我的开源项目 &lt;a href=&#34;https://github.com/sunny0826/cms-grafana-builder&#34;&gt;cms-grafana-builder&lt;/a&gt; 为例，讲解 helm-docs 的一些进阶使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;添加参数说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;helm-docs 可以通过 &lt;code&gt;value.yaml&lt;/code&gt; 中的注释生成参数说明，注释格式如下所示，&lt;code&gt;--&lt;/code&gt; 后的内容会自动填充到 Chart Values 的 Description 中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# access_key_id -- Aliyun Access Key Id.&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;access_key_id&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# access_secret -- Aliyun Access Secret.&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;access_secret&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# region_id -- Aliyun Region Id.&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;region_id&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cn-shanghai&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# password -- Grafana admin password.&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;password&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;admin&amp;#34;&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;image&lt;/span&gt;:
  &lt;span style=&#34;color:#75715e&#34;&gt;# image.repository -- Image source repository name.&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: grafana/grafana
  &lt;span style=&#34;color:#75715e&#34;&gt;# image.pullPolicy -- Image pull policy.&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;pullPolicy&lt;/span&gt;: IfNotPresent
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;自定义模板&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以新建 &lt;code&gt;README.md.gotmpl&lt;/code&gt; 模板来进一步定制 &lt;code&gt;README.md&lt;/code&gt; 的输出样式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;README.md.gotmpl&lt;/code&gt; 文件的内容如下，可以在模板中插入 Markdown 来充实 &lt;code&gt;README.md&lt;/code&gt; 的内容，以及改变展示内容的顺序：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-golang&#34; data-lang=&#34;golang&#34;&gt;{{ &lt;span style=&#34;color:#a6e22e&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;chart.header&amp;#34;&lt;/span&gt; . }}
{{ &lt;span style=&#34;color:#a6e22e&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;chart.description&amp;#34;&lt;/span&gt; . }}

{{ &lt;span style=&#34;color:#a6e22e&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;chart.versionLine&amp;#34;&lt;/span&gt; . }}

{{ &lt;span style=&#34;color:#a6e22e&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;chart.sourceLinkLine&amp;#34;&lt;/span&gt; . }}

&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;##&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Introduction&lt;/span&gt;

&lt;span style=&#34;color:#a6e22e&#34;&gt;This&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chart&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;helps&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;you&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;grafana&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;server&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;that&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;aliyun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;cms&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dashboard&lt;/span&gt;.


{{ &lt;span style=&#34;color:#a6e22e&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;chart.requirementsSection&amp;#34;&lt;/span&gt; . }}

{{ &lt;span style=&#34;color:#a6e22e&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;chart.valuesSection&amp;#34;&lt;/span&gt; . }}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;helm-docs 可以帮助很多像我这样需要维护多个 Helm Chart 的开发者，在更新完或新建 Chart 以后，使用 &lt;code&gt;helm-docs&lt;/code&gt; 来自动生成 &lt;code&gt;README.md&lt;/code&gt; 文件，无需逐个寻找和修改，甚至将其集成到 CI 流水线中，自动生成最新的 &lt;code&gt;README.md&lt;/code&gt;，保证文档和代码的一致。&lt;/p&gt;
&lt;p&gt;更多内容和示例，详见 &lt;a href=&#34;https://github.com/norwoodj/helm-docs&#34;&gt;https://github.com/norwoodj/helm-docs&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>去指挥你的舰队吧！体验使用 Fleet 批量管理 K8S 集群</title>
      <link>https://guoxudong.io/en/post/rancher-fleet/</link>
      <pubDate>Thu, 23 Apr 2020 14:03:53 +0800</pubDate>
      
      <guid>https://guoxudong.io/en/post/rancher-fleet/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;最早听说到这个消息时，我还是很疑惑的，Fleet 不是 CoreOS 早已经停止维护的一个项目吗？怎么又和 Rancher Labs 扯上了关系？&lt;/p&gt;
&lt;p&gt;**“为用户提供海量 Kubernetes 集群的集中管理体验”**这句话是否言过其实：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“海量”这个量到底有多大？&lt;/li&gt;
&lt;li&gt;又有多少公司或团队有管理海量的 Kubernetes 集群的需求？&lt;/li&gt;
&lt;li&gt;又是怎么一个&lt;strong&gt;集中管理&lt;/strong&gt;法？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;带着这些疑问，我仔细了解了一下 Fleet 这个开源项目。&lt;/p&gt;
&lt;h2 id=&#34;fleet&#34;&gt;Fleet&lt;/h2&gt;
&lt;p&gt;首先，这里的 Fleet 是一个新项目，起这个名字应该算是一种致敬，经过了解后我个人觉得这个名字起的还是挺贴切的，比一大波 KubeXXX 有创意多了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“我一直是它的忠实粉丝，将这一项目命名为 Fleet 也包含了我的私心。”Darren Shepherd 解释道：“所以我希望重新使用 Fleet 这一名字，这是对这个非常出色的容器领域早期项目的致敬。同时，对于推动 Kubernetes 集群管理的演进，我们感到十分兴奋及万分期待。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;mdash; 摘自 RancherLabs 官方微信公众号《Rancher开源Fleet：业界首个海量K8S集群管理项目》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;顾名思义 Fleet 是“舰队”的意思，而 Kubernetes 在希腊语意为 “舵手”。从名称上看，Fleet 的目标就是管理或是指挥众多 Kubernetes 集群。而在了解这个项目时，我发现了这个项目和 Rancher Labs 另一个受欢迎项目 &lt;a href=&#34;https://k3s.io/&#34;&gt;k3s&lt;/a&gt; 有个千丝万缕的联系，甚至在我看来 Fleet 可能就是就是为了管理众多 k3s 集群而生的，是 Rancher Labs 布局边缘计算和 IoT 领域的重要组成部分。&lt;/p&gt;
&lt;p&gt;k3s 是一款轻量级的 Kubernetes 集群，主要面向边缘计算和 IOT 领域，相比原生 Kubernetes，k3s 体量更轻、部署简单且快速，同时还具有完整的 Kubernetes 体验。可以说只要是 Linux 系统（配合周边工具甚至可以运行在 Mac 和 Windows 系统），无论是树莓派、各种开发板还是 PC 机，都可以独立运行起 k3s，&lt;strong&gt;这也为运行海量 Kubernetes 集群&lt;/strong&gt;提供了可能。以汽车为例，我们可以为每一辆汽车都部署一个 k3s 集群，所有汽车相关的软件（导航、广播甚至是无人驾驶程序）都部署在 k3s 集群中，每次这些软件发布新版本，只需使用 Fleet 进行批量操作该种车型的所有 k3s 集群即可，无需将车开回 4S 店进行手动更新。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;解释了海量 Kubernetes 集群的疑问，下面就从 Fleet 的架构入手，讲讲如何&lt;strong&gt;集中管理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/ad5fbf65ly1ge3o40xe41j20qx0ljdm7.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Fleet 包含&lt;code&gt;Manager&lt;/code&gt;和&lt;code&gt;agent&lt;/code&gt;，&lt;code&gt;Manager&lt;/code&gt;所在集群作为控制平面管理所有&lt;code&gt;agent&lt;/code&gt;集群，同时 Fleet 根据 Kubernetes 部署 Pod 的模型，定义了一个 Bundles 对象，并且提供了一种内置机制，可以使用诸如&lt;code&gt;Helm&lt;/code&gt;和&lt;code&gt;Kustomize&lt;/code&gt;等行业标准工具为每个目标集群定制 Bundles，在我看来这种模式以及&lt;code&gt;bundle.yaml&lt;/code&gt;的写法都和&lt;code&gt;Kustomize&lt;/code&gt;很像(套娃行为？)&amp;hellip;一旦用户在集群之间部署了 Bundles，Fleet 就会主动监视资源是否已就绪，以及是否被更改过。总的来说就是通过部署 Bundles，就可以将部署内容批量分发到所有目标集群，从而达到&lt;strong&gt;集中管理&lt;/strong&gt;的目的。&lt;/p&gt;
&lt;h2 id=&#34;尝鲜体验&#34;&gt;尝鲜体验&lt;/h2&gt;
&lt;p&gt;说那么多其实意义不大，好不好用，只有试过才知道。这里使用的 Fleet 版本为&lt;code&gt;v0.2.0&lt;/code&gt;，是目前的最新版本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下载 CLI 工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先需要下载&lt;code&gt;fleet&lt;/code&gt;的 CLI 工具，这里的体验和 k3s 类似，都是直接&lt;code&gt;curl&lt;/code&gt; GitHub 上的安装脚本并执行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ curl -sfL https://raw.githubusercontent.com/rancher/fleet/master/install.sh | sh -
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;部署控制平面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 CLI 工具将&lt;code&gt;Fleet Manager&lt;/code&gt;部署到 Kubernetes 集群上：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Kubeconfig should point to Manager cluster&lt;/span&gt;
$ fleet install manager | kubectl apply -f -
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;生成 Cluster group token&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;到这控制平面就部署好了，接下来部署&lt;code&gt;agent&lt;/code&gt;目标集群。这里生成的其实是一个 yaml 文件，内容包含 fleet 需要的 RBAC 权限和 fleet-agent 的 Deployment：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Kubeconfig should point to Manager cluster&lt;/span&gt;
$ fleet install agent-token &amp;gt; token
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;目标集群注册&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将需要纳管的目标集群加入到 fleet 中，&lt;strong&gt;注意&lt;/strong&gt;：这里需要将 kubeconfig 切换到目标集群，也就是需要部署&lt;code&gt;agent&lt;/code&gt;的集，每个需要注册的集群都要部署&lt;code&gt;agent&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Kubeconfig should point to AGENT cluster&lt;/span&gt;
$ kubectl apply -f token
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;部署 bundles&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里就是向多个集群同时部署 bundles，使用方法也和&lt;code&gt;Kustomize&lt;/code&gt;类似（&lt;code&gt;example&lt;/code&gt; 目录是 fleet 官方仓库中的示例目录）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Kubeconfig should point to Manager cluster&lt;/span&gt;
$ fleet apply ./examples/helm-kustomize
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;查看状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在就可以查看所有集群 bundles 的状态了，这里可以看到 bundles 在多个集群都部署成功了（这里是我起的两个 k3s 集群做的测试）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ kubectl get fleet
NAME                                   CLUSTER-COUNT   BUNDLES-READY   BUNDLES-DESIRED   STATUS
clustergroup.fleet.cattle.io/default   &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;               &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;               &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;                 Modified: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;helm-kustomize &lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;

NAME                                    CLUSTERS-READY   CLUSTERS-DESIRED   STATUS
bundle.fleet.cattle.io/fleet-agent      &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;                &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
bundle.fleet.cattle.io/helm-kustomize   &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;                &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;                  Modified: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;default-default-group/cluster-5a186072-acbd-4f54-8f22-fb1651ce902f &lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;总的来说，Fleet 的架构简洁且十分轻量，部署方式简单，使用&lt;code&gt;YAML&lt;/code&gt;、&lt;code&gt;Helm&lt;/code&gt;、&lt;code&gt;Kustomez&lt;/code&gt;都可以进行资源的描述和配置，甚至可以使用&lt;code&gt;Helm&lt;/code&gt;+&lt;code&gt;Kustomeze&lt;/code&gt;的模式，部署体验不错。&lt;/p&gt;
&lt;p&gt;但遗憾的是，目前 Fleet 还处于项目早期，实践也仅限于尝鲜体验，并不能用于生产环境，项目 README 中还专门提到了&lt;strong&gt;目前 Fleet 仅适用于 10 个集群以下的小规模部署&lt;/strong&gt;。目前文档不足且项目维护人员并不积极，文档勘误的 &lt;a href=&#34;https://github.com/rancher/fleet/pull/32&#34;&gt;RP&lt;/a&gt; 和相关 ISSUE 也没有得到相关的反馈。项目是做到了业界首个，但是要真正生产可用甚至做到业界第一还有很长的一段路要走。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rancher/fleet&#34;&gt;Fleet - Github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/byErGqVBtm4kdv58OZFt_w&#34;&gt;Rancher开源Fleet：业界首个海量K8S集群管理项目 - RancherLabs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Katacoda：免费学习 Kubernetes 利器</title>
      <link>https://guoxudong.io/en/post/katacoda-k8s/</link>
      <pubDate>Fri, 27 Mar 2020 15:57:11 +0800</pubDate>
      
      <guid>https://guoxudong.io/en/post/katacoda-k8s/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近 ServiceMesher 社区重启了&lt;a href=&#34;https://github.com/servicemesher/istio-handbook&#34;&gt;《Istio 服务网格进阶实战》&lt;/a&gt; 的编写，我也作为编委会成员参与其中。该书的实践项目都基于 Istio 1.5 版本以及 Katacoda 提供的 Kubernetes 环境完成。由于实践部分都要使用 Katacoda，介绍 Katacoda 这章需要先完成，为其他参与编写实践篇的作者提供参考。&lt;/p&gt;
&lt;h2 id=&#34;katacoda&#34;&gt;Katacoda&lt;/h2&gt;
&lt;p&gt;Katacoda 是一个面向软件工程师的交互式学习和培训平台，可在浏览器中使用真实环境学习和测试新技术，帮助开发人员学习，并掌握最佳实践。该平台于 2019 年 11 月被 O&amp;rsquo;Reilly 收购。&lt;/p&gt;
&lt;p&gt;Katacoda 可以快速的提供一套完整的临时环境，并在使用后将其回收。用户可以根据设计好的引导步骤，通过浏览器上的终端界面操作一套完整的环境，一步步的学习和实践。尤其是在学习 Kubernetes 这种复杂的应用时，单单是创建一个集群就要花去不少时间，同时消耗的资源也令一些初学者望而生畏，Katacoda 的出现很好的解决了这些问题。课程设计者可以定制应用程序所需环境，并设计循序渐进的指导路径，旨在确保用户以最佳方式学习。&lt;/p&gt;
&lt;p&gt;在 Katacoda 每个用户都可以免费的学习和创建课程，其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Course：课程，可包含一系列的 scenarios。
&lt;ul&gt;
&lt;li&gt;官方教程入口：https://katacoda.com/scenario-examples/scenarios/create-course&lt;/li&gt;
&lt;li&gt;汉化教程入口：https://katacoda.com/guoxudong/courses/katacoda-example/create-course&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Scenarios：场景、方案。
&lt;ul&gt;
&lt;li&gt;官方教程入口：https://katacoda.com/scenario-examples/scenarios/create-scenario-101&lt;/li&gt;
&lt;li&gt;汉化教程入口：https://katacoda.com/guoxudong/courses/katacoda-example/katacoda-create-scenarios&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;使用-katacoda-学习&#34;&gt;使用 Katacoda 学习&lt;/h2&gt;
&lt;p&gt;Katacoda 提供了非常便利的学习方式，用户只需要打开相应课程，就可以跟着课程设计者的说明，按照设计好的步骤一步步完成学习。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;介绍会标明课程的难度和需要的时间，帮助用户了解该课程的基本信息：
&lt;img src=&#34;https://tvax1.sinaimg.cn/large/ad5fbf65gy1gd8k9b4jwoj21ha0q7wha.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进入课程，左侧是该步骤说明，右侧是一个已经准备好的终端，直接可以使用：
&lt;img src=&#34;https://tvax2.sinaimg.cn/large/ad5fbf65gy1gd8kdmfr3ej21h90qeq8s.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;之后就是跟着步骤说明，一步步的完成学习即可：
&lt;img src=&#34;https://tva3.sinaimg.cn/large/ad5fbf65gy1gd8kh1jcs1j21hb0q5do7.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;创建课程&#34;&gt;创建课程&lt;/h2&gt;
&lt;p&gt;既然可以学习别人设计好的课程，那么也可以自己设计课程，以供用户学习。&lt;/p&gt;
&lt;h3 id=&#34;新建仓库&#34;&gt;新建仓库&lt;/h3&gt;
&lt;p&gt;Katacoda 需要注册账号登录，这里直接使用 GitHub 账号登录即可，毕竟之后创建的方案都是存放在 GitHub 上的。&lt;/p&gt;
&lt;p&gt;这里推荐在页面新建仓库，访问 &lt;a href=&#34;https://www.katacoda.com/teach/git-hosted-scenarios&#34;&gt;https://www.katacoda.com/teach/git-hosted-scenarios&lt;/a&gt; ，点击 &lt;code&gt;Automatically Create and Configure Github Repository&lt;/code&gt; 按钮，Katacoda 会自动在您的 Github 中创建一个名为 &lt;code&gt;katacoda-scenarios&lt;/code&gt; 的仓库，并自动为您配置 Webhook，每次更新该仓库时，都会自动更新您 Katacoda 中课程的内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tvax3.sinaimg.cn/large/ad5fbf65gy1gd73rov21ij219q0pl42u.jpg&#34; alt=&#34;katacoda 新建仓库页面&#34;&gt;&lt;/p&gt;
&lt;p&gt;创建完成后，就可以在您的 Github 上找到名为 &lt;code&gt;katacoda-scenarios&lt;/code&gt; 的代码仓库。&lt;/p&gt;
&lt;h3 id=&#34;scenarios&#34;&gt;Scenarios&lt;/h3&gt;
&lt;p&gt;Scenarios 即为方案、场景，由一组 Markdown、bash 脚本和一个 JSON 文件组成，这些文件保存了该 Scenarios 的所有配置。&lt;/p&gt;
&lt;p&gt;Katacoda 官方提供了 CLI 工具，帮助您创建 Scenarios。&lt;/p&gt;
&lt;h4 id=&#34;安装-cli&#34;&gt;安装 CLI&lt;/h4&gt;
&lt;p&gt;通过 npm 命令安装 &lt;code&gt;npm i katacoda-cli --global&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;命令遵循语法的是 &lt;code&gt;$ katacoda COMMAND&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;安装完成后，可以通过运行命令 &lt;code&gt;katacoda --help&lt;/code&gt; 查看帮助信息。&lt;/p&gt;
&lt;h4 id=&#34;创建-scenarios-目录&#34;&gt;创建 Scenarios 目录&lt;/h4&gt;
&lt;p&gt;例如，要创建新的方案，可以通过运行命令 &lt;code&gt;katacoda scenarios:create&lt;/code&gt;，CLI 将会提示一些信息，帮助您创建方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Friendly URL:&lt;/strong&gt; 此处可输入 &lt;code&gt;test-scenario&lt;/code&gt;，该属性将确定 scenarios 文件夹的名称，以及用来访问他的 URL。因此，该属性不能包括空格，需要是小写字母等。例如，如果您的用户名是 test-username 并且您的方案称为 test-scenario（如建议的那样），用于在平台中指向该方案的URL将为 &lt;a href=&#34;https://katacoda.com/test-username/scenarios/test-scenario/&#34;&gt;https://katacoda.com/test-username/scenarios/test-scenario/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Title:&lt;/strong&gt; 方案的标题，将会显示在简介上&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Description:&lt;/strong&gt; 方案的描述，将会显示在简介上&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Difficulty level:&lt;/strong&gt; 难度级别，将会显示在简介上&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Estimated time:&lt;/strong&gt; 估计完成的时间，将会显示在简介上&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Number of steps:&lt;/strong&gt; 方案的步骤数。CLI 将会为您的所有步骤创建文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Image:&lt;/strong&gt; 确定适用于您的方案的基本软件。例如，如果您需要 docker，java，go 等作为前提条件。更多相关信息，请阅读 &lt;a href=&#34;https://katacoda.com/docs/scenarios/environments&#34;&gt;https://katacoda.com/docs/scenarios/environments&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Layout:&lt;/strong&gt; 它将确定方案界面元素的配置。例如，如果您只想显示终端，或编辑器+终端等形式，更多相关信息，请阅读 &lt;a href=&#34;https://katacoda.com/docs/scenarios/layouts&#34;&gt;https://katacoda.com/docs/scenarios/layouts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输入这些信息，CLI 将帮您创建一个文件夹，其中引入了 &lt;em&gt;&lt;strong&gt;friendly URL&lt;/strong&gt;&lt;/em&gt; 的名称，并将在该文件夹内创建方案所需的文件。&lt;/p&gt;
&lt;h4 id=&#34;编辑-scenarios&#34;&gt;编辑 Scenarios&lt;/h4&gt;
&lt;p&gt;Scenarios 目录创建好之后，可以看到目录的结构：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;.
├── finish.md
├── index.json
├── intro.md
├── step1.md
├── step2.md
├── step3.md
├── step4.md
└── step5.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;index.json&lt;/code&gt; ：文件中定义了标题、描述、步骤顺序、UI 布局以及所需环境，内容与您使用 CLI 工具创建时输入的是一致的，如果想对输入的内容进行修改，也可以在这里修改&lt;/li&gt;
&lt;li&gt;&lt;code&gt;intro.md&lt;/code&gt;：介绍页，用来介绍您这个 Scenarios&lt;/li&gt;
&lt;li&gt;&lt;code&gt;finish.md&lt;/code&gt; ：结束页&lt;/li&gt;
&lt;li&gt;&lt;code&gt;step1-setpN.md&lt;/code&gt;：步骤介绍，数目与您使用 CLI 工具创建 Scenarios 时输入的数目相同&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;上传&#34;&gt;上传&lt;/h3&gt;
&lt;p&gt;将创建的 Scenarios 移动到之前创建的 git 项目中。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ git add .
$ git commit -m &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;New Scenarios&amp;#34;&lt;/span&gt;
$ git push origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上传成功后，在 &lt;strong&gt;Your Profile&lt;/strong&gt; 页面就可以看到您上传的课程。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;Katacoda 是一个面向软件工程师的交互式学习和培训平台，开发人员根据产品特色设计学习流程，方便用户的学习；学习者则无需关心环境的搭建与依赖的安装，通过开发人员设计的最佳实践来进行学习，快速又高效。&lt;strong&gt;最重要的是，它是免费的！白嫖的东西又有谁不喜欢呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同时也欢迎各位朋友一起参与到&lt;a href=&#34;https://github.com/servicemesher/istio-handbook&#34;&gt;《Istio 服务网格进阶实战》&lt;/a&gt; 的编撰中，和 ServiceMesher 社区的朋友一起完成这部开源书籍。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kt Connect：研发侧利器，本地连通 Kubernetes 集群内网</title>
      <link>https://guoxudong.io/en/post/alibaba-kt-connect/</link>
      <pubDate>Tue, 24 Mar 2020 09:14:06 +0800</pubDate>
      
      <guid>https://guoxudong.io/en/post/alibaba-kt-connect/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;随着 Kubernetes 的普及，越来越多的应用被容器化，并部署到 Kubernetes 上。随之而来的问题是当容器中发生错误时，对错误的定位和调试也变得很复杂。当一个工具给你带来便利时，它也可能给你带来另一些麻烦。&lt;/p&gt;
&lt;p&gt;那么有没有工具可以在本地联通 Kubernetes 集群并进行调试呢？当然是有的，这里就介绍一款研发侧利器：&lt;code&gt;Kt Connect&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;kt-connect&#34;&gt;Kt Connect&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Kt Connect&lt;/code&gt; 是阿里巴巴开源的一款云原生协同开发测试解决方案，目前的功能包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接访问 Kubernetes 集群&lt;/li&gt;
&lt;li&gt;转发集群流量到本地&lt;/li&gt;
&lt;li&gt;Service Mesh 支持&lt;/li&gt;
&lt;li&gt;基于 SSH 的轻量级 VPN 网络&lt;/li&gt;
&lt;li&gt;作为 kubectl 插件，集成到 Kubectl&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（以上内容来自&lt;a href=&#34;https://alibaba.github.io/kt-connect/#/zh-cn/&#34;&gt;官方文档&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;目前使用下来最实用的功能就是&lt;strong&gt;直接连接 Kubernetes 网络&lt;/strong&gt;实现在本地使用 k8s 内网域名调用 Kubernetes 集群内的服务以及&lt;strong&gt;将 Kubernetes 集群中的流量转发到本地&lt;/strong&gt;，作用类似于一个 VPN，将本地网络与 Kubernetes 集群网络连接。
&lt;img src=&#34;https://tvax1.sinaimg.cn/large/ad5fbf65gy1gd4wu5p3rmj20pb0dl75m.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Kt Connect&lt;/code&gt; 使用 Go 开发，支持 Mac、Linux 和 Windows，安装方式也很简单&lt;/p&gt;
&lt;p&gt;前往&lt;a href=&#34;https://github.com/alibaba/kt-connect/releases&#34;&gt;Github Releases&lt;/a&gt; 下载可执行文件&lt;/p&gt;
&lt;h3 id=&#34;mac&#34;&gt;Mac&lt;/h3&gt;
&lt;p&gt;安装sshuttle&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;brew install sshuttle
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下载并安装KT&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ curl -OL https://rdc-incubators.oss-cn-beijing.aliyuncs.com/stable/ktctl_darwin_amd64.tar.gz
$ tar -xzvf ktctl_darwin_amd64.tar.gz
$ mv ktctl_darwin_amd64 /usr/local/bin/ktctl
$ ktctl -h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;linux&#34;&gt;Linux&lt;/h3&gt;
&lt;p&gt;安装sshuttle&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;pip install sshuttle
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下载并安装KT&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ curl -OL https://rdc-incubators.oss-cn-beijing.aliyuncs.com/stable/ktctl_linux_amd64.tar.gz
$ tar -xzvf ktctl_linux_amd64.tar.gz
$ mv ktctl_linux_amd64 /usr/local/bin/ktctl
$ ktctl -h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;windows&#34;&gt;Windows&lt;/h3&gt;
&lt;p&gt;下载并解压可执行文件，并确保ktctl在PATH路径下&lt;/p&gt;
&lt;h2 id=&#34;本地连接集群&#34;&gt;本地连接集群&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;使用 &lt;code&gt;ktctl connect&lt;/code&gt; 命令，启动的时候需要 admin 权限，需要输入密码&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ ktctl --namespace&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;default connect

1:51PM INF Connect Start At &lt;span style=&#34;color:#ae81ff&#34;&gt;69444&lt;/span&gt;
1:51PM INF Client address 192.168.7.121
1:51PM INF deploy shadow deployment kt-connect-daemon-rcacy in namespace default

1:51PM INF pod label: kt&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;kt-connect-daemon-rcacy
1:51PM INF pod: kt-connect-daemon-rcacy-fd4c587f-zmn4z is running,but not ready
1:51PM INF pod: kt-connect-daemon-rcacy-fd4c587f-zmn4z is running,but not ready
1:51PM INF Shadow pod: kt-connect-daemon-rcacy-fd4c587f-zmn4z is ready.
Forwarding from 127.0.0.1:2222 -&amp;gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;22&lt;/span&gt;
Forwarding from &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;::1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;:2222 -&amp;gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;22&lt;/span&gt;
1:51PM INF port-forward start at pid: &lt;span style=&#34;color:#ae81ff&#34;&gt;69445&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;local sudo&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; Password: 1:51PM INF vpn&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;sshuttle&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; start at pid: &lt;span style=&#34;color:#ae81ff&#34;&gt;69449&lt;/span&gt;
1:51PM INF KT proxy start successful
&lt;span style=&#34;color:#75715e&#34;&gt;# 这里需要输入密码&lt;/span&gt;
Handling connection &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2222&lt;/span&gt;
Warning: Permanently added &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;[127.0.0.1]:2222&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;ECDSA&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; to the list of known hosts.
bash: warning: setlocale: LC_ALL: cannot change locale &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;en_US.UTF-8&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
client: Connected.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里可以看到在 &lt;code&gt;namespace:default&lt;/code&gt; 中部署了一个 &lt;code&gt;kt-connect-daemon-*&lt;/code&gt; 的 &lt;code&gt;Deployment&lt;/code&gt;，如果这个 &lt;code&gt;Deployment&lt;/code&gt; 启动正常，就可以直接在本地访问 Kubernetes 集群内的服务了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ kubectl get deploy | grep kt

kt-connect-daemon-rcacy   1/1     &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;           5m35s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;访问集群服务，可以使用 &lt;code&gt;curl&lt;/code&gt; 或者直接在浏览器访问。（这里使用之前文章&lt;a href=&#34;../feiyan-grafana&#34;&gt;《使用 Grafana 展示肺炎疫情动态》&lt;/a&gt;中部署的服务）&lt;/p&gt;
&lt;h3 id=&#34;使用-curl&#34;&gt;使用 &lt;code&gt;curl&lt;/code&gt;&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ curl kk-feiyan
UP
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;直接使用浏览器&#34;&gt;直接使用浏览器&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://tvax3.sinaimg.cn/large/ad5fbf65ly1gd4zc1ddfij20fq03zglp.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;转发集群流量到本地&#34;&gt;转发集群流量到本地&lt;/h2&gt;
&lt;p&gt;使用 &lt;code&gt;ktctl exchange&lt;/code&gt; 命令，这个命令的前提条件是 Kubernetes 集群中必须有已经已经存在的 &lt;code&gt;Deployment&lt;/code&gt;，在运行该命令时，将会起一个 shadow 容器，来代替已存在的 Deployment，调用该容器的流量，都会被转发到本地的指定端口。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;本地启动一个服务&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tvax4.sinaimg.cn/large/ad5fbf65ly1gd4zsl7r14j20eq03r76o.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;p&gt;运行命令&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ ktctl exchange kk-feiyan --expose &lt;span style=&#34;color:#ae81ff&#34;&gt;8088&lt;/span&gt;
2:13PM INF &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;KT Connect&amp;#39;&lt;/span&gt; is runing, you can access local app from cluster and localhost
2:13PM INF Client address 192.168.7.121
2:13PM INF deploy shadow deployment kk-feiyan-kt-yssnq in namespace default

2:13PM INF pod label: kt&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;kk-feiyan-kt-yssnq
2:13PM INF pod: kk-feiyan-kt-yssnq-6464bbf74d-smvhc is running,but not ready
2:13PM INF pod: kk-feiyan-kt-yssnq-6464bbf74d-smvhc is running,but not ready
2:13PM INF Shadow pod: kk-feiyan-kt-yssnq-6464bbf74d-smvhc is ready.
2:13PM INF create exchange shadow kk-feiyan-kt-yssnq in namespace default
2:13PM INF scale deployment kk-feiyan to &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;

2:13PM INF  * kk-feiyan &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; replicas&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; success
2:13PM INF remote 172.22.1.166 forward to local &lt;span style=&#34;color:#ae81ff&#34;&gt;8088&lt;/span&gt;
Forwarding from 127.0.0.1:2266 -&amp;gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;22&lt;/span&gt;
Forwarding from &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;::1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;:2266 -&amp;gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;22&lt;/span&gt;
2:13PM INF exchange port forward to local start at pid: &lt;span style=&#34;color:#ae81ff&#34;&gt;70269&lt;/span&gt;
2:13PM INF redirect request from pod 172.22.1.166 &lt;span style=&#34;color:#ae81ff&#34;&gt;22&lt;/span&gt; to 127.0.0.1:2266 starting

Handling connection &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2266&lt;/span&gt;
Warning: Permanently added &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;[127.0.0.1]:2266&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;ECDSA&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; to the list of known hosts.
bash: warning: setlocale: LC_ALL: cannot change locale &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;en_US.UTF-8&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
2:13PM INF ssh remote port-forward start at pid: &lt;span style=&#34;color:#ae81ff&#34;&gt;70270&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;查看 Deployment&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ kubectl get deploy | grep kk-feiyan
kk-feiyan                 0/0     &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;           39d    &lt;span style=&#34;color:#75715e&#34;&gt;# 原服务&lt;/span&gt;
kk-feiyan-kt-eclcc        1/1     &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;           89s    &lt;span style=&#34;color:#75715e&#34;&gt;# 转发流量服务&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样的话，集群内调用 &lt;code&gt;kk-feiyan&lt;/code&gt; 这个服务的流量都会被转发到本地&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;集群内调用：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ curl kk-feiyan
UP
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;可以看到流量被抓发到了本地&lt;/strong&gt;
&lt;img src=&#34;https://tvax3.sinaimg.cn/large/ad5fbf65ly1gd4zuym6ofj20eq052n0d.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;将本地服务暴露到-kubernetes-集群&#34;&gt;将本地服务暴露到 Kubernetes 集群&lt;/h2&gt;
&lt;p&gt;有些时候，我们并不想使用 &lt;code&gt;exchange&lt;/code&gt; 来代替已经存在的 Deployment，只想在集群内新建一个服务来将流量转发到本，以完成调试。&lt;/p&gt;
&lt;p&gt;这个时候使用 &lt;code&gt;ktctl run&lt;/code&gt;，就可以满足需求，该命令会在 Kubernetes 集群中新建一个服务，并将访问该服务的流量被转发到本地的指定端口。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ ktctl run localservice --port &lt;span style=&#34;color:#ae81ff&#34;&gt;8088&lt;/span&gt; --expose
2:33PM INF Client address 192.168.7.121
2:33PM INF deploy shadow deployment localservice in namespace default

2:33PM INF pod label: kt&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;localservice
2:33PM INF pod: localservice-77d565c488-64hpp is running,but not ready
2:33PM INF pod: localservice-77d565c488-64hpp is running,but not ready
2:33PM INF Shadow pod: localservice-77d565c488-64hpp is ready.
2:33PM INF create shadow pod localservice-77d565c488-64hpp ip 172.22.1.74
2:33PM INF expose deployment localservice to localservice:8088
2:33PM INF remote 172.22.1.74 forward to local &lt;span style=&#34;color:#ae81ff&#34;&gt;8088&lt;/span&gt;
Forwarding from 127.0.0.1:2274 -&amp;gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;22&lt;/span&gt;
Forwarding from &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;::1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;:2274 -&amp;gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;22&lt;/span&gt;
2:33PM INF exchange port forward to local start at pid: &lt;span style=&#34;color:#ae81ff&#34;&gt;70899&lt;/span&gt;
2:33PM INF redirect request from pod 172.22.1.74 &lt;span style=&#34;color:#ae81ff&#34;&gt;22&lt;/span&gt; to 127.0.0.1:2274 starting

Handling connection &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2274&lt;/span&gt;
Warning: Permanently added &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;[127.0.0.1]:2274&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;ECDSA&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; to the list of known hosts.
bash: warning: setlocale: LC_ALL: cannot change locale &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;en_US.UTF-8&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
2:33PM INF ssh remote port-forward start at pid: &lt;span style=&#34;color:#ae81ff&#34;&gt;70903&lt;/span&gt;
2:33PM INF forward remote 172.22.1.74:8088 -&amp;gt; 127.0.0.1:8088
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到该服务已经被拉起了&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ kubectl get deploy localservice
NAME           READY   UP-TO-DATE   AVAILABLE   AGE
localservice   1/1     &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;           86s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;访问该服务&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ curl localservice:8088
UP
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到流量被转发到了本地
&lt;img src=&#34;https://tva3.sinaimg.cn/large/ad5fbf65ly1gd50e6lkquj20ff05z782.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;本地访问 k8s 内网，将 k8s 流量转发到本地，靠着这两大功能 &lt;code&gt;Kt Connect&lt;/code&gt; 可以称之为研发侧的利器，我们可以轻松的在本地调用集群服务，或者让集群调用本地的服务，这就让开发/测试 k8s 集群中发起调用的服务，在本地断点 debug 成为了现实，非常好用。同时还有其他一些没有介绍的功能，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Service Mesh 支持，可以支持用户可以基于Service Mesh的能力做更多自定义的流量规则定义&lt;/li&gt;
&lt;li&gt;Dashboard 功能，管理所以使用 kt 连入集群的用户等等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;值得一提的是，&lt;code&gt;ktctl run&lt;/code&gt; 功能是我提出该场景并希望能实现，该 &lt;a href=&#34;https://github.com/alibaba/kt-connect/issues/89&#34;&gt;issue&lt;/a&gt; 提出仅一天就通过并完成了开发。给高效的开发人员点赞。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>修改 Nginx Ingress 日志打印格式</title>
      <link>https://guoxudong.io/en/post/nginx-ingress-log-aliyun/</link>
      <pubDate>Mon, 02 Mar 2020 15:29:16 +0800</pubDate>
      
      <guid>https://guoxudong.io/en/post/nginx-ingress-log-aliyun/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近接到一个需求，需要展示 ingress 上面的访问日志，由于我们的业务系统都部署在 Kubernetes 上面，通过 ingress 进行访问，所以这里的访问日志，其实就是我们全部业务系统的访问日志。&lt;/p&gt;
&lt;p&gt;日志采集方面，阿里云天生就提供了 nginx-ingress 日志和采集和展示，本身提供很多不错的基于 ingress 日志数据的图表与分析。如果你使用的是阿里云 ACK 容器服务，那么极端推荐使用，配置方法见官方文档：https://help.aliyun.com/document_detail/86532.html。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva2.sinaimg.cn/large/ad5fbf65gy1gcfmo5d410j21970nzwjg.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;p&gt;让人头秃的是，我们这次不但要采集 ingress 日志上比较常规的 &lt;code&gt;url&lt;/code&gt; &lt;code&gt;client_ip&lt;/code&gt; &lt;code&gt;method&lt;/code&gt; &lt;code&gt;status&lt;/code&gt; 等字段，还要采集我们系统在 &lt;code&gt;Request Headers&lt;/code&gt; 里面自定义的参数，这些参数是默认的 ingress 并不展示的，所以需要我们进行调整。&lt;/p&gt;
&lt;h2 id=&#34;开始&#34;&gt;开始&lt;/h2&gt;
&lt;p&gt;首先明确需要调整的组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nginx-ingress&lt;/code&gt; 的 ConfigMap：用于打印自定义日志字段&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AliyunLogConfig&lt;/code&gt;：这个是阿里云日志服务的 CRD 扩展，需要在这个里面加入新增的字段名和修改后的正则表达式&lt;/li&gt;
&lt;li&gt;在日志服务控制台，添加新增字段的指定字段查询&lt;/li&gt;
&lt;li&gt;新增展示仪表盘&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;调整-ingress-日志输出&#34;&gt;调整 ingress 日志输出&lt;/h3&gt;
&lt;p&gt;我们 ingress 组件使用的是 &lt;code&gt;nginx-ingress-container&lt;/code&gt;，这里要调整日志输出格式，老规矩，直接官方文档：https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/。&lt;/p&gt;
&lt;p&gt;从文档可见，只需要调整 &lt;code&gt;ingress-nginx&lt;/code&gt; 的 ConfigMap &lt;code&gt;nginx-configuration&lt;/code&gt; data 中的 &lt;code&gt;log-format-upstream&lt;/code&gt; 字段即可。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;修改 ConfigMap，&lt;code&gt;ingress-controller&lt;/code&gt; 将进行热更新，看到如下日志，就证明配置已完成更新，接下来就可以看到你自定义字段的值已经打印出来了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;I0302&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;08&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;58.393365&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;controller&lt;/span&gt;.&lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;] &lt;span style=&#34;color:#a6e22e&#34;&gt;Backend&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;successfully&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;reloaded&lt;/span&gt;.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;调整阿里云日志组件配置&#34;&gt;调整阿里云日志组件配置&lt;/h3&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;日志已经成功打印了，接下来就是调整日志采集的字段了，这里只需要调整日志服务 CRD 的扩展配置即可。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ kubectl edit AliyunLogConfig k8s-nginx-ingress
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在修改配置之前，推荐先去 &lt;a href=&#34;https://regex101.com/&#34;&gt;https://regex101.com/&lt;/a&gt; 验证正则表达式是否正确，将调整过的正则表达式和 &lt;code&gt;ingress-controller&lt;/code&gt; 打印的日志贴入下图指定位置，就可以看出正则表达式是否正确。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tvax1.sinaimg.cn/large/ad5fbf65gy1gcfo9lxuc6j21gv0juwka.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;p&gt;然后将添加的字段名称（这个名称将作为 key 在日志服务中展示，可以与 header 中的字段不同）和正则表达式贴入如下 CRD 中。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;apiVersion&lt;/span&gt;: log.alibabacloud.com/v1alpha1
&lt;span style=&#34;color:#66d9ef&#34;&gt;kind&lt;/span&gt;: AliyunLogConfig
&lt;span style=&#34;color:#66d9ef&#34;&gt;metadata&lt;/span&gt;:
  &lt;span style=&#34;color:#75715e&#34;&gt;# your config name, must be unique in you k8s cluster&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: k8s-nginx-ingress
&lt;span style=&#34;color:#66d9ef&#34;&gt;spec&lt;/span&gt;:
  &lt;span style=&#34;color:#75715e&#34;&gt;# logstore name to upload log&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;logstore&lt;/span&gt;: nginx-ingress
  &lt;span style=&#34;color:#75715e&#34;&gt;# product code, only for k8s nginx ingress&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;productCode&lt;/span&gt;: k8s-nginx-ingress
  &lt;span style=&#34;color:#75715e&#34;&gt;# logtail config detail&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;logtailConfig&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;inputType&lt;/span&gt;: plugin
    &lt;span style=&#34;color:#75715e&#34;&gt;# logtail config name, should be same with [metadata.name]&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;configName&lt;/span&gt;: k8s-nginx-ingress
    &lt;span style=&#34;color:#66d9ef&#34;&gt;inputDetail&lt;/span&gt;:
      &lt;span style=&#34;color:#66d9ef&#34;&gt;plugin&lt;/span&gt;:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;inputs&lt;/span&gt;:
        - &lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt;: service_docker_stdout
          &lt;span style=&#34;color:#66d9ef&#34;&gt;detail&lt;/span&gt;:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;IncludeLabel&lt;/span&gt;:
              &lt;span style=&#34;color:#66d9ef&#34;&gt;io.kubernetes.container.name&lt;/span&gt;: nginx-ingress-controller
            &lt;span style=&#34;color:#66d9ef&#34;&gt;Stderr&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;Stdout&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;processors&lt;/span&gt;:
        - &lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt;: processor_regex
          &lt;span style=&#34;color:#66d9ef&#34;&gt;detail&lt;/span&gt;:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;KeepSource&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;Keys&lt;/span&gt;:
            - client_ip
            - x_forward_for
            - remote_user
            - time
            - method
            - url
            - version
            - status
            - body_bytes_sent
            - http_referer
            - http_user_agent
            - request_length
            - request_time
            - proxy_upstream_name
            - upstream_addr
            - upstream_response_length
            - upstream_response_time
            - upstream_status
            - req_id
            - host
            - &lt;span style=&#34;color:#75715e&#34;&gt;#需要添加的字段名称&lt;/span&gt;
            - ...
            &lt;span style=&#34;color:#66d9ef&#34;&gt;NoKeyError&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;NoMatchError&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;Regex&lt;/span&gt;: &lt;span style=&#34;color:#75715e&#34;&gt;#修改后的正则表达式&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;SourceKey&lt;/span&gt;: content
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;日志控制台新增字段&#34;&gt;日志控制台新增字段&lt;/h3&gt;
&lt;p&gt;如果上面的操作无误的话，日志服务中就会展示您添加的字段了，如果配置有误，所有的自定义字段都会不显示，只会显示保留字段名称。&lt;/p&gt;
&lt;p&gt;添加指定字段查询，就可以快速查看添加的字段了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva3.sinaimg.cn/large/ad5fbf65gy1gcfohy9fv4j21460gxtc6.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;新增展示仪表盘&#34;&gt;新增展示仪表盘&lt;/h3&gt;
&lt;p&gt;日志既然已经取到了，那么展示就很容易了，直接在查询栏中输入分析语句，日志服务支持 SQL 聚合日志，并直接生成统计图表，点击添加到仪表盘可以就可以添加到现有仪表盘或者新建一个仪表盘。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva2.sinaimg.cn/large/ad5fbf65gy1gcfos33c23j219a0nuae3.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;成果&#34;&gt;成果&lt;/h2&gt;
&lt;p&gt;之后进行一些微调，添加过滤栏，由于这里统计的是登录用户，你甚至都可以添加一个词云来看看哪些用于使用系统比较频繁。当然，想添加什么都看您的喜好，日志在你手里，想怎么分析都可以。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva4.sinaimg.cn/large/ad5fbf65gy1gcfowk10tjj21970ns79i.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;
&lt;p&gt;本次实现的功能并不是什么高深的功能，只不过是一个简单的访问日志记录和展示，相信每个系统其实都有一套这种功能。但是这种实现方式在我看来优点更多：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无代码：全程没有写一行代码，如果有的话，也就是业务需要统一 &lt;code&gt;Request Headers&lt;/code&gt; 里面的字段。&lt;/li&gt;
&lt;li&gt;配置简单：只需要修改 nginx ConfigMap 中的一个字段，并在 CRD 中添加字段名称和正在表达式，唯一的难度可能就是正则表达式。&lt;/li&gt;
&lt;li&gt;配置快：整体的配置时间很短，加上查文档和调整图表也不过半天的时间，肯定比 &lt;code&gt;提需求-评估-开发-测试-验收&lt;/code&gt; 全流程走一遍，前端后端撕一遍要快的多的多的多。&lt;/li&gt;
&lt;li&gt;高度定制：可以根据自己的喜好，随意定制图表。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;最近发现阿里云日志服务是一个宝藏产品，从安全到 k8s 业务，从成本控制到疫情动态，日志服务真的就是把所有没有前端开发资源的服务都帮了一把。
&amp;mdash; 摘自本人朋友圈&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Kubecm：管理你的 kubeconfig</title>
      <link>https://guoxudong.io/en/post/kubecm/</link>
      <pubDate>Mon, 09 Dec 2019 10:07:46 +0800</pubDate>
      
      <guid>https://guoxudong.io/en/post/kubecm/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;该项目脱胎于 &lt;a href=&#34;https://github.com/sunny0826/mergeKubeConfig&#34;&gt;mergeKubeConfig&lt;/a&gt; 项目，最早写该项目的目的是在一堆杂乱无章的 kubeconfig 中自由的切换。随着需要操作的 Kubernetes 集群越来越多，在不同的集群之间切换也越来越麻烦，而操作 Kubernetes 集群的本质不过是通过 &lt;code&gt;kubeconfig&lt;/code&gt; 访问 Kubernetes 集群的 API Server，以操作 Kubernetes 的各种资源，而 &lt;code&gt;kubeconfig&lt;/code&gt; 不过是一个 yaml 文件，用来保存访问集群的密钥，最早的 &lt;a href=&#34;https://github.com/sunny0826/mergeKubeConfig&#34;&gt;mergeKubeConfig&lt;/a&gt; 不过是一个操作 yaml 文件的 Python 脚本。而随着 golang 学习的深入，也就动了重写这个项目的念头，就这样 &lt;a href=&#34;https://github.com/sunny0826/kubecm&#34;&gt;kubecm&lt;/a&gt; 诞生了。&lt;/p&gt;
&lt;h2 id=&#34;kubecm&#34;&gt;kubecm&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/sunny0826/kubecm&#34;&gt;kubecm&lt;/a&gt; 由 golang 编写，支持 &lt;code&gt;Mac&lt;/code&gt; &lt;code&gt;Linux&lt;/code&gt; 和 &lt;code&gt;windows&lt;/code&gt; 平台，&lt;code&gt;delete&lt;/code&gt; &lt;code&gt;rename&lt;/code&gt; &lt;code&gt;switch&lt;/code&gt; 提供比较实用的交互式的操作，目前的功能包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;add ：添加新的 &lt;code&gt;kubeconfig&lt;/code&gt; 到 &lt;code&gt;$HOME/.kube/config&lt;/code&gt; 中&lt;/li&gt;
&lt;li&gt;completion ：命令行自动补全功能&lt;/li&gt;
&lt;li&gt;delete：删除已有的 &lt;code&gt;context&lt;/code&gt; ，提供交互式和指定删除两种方式&lt;/li&gt;
&lt;li&gt;merge：将指定目录中的 &lt;code&gt;kubeconfig&lt;/code&gt; 合并为一个 &lt;code&gt;kubeconfig&lt;/code&gt; 文件&lt;/li&gt;
&lt;li&gt;rename：重名指定的 &lt;code&gt;context&lt;/code&gt;，提供交互式和指定重命名两种方式&lt;/li&gt;
&lt;li&gt;switch：交互式切换 &lt;code&gt;context&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/sunny0826/kubecm&#34;&gt;kubecm&lt;/a&gt; 支持 &lt;code&gt;Mac&lt;/code&gt; &lt;code&gt;Linux&lt;/code&gt; 和 &lt;code&gt;windows&lt;/code&gt; 平台，安装方式也比较简单：&lt;/p&gt;
&lt;h4 id=&#34;macos&#34;&gt;MacOS&lt;/h4&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;brew install sunny0826/tap/kubecm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;linux&#34;&gt;Linux&lt;/h4&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# linux x86_64&lt;/span&gt;
curl -Lo kubecm.tar.gz https://github.com/sunny0826/kubecm/releases/download/v&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;VERSION&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;/kubecm_&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;VERSION&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;_Linux_x86_64.tar.gz
tar -zxvf kubecm.tar.gz kubecm
cd kubecm
sudo mv kubecm /usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;windows&#34;&gt;Windows&lt;/h4&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;命令行自动补全&#34;&gt;命令行自动补全&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;以 &lt;code&gt;zsh&lt;/code&gt; 为例，在 &lt;code&gt;$HOME/.zshrc&lt;/code&gt; 中添加&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-vim&#34; data-lang=&#34;vim&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;source&lt;/span&gt; &amp;lt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;kubecm&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;completion&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;zsh&lt;/span&gt;)&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后使用 &lt;code&gt;source&lt;/code&gt; 命令，使其生效&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-zsh&#34; data-lang=&#34;zsh&#34;&gt;source $HOME/.zshrc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;之后，在输入 &lt;code&gt;kubecm&lt;/code&gt; 后按 &lt;!-- raw HTML omitted --&gt;tab&lt;!-- raw HTML omitted --&gt; 键，就可以看到命令行自动补全的内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva2.sinaimg.cn/large/ad5fbf65gy1g9qa0yy3bvj21co0f2hdt.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;操作-kubeconfig&#34;&gt;操作 kubeconfig&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h4 id=&#34;查看&#34;&gt;查看&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 查看 $HOME/.kube/config 中所有的 context&lt;/span&gt;
kubecm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;添加&#34;&gt;添加&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 添加 example.yaml 到 $HOME/.kube/config.yaml，该方式不会覆盖源 kubeconfig，只会在当前目录中生成一个 config.yaml 文件&lt;/span&gt;
kubecm add -f example.yaml

&lt;span style=&#34;color:#75715e&#34;&gt;# 功能同上，但是会将 example.yaml 中的 context 命名为 test&lt;/span&gt;
kubecm add -f example.yaml -n test

&lt;span style=&#34;color:#75715e&#34;&gt;# 添加 -c 会覆盖源 kubeconfig&lt;/span&gt;
kubecm add -f example.yaml -c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;删除&#34;&gt;删除&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 交互式删除&lt;/span&gt;
kubecm delete
&lt;span style=&#34;color:#75715e&#34;&gt;# 删除指定 context&lt;/span&gt;
kubecm delete my-context
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;合并&#34;&gt;合并&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 合并 test 目录中的 kubeconfig,该方式不会覆盖源 kubeconfig，只会在当前目录中生成一个 config.yaml 文件&lt;/span&gt;
kubecm merge -f test 

&lt;span style=&#34;color:#75715e&#34;&gt;# 添加 -c 会覆盖源 kubeconfig&lt;/span&gt;
kubecm merge -f test -c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;重命名&#34;&gt;重命名&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 交互式重命名&lt;/span&gt;
kubecm rename
&lt;span style=&#34;color:#75715e&#34;&gt;# 将 dev 重命名为 test&lt;/span&gt;
kubecm rename -o dev -n test
&lt;span style=&#34;color:#75715e&#34;&gt;# 重命名 current-context 为 dev&lt;/span&gt;
kubecm rename -n dev -c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;切换默认-namespace&#34;&gt;切换默认 namespace&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 交互式切换 namespace&lt;/span&gt;
kubecm namespace
&lt;span style=&#34;color:#75715e&#34;&gt;# 或者&lt;/span&gt;
kubecm ns
&lt;span style=&#34;color:#75715e&#34;&gt;# 切换默认 namespace 为 kube-system&lt;/span&gt;
kubecm ns kube-system
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;效果展示&#34;&gt;效果展示&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;Interaction.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;视频介绍&#34;&gt;视频介绍&lt;/h2&gt;

&lt;div style=&#34;position: relative; width: 100%; height: 0; padding-bottom: 75%;&#34;&gt;
    &lt;iframe src=&#34;//player.bilibili.com/player.html?aid=88259938&amp;amp;cid=150776221&amp;amp;page=1&#34; scrolling=&#34;no&#34; border=&#34;0&#34; frameborder=&#34;no&#34; framespacing=&#34;0&#34; allowfullscreen=&#34;true&#34;style=&#34;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&#34;&gt; &lt;/iframe&gt;
&lt;/div&gt;
&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/sunny0826/kubecm&#34;&gt;kubecm&lt;/a&gt; 项目的初衷为学习 golang 并熟悉 client-go 的使用，随着使用的深入，断断续续增加了不少功能，开发出了一个看上去还算正规的项目。总的来说都是根据自己的喜好来开发的业余项目，欢迎各位通过 &lt;a href=&#34;https://github.com/sunny0826/kubecm/issues/new&#34;&gt;ISSUE&lt;/a&gt; 来进行交流和讨论。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>小工具介绍：KubeWatch</title>
      <link>https://guoxudong.io/en/post/kubewatch/</link>
      <pubDate>Wed, 04 Dec 2019 17:09:51 +0800</pubDate>
      
      <guid>https://guoxudong.io/en/post/kubewatch/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;这次要介绍一个 Kubernetes 资源观测工具，实时监控 Kubernetes 集群中各种资源的新建、更新和删除，并实时通知到各种协作软件/聊天软件，目前支持的通知渠道有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;slack&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hipchat&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mattermost&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flock&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;webhook&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我这边开发了钉钉的通知渠道，但是在上游 &lt;a href=&#34;https://github.com/bitnami-labs/kubewatch/issues/198&#34;&gt;ISSUE#198&lt;/a&gt; 中提出的贡献请求并没有得到回应，所以这边只能 fork 了代码，然后自己进行了开发，以支持钉钉通知。&lt;/p&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;p&gt;这里推荐使用 helm 进行安装，快速部署&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm install kubewatch stable/kubewatch &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;--set rbac.create&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;true &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;--set slack.channel&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;#YOUR_CHANNEL&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;--set slack.token&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;xoxb-YOUR_TOKEN&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;--set resourcesToWatch.pod&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;true &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;--set resourcesToWatch.daemonset&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果想使用钉钉通知，则可以在 &lt;a href=&#34;https://github.com/sunny0826/kubewatch-chat&#34;&gt;GitHub&lt;/a&gt; 上拉取我的代码，代码中包含 helm chart 包，可直接进行安装&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;git clone https://github.com/sunny0826/kubewatch-chat.git
cd kubewatch-chat
helm install kubewatch kubewatch &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;--set dingtalk.sign&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;XXX&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;--set dingtalk.token&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;XXXX-XXXX-XXXX&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;钉钉配置&#34;&gt;钉钉配置&lt;/h2&gt;
&lt;p&gt;在钉钉中创建 &lt;code&gt;智能群助手&lt;/code&gt; ，之后&lt;/p&gt;
&lt;h3 id=&#34;获取-token&#34;&gt;获取 token&lt;/h3&gt;
&lt;p&gt;复制的 webhook 中 &lt;code&gt;https://oapi.dingtalk.com/robot/send?access_token={YOUR_TOKEN}&lt;/code&gt;, &lt;code&gt;{YOUR_TOKEN}&lt;/code&gt; 就是要填入的 token。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva4.sinaimg.cn/large/ad5fbf65gy1g9ku2hvs16j20ep05smxk.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;安全设置&#34;&gt;安全设置&lt;/h2&gt;
&lt;p&gt;钉钉智能群助手在更新后新增了安全设置，提供三种验证方式 &lt;code&gt;自定义关键词&lt;/code&gt; &lt;code&gt;加签&lt;/code&gt; &lt;code&gt;IP地址（段）&lt;/code&gt;，这里推荐使用 &lt;code&gt;IP地址（段）的方式&lt;/code&gt;，直接将 Kubernetes 集群的出口 IP 填入设置即可。同时也提供了 &lt;code&gt;加签&lt;/code&gt; 的方式，拷贝秘钥，将其填入 &lt;code&gt;dingtalk.sign&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/ad5fbf65gy1g9ku6qjwy2j20fo077glw.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;项目配置&#34;&gt;项目配置&lt;/h2&gt;
&lt;p&gt;编辑 &lt;code&gt;kubewatch/value.yaml&lt;/code&gt; ，修改配置&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;## Global Docker image parameters&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;## Please, note that this will override the image parameters, including dependencies, configured to use the global value&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;## Current available global Docker image parameters: imageRegistry and imagePullSecrets&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;##&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# global:&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#   imageRegistry: myRegistryName&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#   imagePullSecrets:&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#     - myRegistryKeySecretName&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;slack&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;enabled&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;channel&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;token&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;xoxb&amp;#34;&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;hipchat&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;enabled&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
  &lt;span style=&#34;color:#75715e&#34;&gt;# room: &amp;#34;&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#75715e&#34;&gt;# token: &amp;#34;&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#75715e&#34;&gt;# url: &amp;#34;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;mattermost&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;enabled&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
  &lt;span style=&#34;color:#75715e&#34;&gt;# channel: &amp;#34;&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#75715e&#34;&gt;# url: &amp;#34;&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#75715e&#34;&gt;# username: &amp;#34;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;flock&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;enabled&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
  &lt;span style=&#34;color:#75715e&#34;&gt;# url: &amp;#34;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;webhook&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;enabled&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
  &lt;span style=&#34;color:#75715e&#34;&gt;# url: &amp;#34;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;dingtalk&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;enabled&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;token&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;sign&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;# namespace to watch, leave it empty for watching all.&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;namespaceToWatch&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;# Resources to watch&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;resourcesToWatch&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;deployment&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;replicationcontroller&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;replicaset&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;daemonset&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;services&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;pod&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;job&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;persistentvolume&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;image&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;registry&lt;/span&gt;: docker.io
&lt;span style=&#34;color:#75715e&#34;&gt;#  repository: bitnami/kubewatch&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;repository&lt;/span&gt;: guoxudongdocker/kubewatch-chart
&lt;span style=&#34;color:#75715e&#34;&gt;#  tag: 0.0.4-debian-9-r405&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;tag&lt;/span&gt;: latest
  &lt;span style=&#34;color:#66d9ef&#34;&gt;pullPolicy&lt;/span&gt;: Always
  &lt;span style=&#34;color:#75715e&#34;&gt;## Optionally specify an array of imagePullSecrets.&lt;/span&gt;
  &lt;span style=&#34;color:#75715e&#34;&gt;## Secrets must be manually created in the namespace.&lt;/span&gt;
  &lt;span style=&#34;color:#75715e&#34;&gt;## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/&lt;/span&gt;
  &lt;span style=&#34;color:#75715e&#34;&gt;##&lt;/span&gt;
  &lt;span style=&#34;color:#75715e&#34;&gt;# pullSecrets:&lt;/span&gt;
  &lt;span style=&#34;color:#75715e&#34;&gt;#   - myRegistryKeySecretName&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;## String to partially override kubewatch.fullname template (will maintain the release name)&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;##&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# nameOverride:&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;## String to fully override kubewatch.fullname template&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;##&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# fullnameOverride:&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;rbac&lt;/span&gt;:
  &lt;span style=&#34;color:#75715e&#34;&gt;# If true, create &amp;amp; use RBAC resources&lt;/span&gt;
  &lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;create&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;serviceAccount&lt;/span&gt;:
  &lt;span style=&#34;color:#75715e&#34;&gt;# Specifies whether a ServiceAccount should be created&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;create&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
  &lt;span style=&#34;color:#75715e&#34;&gt;# The name of the ServiceAccount to use.&lt;/span&gt;
  &lt;span style=&#34;color:#75715e&#34;&gt;# If not set and create is true, a name is generated using the fullname template&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;:

&lt;span style=&#34;color:#66d9ef&#34;&gt;resources&lt;/span&gt;: {}
  &lt;span style=&#34;color:#75715e&#34;&gt;# limits:&lt;/span&gt;
  &lt;span style=&#34;color:#75715e&#34;&gt;#   cpu: 100m&lt;/span&gt;
  &lt;span style=&#34;color:#75715e&#34;&gt;#   memory: 300Mi&lt;/span&gt;
  &lt;span style=&#34;color:#75715e&#34;&gt;# requests:&lt;/span&gt;
  &lt;span style=&#34;color:#75715e&#34;&gt;#   cpu: 100m&lt;/span&gt;
  &lt;span style=&#34;color:#75715e&#34;&gt;#   memory: 300Mi&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;# Affinity for pod assignment&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# affinity: {}&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;# Tolerations for pod assignment&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# Ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;tolerations&lt;/span&gt;: []

&lt;span style=&#34;color:#75715e&#34;&gt;# Node labels for pod assignment&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# Ref: https://kubernetes.io/docs/user-guide/node-selection/&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;nodeSelector&lt;/span&gt;: {}

&lt;span style=&#34;color:#66d9ef&#34;&gt;podAnnotations&lt;/span&gt;: {}
&lt;span style=&#34;color:#66d9ef&#34;&gt;podLabels&lt;/span&gt;: {}
&lt;span style=&#34;color:#66d9ef&#34;&gt;replicaCount&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用 &lt;code&gt;value.yaml&lt;/code&gt; 安装&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;git clone https://github.com/sunny0826/kubewatch-chat.git
cd kubewatch-chat
helm install my-release -f kubewatch/values.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;slack-配置&#34;&gt;Slack 配置&lt;/h2&gt;
&lt;p&gt;Slack 为 kubewatch 默认的通知软件，这里就不简介 Slack 的安装和注册，直接从创建 APP 开始&lt;/p&gt;
&lt;h3 id=&#34;创建一个-app&#34;&gt;创建一个 APP&lt;/h3&gt;
&lt;p&gt;进去创建 &lt;a href=&#34;https://api.slack.com/apps&#34;&gt;APP 页面&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/ad5fbf65gy1g9kum3x5npj21h40p6tdx.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;p&gt;选择 &lt;code&gt;App Name&lt;/code&gt; 和 &lt;code&gt;Development Slack Workspace&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/ad5fbf65gy1g9kupp0av1j210c0uejvj.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;添加-bot-用户&#34;&gt;添加 Bot 用户&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://tvax3.sinaimg.cn/large/ad5fbf65gy1g9kuszmgggj21n4156gu2.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;添加-app-到-workspace&#34;&gt;添加 App 到 Workspace&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://tva3.sinaimg.cn/large/ad5fbf65gy1g9kuyzwzetj21qu0wmq9n.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;获取-bot-token&#34;&gt;获取 Bot-token&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://tvax3.sinaimg.cn/large/ad5fbf65gy1g9kv06dva8j21s60uajxf.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;通知效果&#34;&gt;通知效果&lt;/h2&gt;
&lt;p&gt;在 Slack 中，&lt;code&gt;创建&lt;/code&gt; &lt;code&gt;更新&lt;/code&gt; &lt;code&gt;删除&lt;/code&gt; 分别以绿、黄和红色代表&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tvax1.sinaimg.cn/large/ad5fbf65gy1g9kv23nvmoj213c0mewj4.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;p&gt;在钉钉中，我进行了汉化&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tvax3.sinaimg.cn/large/ad5fbf65gy1g9kv5fppglj20dd08zdgs.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tvax4.sinaimg.cn/large/ad5fbf65gy1g9kv5uuxn4j20ea08fgmk.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;
&lt;p&gt;对于 kubewatch 我们这里主要用作监控各种 CronJob 的定时触发状态，已经 ConfigMap 和 Secrets 的状态变化，同时也观察 HPA 触发的弹性伸缩的状态，可以实时观测到业务高峰的到来，是一个不错的小工具。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用 Velero 进行集群备份与迁移</title>
      <link>https://guoxudong.io/en/post/aliyun-velero/</link>
      <pubDate>Wed, 13 Nov 2019 09:13:22 +0800</pubDate>
      
      <guid>https://guoxudong.io/en/post/aliyun-velero/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;在近日的一个风和日丽的下午，正在快乐的写 bug 时，突然间钉钉就被 call 爆了，原来是 k8s 测试集群的一个 namespace 突然不见了。这个 namespace 里面有 60 多个服务，瞬间全部没有了……虽然得益于我们的 CI/CD 系统，这些服务很快都重新部署并正常运行了，但是如果在生产环境，那后果就是不可想象的了。在排查这个问题发生的原因的同时，集群资源的灾备和恢复功能就提上日程了，这时 Velero 就出现了。&lt;/p&gt;
&lt;h2 id=&#34;velero&#34;&gt;Velero&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/vmware-tanzu/velero&#34;&gt;Velero&lt;/a&gt; 是 VMWare 开源的 k8s 集群备份、迁移工具。可以帮助我们完成 k8s 的例行备份工作，以便在出现上面问题的时候可以快速进行恢复。同时也提供了集群迁移功能，可以将 k8s 资源迁移到其他 k8s 集群的功能。Velero 将集群资源保存在对象存储中，默认情况下可以使用 &lt;a href=&#34;https://velero.io/docs/v1.1.0/aws-config&#34;&gt;AWS&lt;/a&gt;、&lt;a href=&#34;https://velero.io/docs/v1.1.0/azure-config&#34;&gt;Azure&lt;/a&gt;、&lt;a href=&#34;https://velero.io/docs/v1.1.0/gcp-config&#34;&gt;GCP&lt;/a&gt; 的对象存储，同时也给出了插件功能用来拓展其他平台的存储，这里我们用到的就是阿里云的对象存储 OSS，阿里云也提供了 Velero 的插件，用于将备份存储到 OSS 中。下面我就介绍一下如何在阿里云容器服务 ACK 使用 Velero 完成备份和迁移。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Velero 地址：https://github.com/vmware-tanzu/velero&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;ACK 插件地址：https://github.com/AliyunContainerService/velero-plugin&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;下载-velero-客户端&#34;&gt;下载 Velero 客户端&lt;/h3&gt;
&lt;p&gt;Velero 由客户端和服务端组成，服务器部署在目标 k8s 集群上，而客户端则是运行在本地的命令行工具。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前往 &lt;a href=&#34;https://github.com/vmware-tanzu/velero/releases&#34;&gt;Velero 的 Release 页面&lt;/a&gt; 下载客户端，直接在 GitHub 上下载即可&lt;/li&gt;
&lt;li&gt;解压 release 包&lt;/li&gt;
&lt;li&gt;将 release 包中的二进制文件 &lt;code&gt;velero&lt;/code&gt; 移动到 &lt;code&gt;$PATH&lt;/code&gt; 中的某个目录下&lt;/li&gt;
&lt;li&gt;执行 &lt;code&gt;velero -h&lt;/code&gt; 测试&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;创建-oss-bucket&#34;&gt;创建 OSS bucket&lt;/h3&gt;
&lt;p&gt;创建一个 OSS bucket 用于存储备份文件，这里也可以用已有的 bucket，之后会在 bucket 中创建 &lt;code&gt;backups&lt;/code&gt;、&lt;code&gt;metadata&lt;/code&gt;、&lt;code&gt;restores&lt;/code&gt;三个目录，这里建议在已有的 bucket 中创建一个子目录用于存储备份文件。&lt;/p&gt;
&lt;p&gt;创建 OSS 的时候一定要选对区域，要和 ACK 集群在同一个区域，存储类型和读写权限选择&lt;strong&gt;标准存储&lt;/strong&gt;和&lt;strong&gt;私有&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva3.sinaimg.cn/wap720/ad5fbf65gy1g8w7t8c4xbj21021d8thq.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;创建阿里云-ram-用户&#34;&gt;创建阿里云 RAM 用户&lt;/h3&gt;
&lt;p&gt;这里需要创建一个阿里云 RAM 的用户，用于操作 OSS 以及 ACK 资源。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;新建权限策略&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tvax4.sinaimg.cn/large/ad5fbf65gy1g8w80cjiv2j21uo18cag8.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;p&gt;策略内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;{
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;Version&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;Statement&amp;#34;&lt;/span&gt;: [
        {
            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;Action&amp;#34;&lt;/span&gt;: [
                &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ecs:DescribeSnapshots&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ecs:CreateSnapshot&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ecs:DeleteSnapshot&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ecs:DescribeDisks&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ecs:CreateDisk&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ecs:Addtags&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;oss:PutObject&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;oss:GetObject&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;oss:DeleteObject&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;oss:GetBucket&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;oss:ListObjects&amp;#34;&lt;/span&gt;
            ],
            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;Resource&amp;#34;&lt;/span&gt;: [
                &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt;
            ],
            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;Effect&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Allow&amp;#34;&lt;/span&gt;
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新建用户&lt;/p&gt;
&lt;p&gt;在新建用户的时候要选择 &lt;code&gt;编程访问&lt;/code&gt;，来获取 &lt;code&gt;AccessKeyID&lt;/code&gt; 和 &lt;code&gt;AccessKeySecret&lt;/code&gt;，这里请创建一个新用于用于备份，不要使用老用户的 AK 和 AS。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tvax2.sinaimg.cn/large/ad5fbf65gy1g8w8h4ek4uj21h40ue785.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;部署服务端&#34;&gt;部署服务端&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;拉取 &lt;a href=&#34;https://github.com/AliyunContainerService/velero-plugin&#34;&gt;Velero 插件&lt;/a&gt; 到本地&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;git clone https://github.com/AliyunContainerService/velero-plugin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置修改&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;修改 &lt;code&gt;install/credentials-velero&lt;/code&gt; 文件，将新建用户中获得的 &lt;code&gt;AccessKeyID&lt;/code&gt; 和 &lt;code&gt;AccessKeySecret&lt;/code&gt; 填入，这里的 OSS EndPoint 为之前 OSS 的访问域名（&lt;strong&gt;注：这里需要选择外网访问的 EndPoint。&lt;/strong&gt;）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tvax2.sinaimg.cn/large/ad5fbf65gy1g8w8xd1sgzj21c20cm75z.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ALIBABA_CLOUD_ACCESS_KEY_ID&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&amp;lt;ALIBABA_CLOUD_ACCESS_KEY_ID&amp;gt;
ALIBABA_CLOUD_ACCESS_KEY_SECRET&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&amp;lt;ALIBABA_CLOUD_ACCESS_KEY_SECRET&amp;gt;
ALIBABA_CLOUD_OSS_ENDPOINT&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&amp;lt;ALIBABA_CLOUD_OSS_ENDPOINT&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 &lt;code&gt;install/01-velero.yaml&lt;/code&gt;，将 OSS 配置填入：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;---
&lt;span style=&#34;color:#66d9ef&#34;&gt;apiVersion&lt;/span&gt;: velero.io/v1
&lt;span style=&#34;color:#66d9ef&#34;&gt;kind&lt;/span&gt;: BackupStorageLocation
&lt;span style=&#34;color:#66d9ef&#34;&gt;metadata&lt;/span&gt;:
&lt;span style=&#34;color:#66d9ef&#34;&gt;labels&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;component&lt;/span&gt;: velero
&lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: default
&lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt;: velero
&lt;span style=&#34;color:#66d9ef&#34;&gt;spec&lt;/span&gt;:
&lt;span style=&#34;color:#66d9ef&#34;&gt;config&lt;/span&gt;: {}
&lt;span style=&#34;color:#66d9ef&#34;&gt;objectStorage&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;bucket&lt;/span&gt;: &amp;lt;ALIBABA_CLOUD_OSS_BUCKET&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;gt;  # OSS bucket 名称&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;prefix&lt;/span&gt;: &amp;lt;OSS_PREFIX&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;gt;    # bucket 子目录&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;provider&lt;/span&gt;: alibabacloud
---
&lt;span style=&#34;color:#66d9ef&#34;&gt;apiVersion&lt;/span&gt;: velero.io/v1
&lt;span style=&#34;color:#66d9ef&#34;&gt;kind&lt;/span&gt;: VolumeSnapshotLocation
&lt;span style=&#34;color:#66d9ef&#34;&gt;metadata&lt;/span&gt;:
&lt;span style=&#34;color:#66d9ef&#34;&gt;labels&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;component&lt;/span&gt;: velero
&lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: default
&lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt;: velero
&lt;span style=&#34;color:#66d9ef&#34;&gt;spec&lt;/span&gt;:
&lt;span style=&#34;color:#66d9ef&#34;&gt;config&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;region&lt;/span&gt;: &amp;lt;REGION&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;gt;    # 地域，如果是华东2（上海），则为 cn-shanghai&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;provider&lt;/span&gt;: alibabacloud
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;k8s 部署 Velero 服务&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 新建 namespace&lt;/span&gt;
kubectl create namespace velero
&lt;span style=&#34;color:#75715e&#34;&gt;# 部署 credentials-velero 的 secret&lt;/span&gt;
kubectl create secret generic cloud-credentials --namespace velero --from-file cloud&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;install/credentials-velero
&lt;span style=&#34;color:#75715e&#34;&gt;# 部署 CRD&lt;/span&gt;
kubectl apply -f install/00-crds.yaml
&lt;span style=&#34;color:#75715e&#34;&gt;# 部署 Velero&lt;/span&gt;
kubectl apply -f install/01-velero.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试 Velero 状态&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ velero version
Client:
    Version: v1.1.0
    Git commit: a357f21aec6b39a8244dd23e469cc4519f1fe608
Server:
    Version: v1.1.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到 Velero 的客户端和服务端已经部署成功。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务端清理&lt;/p&gt;
&lt;p&gt;在完成测试或者需要重新安装时，执行如下命令进行清理：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;kubectl delete namespace/velero clusterrolebinding/velero
kubectl delete crds -l component&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;velero
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;备份测试&#34;&gt;备份测试&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;velero-plugin&lt;/code&gt; 项目中已经给出 &lt;code&gt;example&lt;/code&gt; 用于测试备份。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;部署测试服务&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;kubectl apply -f examples/base.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;对 &lt;code&gt;nginx-example&lt;/code&gt; 所在的 namespace 进行备份&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;velero backup create nginx-backup --include-namespaces nginx-example --wait
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;模拟 namespace 被误删&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;kubectl delete namespaces nginx-example
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;使用 Velero 进行恢复&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;velero restore create --from-backup nginx-backup --wait
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;集群迁移&#34;&gt;集群迁移&lt;/h3&gt;
&lt;p&gt;迁移方法同备份，在备份后切换集群，在新集群恢复备份即可。&lt;/p&gt;
&lt;h3 id=&#34;高级用法&#34;&gt;高级用法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定时备份&lt;/p&gt;
&lt;p&gt;对集群资源进行定时备份，则可在发生意外的情况下，进行恢复（默认情况下，备份保留 30 天）。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 每日1点进行备份&lt;/span&gt;
velero create schedule &amp;lt;SCHEDULE NAME&amp;gt; --schedule&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0 1 * * *&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# 每日1点进行备份，备份保留48小时&lt;/span&gt;
velero create schedule &amp;lt;SCHEDULE NAME&amp;gt; --schedule&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0 1 * * *&amp;#34;&lt;/span&gt; --ttl 48h
&lt;span style=&#34;color:#75715e&#34;&gt;# 每6小时进行一次备份&lt;/span&gt;
velero create schedule &amp;lt;SCHEDULE NAME&amp;gt; --schedule&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;@every 6h&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# 每日对 web namespace 进行一次备份&lt;/span&gt;
velero create schedule &amp;lt;SCHEDULE NAME&amp;gt; --schedule&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;@every 24h&amp;#34;&lt;/span&gt; --include-namespaces web
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;定时备份的名称为：&lt;code&gt;&amp;lt;SCHEDULE NAME&amp;gt;-&amp;lt;TIMESTAMP&amp;gt;&lt;/code&gt;，恢复命令为：&lt;code&gt;velero restore create --from-backup &amp;lt;SCHEDULE NAME&amp;gt;-&amp;lt;TIMESTAMP&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;备份删除&lt;/p&gt;
&lt;p&gt;直接执行命令进行删除&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;velero delete backups &amp;lt;BACKUP_NAME&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;备份资源查看&lt;/p&gt;
&lt;p&gt;备份查看&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;velero backup get
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;查看定时备份&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;velero schedule get
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;查看可恢复备份&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;velero restore get
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;备份排除项目&lt;/p&gt;
&lt;p&gt;可为资源添加指定标签，添加标签的资源在备份的时候被排除。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 添加标签&lt;/span&gt;
kubectl label -n &amp;lt;ITEM_NAMESPACE&amp;gt; &amp;lt;RESOURCE&amp;gt;/&amp;lt;NAME&amp;gt; velero.io/exclude-from-backup&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;true
&lt;span style=&#34;color:#75715e&#34;&gt;# 为 default namespace 添加标签&lt;/span&gt;
kubectl label -n default namespace/default velero.io/exclude-from-backup&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;问题汇总&#34;&gt;问题汇总&lt;/h3&gt;
&lt;h4 id=&#34;时区问题&#34;&gt;时区问题&lt;/h4&gt;
&lt;p&gt;进行定时备份时，发现备份使用的事 UTC 时间，并不是本地时间，经过排查后发现是 &lt;code&gt;velero&lt;/code&gt; 镜像的时区问题，在调整后就会正常定时备份了，这里我重新调整了时区，直接调整镜像就好，修改 &lt;code&gt;install/01-velero.yaml&lt;/code&gt; 文件，将镜像替换为 &lt;code&gt;registry-vpc.cn-shanghai.aliyuncs.com/keking/velero:latest&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;image&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;caption&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Image from: [**Pexels**](https://www.pexels.com)&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;focal_point&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;preview_only&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
---
&lt;span style=&#34;color:#66d9ef&#34;&gt;apiVersion&lt;/span&gt;: extensions/v1beta1
&lt;span style=&#34;color:#66d9ef&#34;&gt;kind&lt;/span&gt;: Deployment
&lt;span style=&#34;color:#66d9ef&#34;&gt;metadata&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: velero
  &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt;: velero
&lt;span style=&#34;color:#66d9ef&#34;&gt;spec&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;replicas&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;selector&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;matchLabels&lt;/span&gt;:
      &lt;span style=&#34;color:#66d9ef&#34;&gt;deploy&lt;/span&gt;: velero
  &lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;metadata&lt;/span&gt;:
      &lt;span style=&#34;color:#66d9ef&#34;&gt;annotations&lt;/span&gt;:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;prometheus.io/path&lt;/span&gt;: /metrics
        &lt;span style=&#34;color:#66d9ef&#34;&gt;prometheus.io/port&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;8085&amp;#34;&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;prometheus.io/scrape&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;true&amp;#34;&lt;/span&gt;
      &lt;span style=&#34;color:#66d9ef&#34;&gt;labels&lt;/span&gt;:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;component&lt;/span&gt;: velero
        &lt;span style=&#34;color:#66d9ef&#34;&gt;deploy&lt;/span&gt;: velero
    &lt;span style=&#34;color:#66d9ef&#34;&gt;spec&lt;/span&gt;:
      &lt;span style=&#34;color:#66d9ef&#34;&gt;serviceAccountName&lt;/span&gt;: velero
      &lt;span style=&#34;color:#66d9ef&#34;&gt;containers&lt;/span&gt;:
      - &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: velero
        &lt;span style=&#34;color:#75715e&#34;&gt;# sync from gcr.io/heptio-images/velero:latest&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;image&lt;/span&gt;: registry-vpc.cn-shanghai.aliyuncs.com/keking/velero:latest   &lt;span style=&#34;color:#75715e&#34;&gt;# 修复时区后的镜像&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;imagePullPolicy&lt;/span&gt;: IfNotPresent
        &lt;span style=&#34;color:#66d9ef&#34;&gt;command&lt;/span&gt;:
          - /velero
        &lt;span style=&#34;color:#66d9ef&#34;&gt;args&lt;/span&gt;:
          - server
          - --default-volume-snapshot-locations=alibabacloud:default
        &lt;span style=&#34;color:#66d9ef&#34;&gt;env&lt;/span&gt;:
          - &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: VELERO_SCRATCH_DIR
            &lt;span style=&#34;color:#66d9ef&#34;&gt;value&lt;/span&gt;: /scratch
          - &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: ALIBABA_CLOUD_CREDENTIALS_FILE
            &lt;span style=&#34;color:#66d9ef&#34;&gt;value&lt;/span&gt;: /credentials/cloud
        &lt;span style=&#34;color:#66d9ef&#34;&gt;volumeMounts&lt;/span&gt;:
          - &lt;span style=&#34;color:#66d9ef&#34;&gt;mountPath&lt;/span&gt;: /plugins
            &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: plugins
          - &lt;span style=&#34;color:#66d9ef&#34;&gt;mountPath&lt;/span&gt;: /scratch
            &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: scratch
          - &lt;span style=&#34;color:#66d9ef&#34;&gt;mountPath&lt;/span&gt;: /credentials
            &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: cloud-credentials
      &lt;span style=&#34;color:#66d9ef&#34;&gt;initContainers&lt;/span&gt;:
      - &lt;span style=&#34;color:#66d9ef&#34;&gt;image&lt;/span&gt;: registry.cn-hangzhou.aliyuncs.com/acs/velero-plugin-alibabacloud:v1&lt;span style=&#34;color:#ae81ff&#34;&gt;.2&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;imagePullPolicy&lt;/span&gt;: IfNotPresent
        &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: velero-plugin-alibabacloud
        &lt;span style=&#34;color:#66d9ef&#34;&gt;volumeMounts&lt;/span&gt;:
        - &lt;span style=&#34;color:#66d9ef&#34;&gt;mountPath&lt;/span&gt;: /target
          &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: plugins
      &lt;span style=&#34;color:#66d9ef&#34;&gt;volumes&lt;/span&gt;:
        - &lt;span style=&#34;color:#66d9ef&#34;&gt;emptyDir&lt;/span&gt;: {}
          &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: plugins
        - &lt;span style=&#34;color:#66d9ef&#34;&gt;emptyDir&lt;/span&gt;: {}
          &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: scratch
        - &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: cloud-credentials
          &lt;span style=&#34;color:#66d9ef&#34;&gt;secret&lt;/span&gt;:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;secretName&lt;/span&gt;: cloud-credentials

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;版本问题&#34;&gt;版本问题&lt;/h4&gt;
&lt;p&gt;截止发稿时，Velero 已经发布了 v1.2.0 版本，目前 ACK 的 Velero 的插件还未升级。&lt;/p&gt;
&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;
&lt;p&gt;近日正好有 k8s 集群服务迁移服务的需求，使用 Velero 完成了服务的迁移，同时也每日进行集群资源备份，其能力可以满足容器服务的灾备和迁移场景，实测可用，现已运行在所有的 k8s 集群。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用 Grafana 展示阿里云监控指标</title>
      <link>https://guoxudong.io/en/post/aliyun-cms-grafana/</link>
      <pubDate>Thu, 07 Nov 2019 11:08:36 +0800</pubDate>
      
      <guid>https://guoxudong.io/en/post/aliyun-cms-grafana/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;对于阿里云用户来说，阿里云监控是一个很不错的产品，首先它在配额内使用是免费的！免费的！免费的！重要的事情说三遍。他的功能类似于 zabbix，但是比 zabbix 提供了更多的监控项，基本上在云上使用的资源都可以通过云监控来实时监控。而它提供的开箱即用方式，天然集成云资源，并提供多种告警方式，免去了监控与告警系统搭建与维护的繁琐，并且减少了资源的消耗，比购买 ECS 自己搭建 zabbix 要少消耗很多资源。同时阿里云监控和阿里云其他服务一样，也提供了比较完整的 OpenApi 以及各种语言的 sdk，可以基于阿里云的 OpenApi 将其与自己的系统集成。我们之前也是这么做的，但是随着监控项的增加，以及经常需要在办公场地监控投屏的专项监控页，光凭我们的运维开发工程师使用 vue 写速度明显跟不上，而且页面的美观程度也差很多。&lt;/p&gt;
&lt;h3 id=&#34;手写前端-vs-grafana&#34;&gt;手写前端 VS Grafana&lt;/h3&gt;
&lt;p&gt;手写前端虽然可定制化程度更高，但是需要消耗大量精力进行调试，对于运维人员，哪怕是运维开发也是吃不消的（前端小哥哥和小姐姐是不会来帮你的，下图就是我去年拿 vue 写的伪 Grafana 展示页面，花费了大约一周时间在调整这些前端元素）。
&lt;img src=&#34;https://tva4.sinaimg.cn/large/ad5fbf65gy1g8pfrw1licj22ye1gg4qp.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;p&gt;Grafana 则标准化程度很高，展示也更加符合大众审美，某些定制化需求可以通过自定义 DataSource 或者 AJAX 插件的 iframe 模式完成。开发后端 DataSource 肯定就没有前端调整 css 那么痛苦和耗时了，整体配置开发一个这样的页面可能只消耗一人天就能完成。而在新产品上线时，构建一个专项监控展示页面速度就更快了，几分钟内就能完成。
&lt;img src=&#34;https://tva4.sinaimg.cn/large/ad5fbf65gy1g8pfvp0keej22yc1g2khm.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;关于阿里云监控&#34;&gt;关于阿里云监控&lt;/h2&gt;
&lt;p&gt;云监控（CloudMonitor）是一项针对阿里云资源和互联网应用进行监控的服务。&lt;/p&gt;
&lt;p&gt;云监控为云上用户提供开箱即用的企业级开放型一站式监控解决方案。涵盖 IT 设施基础监控，外网网络质量拨测监控，基于事件、自定义指标、日志的业务监控。为您全方位提供更高效、更全面、更省钱的监控服务。通过提供跨产品、跨地域的应用分组管理模型和报警模板，帮助您快速构建支持几十种云产品、管理数万实例的高效监控报警管理体系。通过提供 Dashboard，帮助您快速构建自定义业务监控大盘。使用云监控，不但可以帮助您提升您的系统服务可用时长，还可以降低企业 IT 运维监控成本。&lt;/p&gt;
&lt;p&gt;云监控服务可用于收集获取阿里云资源的监控指标或用户自定义的监控指标，探测服务可用性，以及针对指标设置警报。使您全面了解阿里云上的资源使用情况、业务的运行状况和健康度，并及时收到异常报警做出反应，保证应用程序顺畅运行。&lt;/p&gt;
&lt;h2 id=&#34;关于-grafana&#34;&gt;关于 Grafana&lt;/h2&gt;
&lt;p&gt;Grafana 是一个跨平台的开源的度量分析和可视化工具，可以通过将采集的数据查询然后可视化的展示，并及时通知。由于云监控的 Grafana 还没有支持告警，所以我们这里只用了 Grafana 的可视化功能，而告警本身就是云监控自带的，所以也不需要依赖 Grafana 来实现。而我们的 Prometheus 也使用了 Grafana 进行数据可视化，所以有现成的 Grafana-Server 使用。&lt;/p&gt;
&lt;h2 id=&#34;阿里云监控对接-grafana&#34;&gt;阿里云监控对接 Grafana&lt;/h2&gt;
&lt;p&gt;首先 Grafana 服务的部署方式这里就不做介绍了，请使用较新版本的 Grafana，最好是 5.5.0+。后文中也有我开源的基于阿里云云监控的 Grafana 的 helm chart，可以使用 helm 安装，并会直接导入云监控的指标，这个会在后文中介绍。&lt;/p&gt;
&lt;h3 id=&#34;安装阿里云监控插件&#34;&gt;安装阿里云监控插件&lt;/h3&gt;
&lt;p&gt;进入插件目录进行安装&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;cd /var/lib/grafana/plugins/
git clone https://github.com/aliyun/aliyun-cms-grafana.git 
service grafana-server restart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果是使用 docker 或者部署在 k8s 集群，这里也可以使用环境变量在 Grafana 部署的时候进行安装&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;spec&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;containers&lt;/span&gt;:
  - &lt;span style=&#34;color:#66d9ef&#34;&gt;env&lt;/span&gt;:
    - &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: GF_INSTALL_PLUGINS  &lt;span style=&#34;color:#75715e&#34;&gt;# 多个插件请使用,隔开&lt;/span&gt;
      &lt;span style=&#34;color:#66d9ef&#34;&gt;value&lt;/span&gt;: grafana-simple-json-datasource,https://github.com/aliyun/aliyun-cms-grafana/archive/master.zip;aliyun-cms-grafana
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;您也可以下载 aliyun-cms-grafana.zip 插件解压后，上传服务器的 Grafana 的 plugins 目录下，重启 grafana-server 即可。&lt;/p&gt;
&lt;h3 id=&#34;配置云监控-datasource&#34;&gt;配置云监控 DataSource&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Grafana 启动后，进入 &lt;code&gt;Configuration&lt;/code&gt; 页面，选择 &lt;code&gt;DataSource&lt;/code&gt; Tab 页，单击右上方的&lt;code&gt;Add data source&lt;/code&gt;，添加数据源。&lt;/li&gt;
&lt;li&gt;选中&lt;code&gt;CMS Grafana Service&lt;/code&gt;，单击&lt;code&gt;select&lt;/code&gt;。
&lt;img src=&#34;https://tvax2.sinaimg.cn/large/ad5fbf65gy1g8ph0ukr0pj21nm0jk76m.jpg&#34; alt=&#34;image&#34;&gt;&lt;/li&gt;
&lt;li&gt;填写配置项，URL 根据云监控所在地域填写，并且填写阿里云账号的 accessKeyId 和 accessSecret，完成后单击&lt;code&gt;Save&amp;amp;Test&lt;/code&gt;。
&lt;img src=&#34;https://tvax3.sinaimg.cn/large/ad5fbf65gy1g8ph4bg2bij218m194n9f.jpg&#34; alt=&#34;image&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;创建-dashboard&#34;&gt;创建 Dashboard&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;单击 &lt;code&gt;Create&lt;/code&gt; -&amp;gt; &lt;code&gt;Dashboard&lt;/code&gt; -&amp;gt; &lt;code&gt;Add Query&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;配置图标，数据源选择之前添加的 &lt;code&gt;CMS Grafana Service&lt;/code&gt;，然后文档中的配置项填入指标即可（这里要注意的是，云监控 API 给返回的只有实例 ID，并没有自定义的实例名称，这里需要手动将其填入 &lt;code&gt;Y - column describe&lt;/code&gt; 中；而且只支持输入单个 Dimension，若输入多个，默认选第一个，由于这些问题才有了后续我开发的 &lt;code&gt;cms-grafana-builder&lt;/code&gt; 的动机）。
&lt;img src=&#34;https://tva4.sinaimg.cn/large/ad5fbf65gy1g8phck0irbj22ye13in79.jpg&#34; alt=&#34;image&#34;&gt;&lt;/li&gt;
&lt;li&gt;配置参考 &lt;a href=&#34;https://help.aliyun.com/document_detail/28619.html&#34;&gt;云产品监控项&lt;/a&gt;，
&lt;img src=&#34;https://tva2.sinaimg.cn/large/ad5fbf65gy1g8phg832uvj21a40vo793.jpg&#34; alt=&#34;image&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;使用-helm-chart-的方式部署-grafana&#34;&gt;使用 helm chart 的方式部署 Grafana&lt;/h2&gt;
&lt;p&gt;项目地址：https://github.com/sunny0826/cms-grafana-builder&lt;/p&gt;
&lt;h3 id=&#34;cms-grafana-builder&#34;&gt;cms-grafana-builder&lt;/h3&gt;
&lt;p&gt;由于上文中的问题，我们需要手动选择每个实例 ID 到 Dimension 中，并且还要讲该实例的名称键入 &lt;code&gt;Y - column describe&lt;/code&gt; 中，十分的繁琐，根本不可能大批量的输入。&lt;/p&gt;
&lt;p&gt;这就是我开发这个 Grafana 指标参数生成器的原因，起初只是一个 python 脚本，用来将我们要监控的指标组装成一个 Grafana 可以使用 json 文件，之后结合 Grafana 的容器化部署方法，将其做成了一个 helm chart。可以在启动的时候自动将需要的参数生成，并且每日会对所有指标进行更新，这样就不用每次新购或者释放掉资源后还需要再跑一遍脚本。&lt;/p&gt;
&lt;h3 id=&#34;部署&#34;&gt;部署&lt;/h3&gt;
&lt;p&gt;只需要将项目拉取下来运行 &lt;code&gt;helm install&lt;/code&gt; 命令&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;helm install my-release kk-grafana-cms &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;--namespace &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;your_namespace&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;--set access_key_id&lt;span style=&#34;color:#f92672&#34;&gt;={&lt;/span&gt;your_access_key_id&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;--set access_secret&lt;span style=&#34;color:#f92672&#34;&gt;={&lt;/span&gt;your_access_secret&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;--set region_id&lt;span style=&#34;color:#f92672&#34;&gt;={&lt;/span&gt;your_aliyun_region_id&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;--set password&lt;span style=&#34;color:#f92672&#34;&gt;={&lt;/span&gt;admin_password&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;更多详情见 &lt;a href=&#34;https://github.com/sunny0826/cms-grafana-builder&#34;&gt;github README&lt;/a&gt;，欢迎提 issue 交流。&lt;/p&gt;
&lt;h3 id=&#34;指标选择&#34;&gt;指标选择&lt;/h3&gt;
&lt;p&gt;在部署成功后，可修改 ConfigMap：&lt;code&gt;grafana-cms-metric&lt;/code&gt;，然后修改对应的监控指标项。&lt;/p&gt;
&lt;h3 id=&#34;效果&#34;&gt;效果&lt;/h3&gt;
&lt;p&gt;ECS:
&lt;img src=&#34;https://tvax1.sinaimg.cn/large/ad5fbf65gy1g8pi9toh3dj21gv0pldyf.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;RDS:
&lt;img src=&#34;https://tva2.sinaimg.cn/large/ad5fbf65gy1g8pi9o91ejj21h80q316p.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;EIP:
&lt;img src=&#34;https://tva4.sinaimg.cn/large/ad5fbf65gy1g8pi9i9if3j21h70q3aif.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Redis:
&lt;img src=&#34;https://tvax1.sinaimg.cn/large/ad5fbf65gy1g8pi8ss733j21h30pz7b6.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;
&lt;p&gt;为了满足公司需求，后续还开发 DataSource 定制部分，用于公司监控大屏的展示，这部分是另一个项目，不在这个项目里，就不细说了，之后有机会总结后再进行分享。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>阿里云产品夜谈-容器服务交流</title>
      <link>https://guoxudong.io/en/post/aliyun-product-meetup/</link>
      <pubDate>Mon, 30 Sep 2019 09:32:35 +0800</pubDate>
      
      <guid>https://guoxudong.io/en/post/aliyun-product-meetup/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://tvax4.sinaimg.cn/large/ad5fbf65gy1g7hb4iwdpvj213i0vs4qq.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;9月25日晚受邀来到阿里云飞天园区参加阿里云MVP产品夜谈，在会上遇到了容器服务团队的负责人易立，并就容器服务进行了交流。此次参加夜谈的除了来自全球各地的阿里云MVP，还有来自安全团队、容器团队、AIoT 团队、大数据团队、数据库团队、人工智能团队、中间件团队、搜索引擎&amp;amp;智能推荐团队的负责人&amp;amp;产品经理。各个参会的MVP可以根据自己的研究方向或者感兴趣的方向选择，直接与团队负责人面对面交流，获取阿里云产品的最新信息，并提出使用意见，促进产品的发展。由于主要从事云原生&amp;amp;容器方面的工作，我选择了容器团队，与阿里云容器服务团队负责人易立就容器服务进行交流，本文记录了部分交流内容。&lt;/p&gt;
&lt;h2 id=&#34;容器服务交流&#34;&gt;容器服务交流&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://tva3.sinaimg.cn/large/ad5fbf65gy1g7hdbw7rwij21zk13ax6s.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;关于集群版本集群升级&#34;&gt;关于集群版本&amp;amp;集群升级&lt;/h3&gt;
&lt;p&gt;众所周知，Kubernetes 以非常稳定的3个月发布一个版本速度在高速迭代这，Kubernetes v1.16.0 也即将 release ，但是目前 ACK 的 Kubernetes 版本依旧为 v1.12.6-aliyun.1 已落后官方4个大版本。得到的回复是新版本 1.14 已经上线，下周就可以升级了，1.14 版本之前已经上线，只不过一直在灰度测试，下周（2019年9月29日）就全面放开升级了。截止写这篇文章的时候，我们的多个 Kubernetes 集群已成功升级到 v1.14.6-aliyun.1 ，虽然在升级的时候出现了一点小问题，但是最后还是顺利解决了。&lt;/p&gt;
&lt;p&gt;然后就是集群升级的问题，集群升级的时候会建议对所有节点打快照，确保节点安全，但是如果在节点升级当中失败，就会出现一半为新版本节点，一半为旧版本节点的问题。我们的一个节点升级失败，就出现了上述问题，最后还是将该节点容器驱散，并将该节点移出集群才解决了升级问题。希望集群升级提供整体状态保存&amp;amp;回退功能，确保如果升级失败（或者出现新旧版本不兼容问题）的时候可以安全回退到之前版本。&lt;/p&gt;
&lt;h3 id=&#34;关于容器服务前端展示&#34;&gt;关于容器服务前端展示&lt;/h3&gt;
&lt;p&gt;ACK 的 WEB 界面相对简陋，一直以来都是对 Kubernetes Dashboard 进行了简单的包装，和其他公有云相比确实不如。不过这也不是容器服务独有的问题，阿里云你产品众多，大部分都有这样的问题。与易立交流得知，容器服务团队目前主要的任务还是确保 Kubernetes 集群的安全稳定运行，他们在安全和可用性上花费的大量精力，貌似并没有拿到什么前端开发资源。我注意到像费用中心、日志服务等产品都有了新版页面，这里希望能容器服务页面也能尽快改版，提高页面操作的便捷和美观。&lt;/p&gt;
&lt;h3 id=&#34;关于授权管理&#34;&gt;关于授权管理&lt;/h3&gt;
&lt;p&gt;一直以来容器服务都有授权管理功能，后来都基于RAM重新做了授权管理功能。但是RAM权限管理策略十分复杂，配置起来也很麻烦，不同的策略结构和语法学习起来非常困难。在配置和管理起来非常困难，我们只能把所有权限收回，每项权限都要根据需求提工单来进行配置，还时长会出现配置不生效的问题。而且这个问题一提出，就引起了大家的共鸣，后了解得知，为了安全合规的要求，操作便捷和安全合规没法兼顾。这里希望授权管理上能在确保合规的同时，能提升RAM操作的便捷性。&lt;/p&gt;
&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://tvax2.sinaimg.cn/large/ad5fbf65gy1g7hdrlln6vj21rm0ycwov.jpg&#34; alt=&#34;image&#34;&gt;
关于容器服务的交流主要是以上几点，其他的还包括监控、存储和 CI/CD 方面进行了交流，同时也获得了不少建议。当面给阿里云提需求的机会并不多，我也是抓住机会，把日常使用 ACK 的问题汇总之后一股脑的丢了出去。有类似需求的同学可以在&lt;a href=&#34;https://connect.aliyun.com&#34;&gt;阿里云的聆听平台&lt;/a&gt;上给阿里云提交建议，以我的经验，合理的需求会很快审核通过并排期开发，换句话说就是“人人都可以是阿里云的产品经理”。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>解决 Nginx-Ingress 重定向失败问题</title>
      <link>https://guoxudong.io/en/post/nginx-ingress-error/</link>
      <pubDate>Fri, 16 Aug 2019 11:15:37 +0800</pubDate>
      
      <guid>https://guoxudong.io/en/post/nginx-ingress-error/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近对公司 Kubernetes 集群的 &lt;code&gt;nginx-ingress-controller&lt;/code&gt; 进行了升级，但是升级后却出现了大问题，之前所有采用 &lt;code&gt;nginx.ingress.kubernetes.io/rewrite-target: /&lt;/code&gt; 注释进行重定向的 Ingress 路由全部失效了，但是那些直接解析了域名，没有进行重定向的却没有发生这个问题。&lt;/p&gt;
&lt;h2 id=&#34;问题分析&#34;&gt;问题分析&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;首先检查对应服务健康状态，发现所有出问题的服务的状态均正常，同时受影响的之后 http 调用，而 RPC 调用却不受影响，这时问题就定位到了 ingress。&lt;/li&gt;
&lt;li&gt;然后检查 nginx-ingress-controller ，发现 nginx-ingress-controller 的状态也是正常的，路由也是正常的。&lt;/li&gt;
&lt;li&gt;最后发现受影响的只有添加了重定向策略的 ingress 。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;问题解决&#34;&gt;问题解决&lt;/h2&gt;
&lt;p&gt;问题已经定位，接下来就是着手解决问题，这时候值得注意的就是之前进行了什么变更：升级了 nginx-ingress-controller 版本！看来问题就出现在新版本上，那么就打开官方文档：https://kubernetes.github.io/ingress-nginx/examples/rewrite/ 看一下吧。&lt;/p&gt;
&lt;h3 id=&#34;attention&#34;&gt;Attention&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Starting in Version 0.22.0, ingress definitions using the annotation &lt;code&gt;nginx.ingress.kubernetes.io/rewrite-target&lt;/code&gt; are not backwards compatible with previous versions. In Version 0.22.0 and beyond, any substrings within the request URI that need to be passed to the rewritten path must explicitly be defined in a &lt;a href=&#34;https://www.regular-expressions.info/refcapture.html&#34;&gt;capture group&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文档上给出了非常明显的警告⚠️：从 V0.22.0 版本开始将不再兼容之前的入口定义，再查看一下我的 nginx-ingress-controller 版本，果然问题出现来这里。&lt;/p&gt;
&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.regular-expressions.info/refcapture.html&#34;&gt;Captured groups&lt;/a&gt; are saved in numbered placeholders, chronologically, in the form &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt; &amp;hellip; &lt;code&gt;$n&lt;/code&gt;. These placeholders can be used as parameters in the &lt;code&gt;rewrite-target&lt;/code&gt; annotation.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;
&lt;p&gt;到这里问题已经解决了，在更新了 ingress 的配置之后，之前所有无法重定向的服务现在都已经可以正常访问了。修改见如下示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;apiVersion: extensions/v1beta1
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;kind: Ingress
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;metadata:
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  annotations:
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    nginx.ingress.kubernetes.io/rewrite-target: /$2
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  name: rewrite
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  namespace: default
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;spec:
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  rules:
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  - host: rewrite.bar.com
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    http:
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;      paths:
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;      - backend:
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;          serviceName: http-svc
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;          servicePort: 80
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        path: /something(/|$)(.*)
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt; | kubectl create -f -
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;
&lt;p&gt;解决这个问题的实际时间虽然不长，但是着实让人出了一身冷汗，同时也给了我警示：变更有风险，升级需谨慎。在升级之前需要先浏览新版本的升级信息，同时需要制定完善的回滚策略，确保万无一失。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>阿里云 ACK 挂载 NAS 数据卷</title>
      <link>https://guoxudong.io/en/post/nas-k8s/</link>
      <pubDate>Mon, 08 Jul 2019 15:09:56 +0800</pubDate>
      
      <guid>https://guoxudong.io/en/post/nas-k8s/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;今天接到一个将 NAS 数据卷挂载到 Kubernetes 集群的需求，需要将一个 NAS 数据卷挂载到集群中。这一很简单的操作由于好久没有操作了，去翻看了一下官方文档，发现官方文档还在停留在去年7月份&amp;hellip;为了防止之后还有相似情况的发生，这里将所有操作做一个简单记录。&lt;/p&gt;
&lt;h2 id=&#34;购买存储包创建文件系统&#34;&gt;购买存储包（创建文件系统）&lt;/h2&gt;
&lt;p&gt;在挂载 NAS 之前，首先要先购买 NAS 文件存储，这里推荐购买存储包，100G 的 SSD 急速型一年只需1400多，而容量型只要279，对于我这种只有少量 NAS 存储需求的人来说是是靠谱的，因为我只需要5G的左右的存储空间，SSD 急速型 NAS 一年只要18块，完美。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/ad5fbf65gy1g4sglwrx0gj22wa09gae4.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;p&gt;选择想要创建 NAS 所在 VPC 和 区域&lt;/p&gt;
&lt;h2 id=&#34;添加挂载点&#34;&gt;添加挂载点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;点击添加挂载点
&lt;img src=&#34;https://wx3.sinaimg.cn/large/ad5fbf65gy1g4sgp0dos2j22ky0iowkr.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择 VPC 网络、交换机和权限组
&lt;img src=&#34;https://wx2.sinaimg.cn/large/ad5fbf65gy1g4sgpwqrgoj20xu0vowib.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;linux-挂载-nas-数据卷&#34;&gt;Linux 挂载 NAS 数据卷&lt;/h2&gt;
&lt;p&gt;在挂载点创建成功后，就可以将 NAS 数据卷挂载到 Linux 系统，这里以 CentOS 为例：&lt;/p&gt;
&lt;h3 id=&#34;安装-nfs-客户端&#34;&gt;安装 NFS 客户端&lt;/h3&gt;
&lt;p&gt;如果 Linux 系统要挂载 NAS ，首先需要安装 NFS 客户端&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sudo yum install nfs-utils
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;挂载-nfs-文件系统&#34;&gt;挂载 NFS 文件系统&lt;/h3&gt;
&lt;p&gt;这里阿里云早就进行了优化，点击创建的文件系统，页面上就可以 copy 挂载命令。页面提供了挂载地址的 copy 和挂载命令的 copy 功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wx2.sinaimg.cn/large/ad5fbf65gy1g4sh2i33wnj22w40yyn55.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;p&gt;挂载命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sudo mount -t nfs -o vers&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;4,minorversion&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;0,noresvport xxxxx.cn-shanghai.nas.aliyuncs.com:/ /mnt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;查看挂载结果&#34;&gt;查看挂载结果&lt;/h3&gt;
&lt;p&gt;直接在挂载数据卷所在服务上执行命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;df -h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;就可以看到结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/ad5fbf65gy1g4sh6xwyt8j20lj0850tq.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-集群挂载-nas-数据卷&#34;&gt;Kubernetes 集群挂载 NAS 数据卷&lt;/h2&gt;
&lt;p&gt;K8S 的持久数据卷挂载大同小异，流程都是：&lt;strong&gt;创建PV&lt;/strong&gt; -&amp;gt; &lt;strong&gt;创建PVC&lt;/strong&gt; -&amp;gt; &lt;strong&gt;使用PVC&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面就简单介绍在阿里云上的操作：&lt;/p&gt;
&lt;h3 id=&#34;创建存储卷pv&#34;&gt;创建存储卷（PV）&lt;/h3&gt;
&lt;p&gt;首先要创建存储卷，选择 &lt;strong&gt;容器服务&lt;/strong&gt; -&amp;gt; &lt;strong&gt;存储卷&lt;/strong&gt; -&amp;gt; &lt;strong&gt;创建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里要注意的是：&lt;strong&gt;挂载点域名使用上面面的挂载地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wx4.sinaimg.cn/large/ad5fbf65gy1g4shuiiyyqj20hc0hp0tz.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;创建存储声明pvc&#34;&gt;创建存储声明（PVC）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;选择 NAS&lt;/strong&gt; -&amp;gt; &lt;strong&gt;已有存储卷&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;选择刚才创建的存储卷&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ws4.sinaimg.cn/large/ad5fbf65gy1g4shv5vs1kj20hx0bvt9g.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;使用pvc&#34;&gt;使用PVC&lt;/h3&gt;
&lt;p&gt;使用的方法这里就不做详细介绍了，相关文章也比较多，这里就只记录 Deployment 中使用的 yaml 片段：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;volumeMounts&lt;/span&gt;:
- &lt;span style=&#34;color:#66d9ef&#34;&gt;mountPath&lt;/span&gt;: /data      &lt;span style=&#34;color:#75715e&#34;&gt;# 挂载路径&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: volume-nas-test
...
&lt;span style=&#34;color:#66d9ef&#34;&gt;volumes&lt;/span&gt;:
- &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: volume-nas-test
&lt;span style=&#34;color:#66d9ef&#34;&gt;persistentVolumeClaim&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;claimName&lt;/span&gt;: nas-test     &lt;span style=&#34;color:#75715e&#34;&gt;# PVC 名称&lt;/span&gt;
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;
&lt;p&gt;这里只是做一个简单的记录，仅适用于阿里云 ACK 容器服务，同时也是 ACK 的一个简单应用。由于不经常对数据卷进行操作，这里做简单的记录，防止以后使用还要再看一遍文档。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>由一封邮件看 Mailing List 在开源项目中的重要性</title>
      <link>https://guoxudong.io/en/post/kubernetes-client-python/</link>
      <pubDate>Thu, 04 Jul 2019 09:16:41 +0800</pubDate>
      
      <guid>https://guoxudong.io/en/post/kubernetes-client-python/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;只要仔细找，想要的轮子总会有的。
&amp;mdash; 某不知名 DevOps 工程师&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;感谢 &lt;code&gt;kubernetes-dev&lt;/code&gt; 的 Mailing List ！早上在浏览邮件时发现了下面这封有趣的邮件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wx3.sinaimg.cn/large/ad5fbf65gy1g4nkmrb8scj21780q0afv.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;p&gt;接触 Kubernetes 也有不短的时间了，也见证了 Kubernetes 干掉 Swarm 和 Mesos 成为容器编排领域的事实标准的过程。在享受 Kubernetes 及其生态圈带来的便利的同时也在为 Kubernetes 及 CNCF 项目进行贡献。而使用 &lt;a href=&#34;https://github.com/kubernetes/kubectl&#34;&gt;&lt;code&gt;kubectl&lt;/code&gt;&lt;/a&gt;、&lt;a href=&#34;https://github.com/rancher/rancher&#34;&gt;&lt;code&gt;rancher&lt;/code&gt;&lt;/a&gt; 甚至是 &lt;a href=&#34;https://github.com/IBM/kui&#34;&gt;&lt;code&gt;kui&lt;/code&gt;&lt;/a&gt; 这些 CLI 和 UI 工具对 Kubernetes 集群进行操作和观察。&lt;/p&gt;
&lt;p&gt;虽然上面这些工具为操作 Kubernetes 集群带来了极大的便利，但是归根到底还是一些开源项目，并不能满足我们的全部需求。所以我们只能根据我们自己的需求和 Kubernetes 的 api-server 进行定制，但是由于 Kubernetes 的 api-server 比较复杂，短时间内并不是那么好梳理的。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-clientpython&#34;&gt;kubernetes-client/python&lt;/h2&gt;
&lt;p&gt;由于我们自研的 DevOps 平台是使用 python 开发的，所以我也基于 python 语言开发了一套 Kubernetes Client ，但总的来说由于 Kubernetes 的功能实在太多，而我的开发实践并不是很多，开发出来的功能只是差强人意。&lt;/p&gt;
&lt;p&gt;而 &lt;a href=&#34;https://github.com/kubernetes-client/python&#34;&gt;&lt;code&gt;kubernetes-client/python&lt;/code&gt;&lt;/a&gt; 这个官方给出的轮子是真的香！&lt;/p&gt;
&lt;h3 id=&#34;安装方便&#34;&gt;安装方便&lt;/h3&gt;
&lt;p&gt;这个安装方式简单的令人发指，支持的 python 版本为 &lt;code&gt;2.7 | 3.4 | 3.5 | 3.6 | 3.7&lt;/code&gt; 并且和所有 python 依赖包一样，只需要使用 &lt;code&gt;pip&lt;/code&gt; 安装即可：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;pip install kubernetes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;简单示例&#34;&gt;简单示例&lt;/h3&gt;
&lt;p&gt;查看所有的 pod ：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#encoding: utf-8&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#Author: guoxudong&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; kubernetes &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; client, config

&lt;span style=&#34;color:#75715e&#34;&gt;# Configs can be set in Configuration class directly or using helper utility&lt;/span&gt;
config&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;load_kube_config()

v1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; client&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;CoreV1Api()
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Listing pods with their IPs:&amp;#34;&lt;/span&gt;)
ret &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; v1&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;list_pod_for_all_namespaces(watch&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;False)
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; ret&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;items:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\t&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\t&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; (i&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;status&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pod_ip, i&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;metadata&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;namespace, i&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;metadata&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;name))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行查看结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;Listing pods &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; their IPs:
&lt;span style=&#34;color:#ae81ff&#34;&gt;172.22&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1.126&lt;/span&gt;	kube&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;system	coredns&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5975&lt;/span&gt;fdf55b&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;bqgkx
&lt;span style=&#34;color:#ae81ff&#34;&gt;172.22&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.2&lt;/span&gt;	kube&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;system	coredns&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5975&lt;/span&gt;fdf55b&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;vxbb4
&lt;span style=&#34;color:#ae81ff&#34;&gt;10.16&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16.13&lt;/span&gt;	kube&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;system	flexvolume&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;ccf7
&lt;span style=&#34;color:#ae81ff&#34;&gt;10.16&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16.15&lt;/span&gt;	kube&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;system	flexvolume&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;h5xn2
&lt;span style=&#34;color:#ae81ff&#34;&gt;10.16&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16.14&lt;/span&gt;	kube&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;system	flexvolume&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;kvn5x
&lt;span style=&#34;color:#ae81ff&#34;&gt;10.16&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16.17&lt;/span&gt;	kube&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;system	flexvolume&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;mf4zv
&lt;span style=&#34;color:#ae81ff&#34;&gt;10.16&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16.14&lt;/span&gt;	kube&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;system	kube&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;proxy&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;worker&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;lpfz
&lt;span style=&#34;color:#ae81ff&#34;&gt;10.16&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16.15&lt;/span&gt;	kube&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;system	kube&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;proxy&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;worker&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;wd9s
&lt;span style=&#34;color:#ae81ff&#34;&gt;10.16&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16.17&lt;/span&gt;	kube&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;system	kube&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;proxy&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;worker&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;phbbj
&lt;span style=&#34;color:#ae81ff&#34;&gt;10.16&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16.13&lt;/span&gt;	kube&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;system	kube&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;proxy&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;worker&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;pst5d
&lt;span style=&#34;color:#ae81ff&#34;&gt;172.22&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1.9&lt;/span&gt;	kube&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;system	metrics&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;server&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;78&lt;/span&gt;b597d5bf&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;wdvqh
&lt;span style=&#34;color:#ae81ff&#34;&gt;172.22&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1.12&lt;/span&gt;	kube&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;system	nginx&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;ingress&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;controller&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;796&lt;/span&gt;ccc5d76&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;9j&lt;/span&gt;h5s
&lt;span style=&#34;color:#ae81ff&#34;&gt;172.22&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1.125&lt;/span&gt;	kube&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;system	nginx&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;ingress&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;controller&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;796&lt;/span&gt;ccc5d76&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;jwwwz
&lt;span style=&#34;color:#ae81ff&#34;&gt;10.16&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16.17&lt;/span&gt;	kube&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;system	terway&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;mfs8
&lt;span style=&#34;color:#ae81ff&#34;&gt;10.16&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16.14&lt;/span&gt;	kube&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;system	terway&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;fz9ck
&lt;span style=&#34;color:#ae81ff&#34;&gt;10.16&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16.13&lt;/span&gt;	kube&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;system	terway&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;t9777
&lt;span style=&#34;color:#ae81ff&#34;&gt;10.16&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16.15&lt;/span&gt;	kube&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;system	terway&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;xbxlp
&lt;span style=&#34;color:#ae81ff&#34;&gt;172.22&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1.8&lt;/span&gt;	kube&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;system	tiller&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;deploy&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;b5d8dd754&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;wpcrc
&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;果然是一个好轮子，引入 kubeconfig 的方式及展示所有 namespace 的 pod 的方法封装的也十分简洁，是个非常漂亮的范例。建议可以看一下&lt;a href=&#34;https://github.com/kubernetes-client/python&#34;&gt;源码&lt;/a&gt;，肯定会有收获的！&lt;/p&gt;
&lt;h3 id=&#34;支持版本&#34;&gt;支持版本&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;client-python&lt;/code&gt; 遵循 &lt;a href=&#34;https://semver.org/lang/zh-CN/&#34;&gt;semver&lt;/a&gt; 规范，所以在 &lt;code&gt;client-python&lt;/code&gt; 的主要版本增加之前，代码将继续使用明确支持的 Kubernetes 集群版本。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Kubernetes 1.5&lt;/th&gt;
&lt;th&gt;Kubernetes 1.6&lt;/th&gt;
&lt;th&gt;Kubernetes 1.7&lt;/th&gt;
&lt;th&gt;Kubernetes 1.8&lt;/th&gt;
&lt;th&gt;Kubernetes 1.9&lt;/th&gt;
&lt;th&gt;Kubernetes 1.10&lt;/th&gt;
&lt;th&gt;Kubernetes 1.11&lt;/th&gt;
&lt;th&gt;Kubernetes 1.12&lt;/th&gt;
&lt;th&gt;Kubernetes 1.13&lt;/th&gt;
&lt;th&gt;Kubernetes 1.14&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;client-python 1.0&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;client-python 2.0&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;client-python 3.0&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;client-python 4.0&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;client-python 5.0&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;client-python 6.0&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;client-python 7.0&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;client-python 8.0&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;client-python 9.0&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;client-python 10.0&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;client-python HEAD&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;mailing-list-的重要性&#34;&gt;Mailing List 的重要性&lt;/h2&gt;
&lt;p&gt;这次的收获很大程度得益于 &lt;code&gt;kubernetes-dev&lt;/code&gt; 的 Mailing List 也就是邮件列表。这种沟通方式在国内不是很流行，大家更喜欢使用 QQ 和微信这样的即时通讯软件进行交流，但是大多数著名开源项目都是主要使用 &lt;strong&gt;Mailing List&lt;/strong&gt; 进行交流，交流的数量甚至比在 GitHub issue 中还多，在与 Apache 、 CNCF 项目开源的贡献者和维护者交流中得知了使用 &lt;strong&gt;Mailing List&lt;/strong&gt; 主要考虑是一下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这种异步的交流方式可以让更多关心该话题的开发人员一起加入到讨论中。&lt;/li&gt;
&lt;li&gt;mailing list 是永久保留的，如果你对某个话题感兴趣，可以随时回复邮件，关注这个话题的开发者都会收到邮件，无论这个话题是昨天提出的，还是去年提出的，有助于解决一些陈年老 BUG （俗称技术债）。&lt;/li&gt;
&lt;li&gt;即时通讯软件虽然很便利，但是问题很快会被评论顶掉，虽然诸如 slack 这样的工具解决了部分这方面的问题，但是还是不如 mailing list 好用。&lt;/li&gt;
&lt;li&gt;并不是所有地区的开发者都有高速的宽带，性能优秀的PC，在地球上很多地区还是只能使用拨号上网，网速只有几kb/s，他们甚至 GitHub issue 都无法使用。但是你不能剥夺他们参与开源项目的权利，而 mailing list 是一种很好的交流方式。&lt;/li&gt;
&lt;li&gt;通过 mailing list 可以很好掌握社区动态，效果明显好于 GitHub watch ，因为并不是项目的所有 commit 都是你关心的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;
&lt;p&gt;如果你有志于参与到开源运动，在享受开源软件带来便利的同事，还想为开源软件做出自己的贡献，那么 mailing list 是你进入社区最好的选择。在 mailing list 中和来自世界各地志同道合的开发者交流中提升自己的能力，创造更大的价值，迈出你参与开源运动的第一步。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>4月29日 云栖社区分享PPT -- 阿里云容器服务的优势与调优</title>
      <link>https://guoxudong.io/en/post/aliyun-share/</link>
      <pubDate>Tue, 30 Apr 2019 18:46:24 +0800</pubDate>
      
      <guid>https://guoxudong.io/en/post/aliyun-share/</guid>
      <description>&lt;p&gt;该PPT 为 2019年4月26日 在云栖社区分享使用，这里留作展示和记录，下载地址可以参考下方链接。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;由于图片资源位于 GitHub 上，国内访问可能会有些慢，建议下载观看。&lt;/p&gt;
&lt;p&gt;PPT 下载地址：https://yq.aliyun.com/articles/700084&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>阿里云容器服务新建集群优化方案(更新版)</title>
      <link>https://guoxudong.io/en/post/aliyun-k8s-perfect/</link>
      <pubDate>Thu, 25 Apr 2019 22:26:06 +0800</pubDate>
      
      <guid>https://guoxudong.io/en/post/aliyun-k8s-perfect/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;选择阿里云的&lt;code&gt;容器服务&lt;/code&gt;，主要原因是公司主要业务基本都在运行在阿里云上。相较自建 kubernetes 集群，容器服务的优势在于部署相对简单，与阿里云 VPC 完美兼容，网络的配置相对简单，而如果使用 &lt;code&gt;kubeadm&lt;/code&gt; 安装部署 kubernetes 集群，除了众所周知的科学上网的问题，还有一系列的问题，包括 &lt;code&gt;etcd&lt;/code&gt; 、 &lt;code&gt;Scheduler&lt;/code&gt; 和 &lt;code&gt;Controller-Manager&lt;/code&gt; 的高可用问题等。并且如果使用托管版的阿里云 kubernetes 容器服务，还会省掉3台 master 节点的钱，并且可能将 master 节点的运维问题丢给阿里云解决，并且其提供的 master 节点性能肯定会比自购的配置好，这点是阿里云容器服务的研发小哥在来我司交流时专门强调的。&lt;/p&gt;
&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;
&lt;p&gt;前面吹了阿里云容器服务的优势，那这里就说说在实践中遇到的容器服务的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在新建集群的时候需要选择相应的 VPC 并选择 &lt;code&gt;Pod&lt;/code&gt; 和 &lt;code&gt;Service&lt;/code&gt; 所在的网段，这两个网段不能和 Node 节点存在于同一网段，但是如果您在阿里云中存在不止一个 VPC （VPC的网段可以是 10.0.0.0/8，172.16-31.0.0/12-16，192.168.0.0/16 ），如果网段设置不对的话，就可能会使原本存在该网段的 ECS 失联，需要删除集群重新创建。如果删除失败的话，还需要手动删除路由表中的记录（&lt;strong&gt;别问我是怎么知道的&lt;/strong&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在使用容器服务创建集群后，会创建2个 SLB （之前是3个），一个是 SLB 是在 VPC 上并且绑定一个弹性IP（需要在创建的时候手动勾选创建弹性IP）用于 API Server，一个是经典网络的 SLB 使用提供给 Ingress 使用。但是这两个外网IP创建后的规格都是默认最大带宽、按流量收费，这个并不符合我们的要求，需要手动修改，&lt;del&gt;然而这个修改都会在第二天才能生效&lt;/del&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;容器服务创建集群后，Node 节点的名称会使&lt;code&gt;{region-id}.{ECS-id}&lt;/code&gt;的形式，这个命名方式在集群监控，使用 &lt;code&gt;kubectl&lt;/code&gt; 操作集群方面就显得比较反人类了，每次都要去查 &lt;code&gt;ECS id&lt;/code&gt; 才能确定是哪个节点，而这个 Node 节点名称是不能修改的！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;网段问题解决&#34;&gt;网段问题解决&lt;/h2&gt;
&lt;p&gt;这个比较好解决，甚至可以说不用解决，只要把网段规划好，不要出现网段冲突就好&lt;/p&gt;
&lt;h2 id=&#34;node-节点名称无法修改问题解决&#34;&gt;Node 节点名称无法修改问题解决&lt;/h2&gt;
&lt;p&gt;这个功能之前已有人在阿里聆听平台提出这个问题了，咨询了容器服务的研发小哥，得到的反馈是该功能已经在灰度测试了，相信很快就可以上线了。&lt;/p&gt;
&lt;h2 id=&#34;创建-slb-规格问题解决&#34;&gt;创建 SLB 规格问题解决&lt;/h2&gt;
&lt;p&gt;相较之前自动创建3个 SLB 的方式，目前的版本只会自动创建2个并且有一个是 VPC 内网+弹性IP的方式，已经进行了优化，但是 ingress 绑定的 SLB 还是经典网络类型，无法接入云防火墙并且规格也是不合适的。这里给出解决方案：&lt;/p&gt;
&lt;h3 id=&#34;方法一使用-kubectl-配置&#34;&gt;方法一：使用 &lt;code&gt;kubectl&lt;/code&gt; 配置&lt;/h3&gt;
&lt;h4 id=&#34;1-创建新的-slb&#34;&gt;1. 创建新的 SLB&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;这里需要创建一个新的 SLB 用来代替自动创建的不符合要求的 SLB。这里可以先私网 SLB 先不绑定弹性IP。&lt;em&gt;&lt;strong&gt;这里要注意的事，新建的 SLB 需要与 k8s集群处于同一 VPC 内，否则在后续会绑定失败&lt;/strong&gt;&lt;/em&gt;。
&lt;img src=&#34;https://wx4.sinaimg.cn/large/ad5fbf65gy1g1ma5lxgvdj21ws0s6qa5.jpg&#34; alt=&#34;image&#34;&gt;&lt;/li&gt;
&lt;li&gt;查看新购买 SLB 的 ID
&lt;img src=&#34;https://wx4.sinaimg.cn/large/ad5fbf65gy1g1ma8zuq1gj20sa0hoq4b.jpg&#34; alt=&#34;image&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-在创建集群后重新绑定-ingress-controller-的-service&#34;&gt;2. 在创建集群后重新绑定 &lt;code&gt;ingress-controller&lt;/code&gt; 的 &lt;code&gt;Service&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;首先需要使用 &lt;code&gt;kubectl&lt;/code&gt; 或者直接在阿里云控制台操作，创建新的 &lt;code&gt;nginx-ingress-svc&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# nginx ingress service&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;apiVersion&lt;/span&gt;: v1
&lt;span style=&#34;color:#66d9ef&#34;&gt;kind&lt;/span&gt;: Service
&lt;span style=&#34;color:#66d9ef&#34;&gt;metadata&lt;/span&gt;:
&lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: nginx-ingress-lb-{new-name}
&lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt;: kube-system
&lt;span style=&#34;color:#66d9ef&#34;&gt;labels&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;app&lt;/span&gt;: nginx-ingress-lb-{new-name}
&lt;span style=&#34;color:#66d9ef&#34;&gt;annotations&lt;/span&gt;:
    &lt;span style=&#34;color:#75715e&#34;&gt;# set loadbalancer to the specified slb id&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;service.beta.kubernetes.io/alicloud-loadbalancer-id&lt;/span&gt;: {SLB-ID}
    &lt;span style=&#34;color:#75715e&#34;&gt;# set loadbalancer address type to intranet if using private slb instance&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;#service.beta.kubernetes.io/alicloud-loadbalancer-address-type: intranet&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;service.beta.kubernetes.io/alicloud-loadbalancer-force-override-listeners&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;true&amp;#39;&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;#service.beta.kubernetes.io/alicloud-loadbalancer-backend-label: node-role.kubernetes.io/ingress=true&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;spec&lt;/span&gt;:
&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt;: LoadBalancer
&lt;span style=&#34;color:#75715e&#34;&gt;# do not route traffic to other nodes&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# and reserve client ip for upstream&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;externalTrafficPolicy&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Local&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;ports&lt;/span&gt;:
- &lt;span style=&#34;color:#66d9ef&#34;&gt;port&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;80&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: http
    &lt;span style=&#34;color:#66d9ef&#34;&gt;targetPort&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;80&lt;/span&gt;
- &lt;span style=&#34;color:#66d9ef&#34;&gt;port&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;443&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: https
    &lt;span style=&#34;color:#66d9ef&#34;&gt;targetPort&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;443&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;selector&lt;/span&gt;:
    &lt;span style=&#34;color:#75715e&#34;&gt;# select app=ingress-nginx pods&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;app&lt;/span&gt;: ingress-nginx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;创建成功后，可以进到 SLB 页面查看，可以看到 &lt;code&gt;80&lt;/code&gt; 和 &lt;code&gt;443&lt;/code&gt; 端口的监听已经被添加了
&lt;img src=&#34;https://wx4.sinaimg.cn/large/ad5fbf65gy1g1maej57c1j21ru0rwq8b.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;3-绑定符合要求的弹性ip&#34;&gt;3. 绑定符合要求的弹性IP&lt;/h4&gt;
&lt;p&gt;确定 SLB 创建成功并且已经成功监听后，这里就可以为 SLB 绑定符合您需求的弹性IP了，这里我们绑定一个按宽带计费2M的弹性IP&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wx4.sinaimg.cn/large/ad5fbf65gy1g1mak2r0p3j207k07mq33.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;4-验证连通性&#34;&gt;4. 验证连通性&lt;/h4&gt;
&lt;p&gt;到上面这步，我们的 ingress 入口 SLB 已经创建完成，这里我们验证一下是否联通。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在k8s集群中部署一个 &lt;code&gt;nginx&lt;/code&gt; ，直接在阿里云容器服务控制台操作即可
&lt;img src=&#34;https://wx4.sinaimg.cn/large/ad5fbf65gy1g1mant7ec6j21s40qegpr.jpg&#34; alt=&#34;image&#34;&gt;
这里创建 ingress 路由，&lt;strong&gt;注意：这里的域名需要解析到刚才创建的 SLB 绑定的弹性IP&lt;/strong&gt;
&lt;img src=&#34;https://wx4.sinaimg.cn/large/ad5fbf65gy1g1maqf7gdjj21ns0kymz8.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访问该域名，显示 &lt;code&gt;nginx&lt;/code&gt; 欢迎页，则证明修改成功
&lt;img src=&#34;https://wx4.sinaimg.cn/large/ad5fbf65gy1g1mat8srhnj21ak0hmact.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;方法二-使用阿里云容器服务控制台配置&#34;&gt;方法二： 使用阿里云容器服务控制台配置&lt;/h3&gt;
&lt;h4 id=&#34;1-阿里云容器控制台创建新-service&#34;&gt;1. 阿里云容器控制台创建新 &lt;code&gt;service&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在阿里云容器服务控制台：&lt;code&gt;路由与负载均衡&lt;/code&gt; &amp;ndash;&amp;gt; &lt;code&gt;服务&lt;/code&gt; 点击&lt;code&gt;创建&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;选择 &lt;code&gt;kube-system&lt;/code&gt; 命名空间&lt;/li&gt;
&lt;li&gt;类型选中&lt;code&gt;负载均衡&lt;/code&gt; - &lt;code&gt;内网访问&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;关联 &lt;code&gt;nginx-ingress-controller&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;并添加端口映射&lt;/li&gt;
&lt;li&gt;点击创建&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://wx4.sinaimg.cn/large/ad5fbf65gy1g2g4fwfgevj20i50hsgmp.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;2-进入负载均衡查看-slb-是否创建&#34;&gt;2. 进入负载均衡查看 SLB 是否创建&lt;/h4&gt;
&lt;p&gt;可见 SLB 已经成功创建&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wx4.sinaimg.cn/large/ad5fbf65gy1g2g4pb1d45j215303c74r.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;3-绑定符合要求的弹性ip-1&#34;&gt;3. 绑定符合要求的弹性IP&lt;/h4&gt;
&lt;p&gt;同方法一&lt;/p&gt;
&lt;h4 id=&#34;4验证连通性&#34;&gt;4.验证连通性&lt;/h4&gt;
&lt;p&gt;同方法一&lt;/p&gt;
&lt;h3 id=&#34;后续操作&#34;&gt;后续操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在确定新的 SLB 创建成功后，就可以将容器服务自动创建的 SLB 释放了&lt;/li&gt;
&lt;li&gt;删除 &lt;code&gt;kube-system&lt;/code&gt; 中原本绑定的 &lt;code&gt;Service&lt;/code&gt; &lt;strong&gt;（目前版本已经可以关联删除绑定的 SLB 了，不用分开操作）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;这里别忘了，自动创建给API Server 的SLB还是按流量付费的，记得降配&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;
&lt;p&gt;上面的这些问题和解决方案都属于临时方案，已在阿里的聆听平台提出了上面的问题，相信很快就会有所改进。总的来说，阿里云容器服务在提供优质的 kubernetes 功能，并且只收 ECS 的钱，对于想学习 kubernetes 又没有太多资金的同学也比较友好，直接买按量付费实例，测试完释放即可，不用购买 master 节点，十分良心！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>自动合并Kubeconfig，实现多k8s集群切换</title>
      <link>https://guoxudong.io/en/post/merge-kubeconfig/</link>
      <pubDate>Sun, 17 Mar 2019 10:45:02 +0800</pubDate>
      
      <guid>https://guoxudong.io/en/post/merge-kubeconfig/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;随着微服务和容器化的深入人心，以及kubernetes已经成为容器编排领域的事实标准，越来越多的公司将自己的服务迁移到kubernetes集群中。而随着kubernetes集群的增加，集群管理的问题就凸显出来，不同的环境存在不同的集群，不同的业务线不同的集群，甚至有些开发人员都有自己的集群。诚然，如果集群是使用公有云如阿里云或华为云的容器服务，可以登录其控制台进行集群管理；或者使用rancher这用的多集群管理工具进行统一的管理。但是在想操作&lt;code&gt;istio&lt;/code&gt;特有的容器资源，或者想使用&lt;code&gt;istioctl&lt;/code&gt;的时候，或者像我一样就是想使用&lt;code&gt;kubectl&lt;/code&gt;命令的同学，这个时候多集群的切换就显的十分重要了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;kubectl&lt;/code&gt;命令行工具通过&lt;code&gt;kubeconfig&lt;/code&gt;文件的配置来选择集群以及集群的API Server通信的所有信息。&lt;code&gt;kubeconfig&lt;/code&gt;用来保存关于集群，用户，名称空间和身份验证机制的信息。默认情况下&lt;code&gt;kubectl&lt;/code&gt;使用的配置文件名称是在&lt;code&gt;$HOME/.kube&lt;/code&gt;目录下的&lt;code&gt;config&lt;/code&gt;文件，可以通过设置环境变量KUBECONFIG或者&amp;ndash;kubeconfig指定其他的配置文件。详情可看官方文档https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/&lt;/p&gt;
&lt;h2 id=&#34;原理&#34;&gt;原理&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;kubeconfig&lt;/code&gt;文件，您可以组织您的群集，用户和名称空间。 还可以定义上下文以快速轻松地在群集和名称空间之间切换。&lt;/p&gt;
&lt;h3 id=&#34;上下文context&#34;&gt;上下文(Context)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;kubeconfig&lt;/code&gt;文件中的上下文元素用于以方便的名称对访问参数进行分组。 每个上下文有三个参数：集群，命名空间和用户。 默认情况下，kubectl命令行工具使用当前上下文中的参数与集群进行通信。可以使用下面的命令设置上下文：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl config use-context
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;配置内容&#34;&gt;配置内容&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;kubectl config view
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;如果设置了&lt;code&gt;--kubeconfig&lt;/code&gt;标志，则只使用指定的文件。该标志只允许有一个实例。&lt;/li&gt;
&lt;li&gt;如果环境变量&lt;code&gt;KUBECONFIG&lt;/code&gt;存在，那么就使用该环境变量&lt;code&gt;KUBECONFIG&lt;/code&gt;里面的值，如果不存在该环境变量&lt;code&gt;KUBECONFIG&lt;/code&gt;，那么默认就是使用&lt;code&gt;$HOME/.kube/config&lt;/code&gt;文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;kubeconfig内容&#34;&gt;&lt;code&gt;kubeconfig&lt;/code&gt;内容&lt;/h3&gt;
&lt;p&gt;从下面kubeconfig文件的配置来看集群、用户、上下文、当前上下文的关系就比较明显了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Config
preferences: {}

clusters:
- cluster:
name: {cluster-name}

users:
- name: {user-name}

contexts:
- context:
    cluster: {cluster-name}
    user: {user-name}
name: {context-name}

current-context: {context-name}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;为何要自动合并&#34;&gt;为何要自动合并&lt;/h2&gt;
&lt;p&gt;在日常的工作中，如果我们需要操作多个集群，会得到多个kubeconfig配置文件。一般的kubeconfig文件都是yaml格式的，但是也有少部分的集群kubeconfig时已json文件的形式给出的（比如华为云的=。=），比如我们公司再阿里云、华为云和自建环境上均存在kubernetes集群，平时操作要在多集群之间切换，这也就催生了我写这个工具（其实就是一个脚本）的动机。&lt;/p&gt;
&lt;h2 id=&#34;自动合并生成kubeconfig&#34;&gt;自动合并生成kubeconfig&lt;/h2&gt;
&lt;p&gt;众所周知，yaml是一种直观的能够被电脑识别的数据序列化格式，是一个可读性高并且容易被人类阅读的语言和json相比（没有格式化之前）可读性更强。而我这个工具并不是很关心kubeconfig的格式，只要将想要合并的kubeconfig放入指定文件即可。&lt;/p&gt;
&lt;p&gt;GitHub：https://github.com/sunny0826/mergeKubeConfig&lt;/p&gt;
&lt;h3 id=&#34;适用环境&#34;&gt;适用环境&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;需要在终端使用命令行管理多集群&lt;/li&gt;
&lt;li&gt;kubernetes集群中安装了istio，需要使用&lt;code&gt;istioctl&lt;/code&gt;命令，但是集群节点并没有安装&lt;code&gt;istioctl&lt;/code&gt;，需要在本地终端操作&lt;/li&gt;
&lt;li&gt;不愿频繁编辑.kube目录中的config文件的同学&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;准备工作&#34;&gt;准备工作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Python环境：2.7或者3均可&lt;/li&gt;
&lt;li&gt;需要依赖包：&lt;code&gt;PyYAML&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;开始使用&#34;&gt;开始使用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;安装依赖：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  pip install PyYAML
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行脚本&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;默认运行方式，kubeconfig文件放入&lt;code&gt;configfile&lt;/code&gt;文件,注意删掉作为示例的两个文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  python merge.py
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自定义kubeconfig文件目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  python merge.py -d {custom-dir}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;运行后操作&#34;&gt;运行后操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将生成的config文件放入.kube目录中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  cp config ~/.kube
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看所有的可使用的kubernetes集群角色&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  kubectl config get-contexts
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更多关于kubernetes配置文件操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  kubectl config --help
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;切换kubernetes配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  kubectl config use-context {your-contexts}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;
&lt;p&gt;在使用kubernetes初期，在多集群之间我一直是频繁的切换&lt;code&gt;.kube/config&lt;/code&gt;文件来达到切换操作集群的目的。这也导致了我的&lt;code&gt;.kube&lt;/code&gt;目录中存在这多个类似于&lt;code&gt;al_test_config.bak&lt;/code&gt;、&lt;code&gt;al_prod_config.bak&lt;/code&gt;、&lt;code&gt;hw_test_config.bak&lt;/code&gt;的文件，本地环境已经自建环境，在集群切换的时候十分头疼。而后来使用&lt;code&gt;--kubeconfig&lt;/code&gt;来进行切换集群，虽然比之前的方法要方便很多，但是并不十分优雅。这个简单的小工具一举解决了我的文件，对于我这个&lt;code&gt;kubectl&lt;/code&gt;重度依赖者来说十分重要。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>解决kubernetes中ingress-nginx配置问题</title>
      <link>https://guoxudong.io/en/post/k8s-ingress-config/</link>
      <pubDate>Wed, 06 Mar 2019 14:42:05 +0800</pubDate>
      
      <guid>https://guoxudong.io/en/post/k8s-ingress-config/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;随着公司容器化的深入，越来越多的服务陆续迁移到kubernetes集群中，有些问题在测试环境并未凸显，但是在生产环境中这些问题就显得格外的扎眼。这里就对实践中kubernetes集群中的7层负载均衡器ingress遇到的问题进行总结。&lt;/p&gt;
&lt;h2 id=&#34;https负载均衡器-ingress&#34;&gt;HTTP(S)负载均衡器-ingress&lt;/h2&gt;
&lt;p&gt;Ingress是kubernetes API的标准资源类型之一，其本质就是一组基于DNS名称(host)或URL路径把请求转发至指定的Service资源的规则，&lt;strong&gt;用于将集群外的请求流量转发至集群内部完成服务发布&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Ingress控制器(Ingress Controller)可以由任何具有反向代理(HTTP/HTTPS)功能的服务程序实现，如Nginx、Envoy、HAProxy、Vulcand和Traefik等。Ingress控制器本身也作为Pod对象与被代理的运行为Pod资源的应用运行于同一网络中。我们在这里选择了NGINX Ingress Controller，由于对NGINX的配置较为熟悉，同时我们使用的kubernetes是阿里云的容器服务，构建集群的时候，容器服务会自带NGINX Ingress Controller。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://wx2.sinaimg.cn/large/ad5fbf65ly1g0t3yj7wecj20w50doab9.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;根据实际情况ingress调优&#34;&gt;根据实际情况Ingress调优&lt;/h2&gt;
&lt;h3 id=&#34;1-解决400-request-header-or-cookie-too-large问题&#34;&gt;1. 解决400 Request Header Or Cookie Too Large问题&lt;/h3&gt;
&lt;h2 id=&#34;preview_only-false&#34;&gt;image:
caption: &amp;ldquo;Image from: &lt;a href=&#34;https://www.pexels.com&#34;&gt;&lt;strong&gt;Pexels&lt;/strong&gt;&lt;/a&gt;&amp;rdquo;
focal_point: &amp;quot;&amp;rdquo;
preview_only: false&lt;/h2&gt;
&lt;h4 id=&#34;现象&#34;&gt;现象&lt;/h4&gt;
&lt;p&gt;微信小程序需要调用后端接口，需要在header中传一段很长的token参数，直接使用浏览器访问该端口可以访问通，但是在加上token访问之后，会报“400 Request Header Or Cookie Too Large”&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;html&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;head&lt;/span&gt;&amp;gt;
        &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;400 Request Header Or Cookie Too Large&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;
    &amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;head&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;body&lt;/span&gt;&amp;gt;
        &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;center&lt;/span&gt;&amp;gt;
            &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;h1&lt;/span&gt;&amp;gt;400 Bad Request&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;h1&lt;/span&gt;&amp;gt;
        &amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;center&lt;/span&gt;&amp;gt;
        &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;center&lt;/span&gt;&amp;gt;Request Header Or Cookie Too Large&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;center&lt;/span&gt;&amp;gt;
        &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;hr&lt;/span&gt;&amp;gt;
        &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;center&lt;/span&gt;&amp;gt;nginx/1.15.6&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;center&lt;/span&gt;&amp;gt;
    &amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;body&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;html&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;问题定位&#34;&gt;问题定位&lt;/h4&gt;
&lt;p&gt;直接修改Service使用nodeport的形式访问，则没有报错，初步定位需要在ingress中nginx配置客户端的请求头，进入Ingress Controller的Pod查询配置，果然是请求头空间不足。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ cat nginx.conf | grep client_header_buffer_size
    client_header_buffer_size       1k;
$ cat nginx.conf | grep large_client_header_buffers
    large_client_header_buffers     &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; 8k;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;解决方法&#34;&gt;解决方法&lt;/h4&gt;
&lt;p&gt;在ingress中添加注释&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-nginx&#34; data-lang=&#34;nginx&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;nginx.ingress.kubernetes.io/server-snippet:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;client_header_buffer_size&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2046k&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;preview_only-false-1&#34;&gt;image:
caption: &amp;ldquo;Image from: &lt;a href=&#34;https://www.pexels.com&#34;&gt;&lt;strong&gt;Pexels&lt;/strong&gt;&lt;/a&gt;&amp;rdquo;
focal_point: &amp;quot;&amp;rdquo;
preview_only: false&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Server snippet&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;Using the annotation &lt;code&gt;nginx.ingress.kubernetes.io/server-snippet&lt;/code&gt; it is possible to add custom configuration in the server configuration block.
&lt;!-- raw HTML omitted --&gt;该注释是将自定义配置加入nginx的server配置中&lt;/p&gt;
&lt;h2 id=&#34;preview_only-false-2&#34;&gt;image:
caption: &amp;ldquo;Image from: &lt;a href=&#34;https://www.pexels.com&#34;&gt;&lt;strong&gt;Pexels&lt;/strong&gt;&lt;/a&gt;&amp;rdquo;
focal_point: &amp;quot;&amp;rdquo;
preview_only: false&lt;/h2&gt;
&lt;h3 id=&#34;2-解决请求超时问题&#34;&gt;2. 解决请求超时问题&lt;/h3&gt;
&lt;h4 id=&#34;现象-1&#34;&gt;现象&lt;/h4&gt;
&lt;p&gt;有一个数据导出功能，需要将大量数据进行处理，然后以Excel格式返回，在导出一个大约3W条数据的时候，出现访问超时情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ws2.sinaimg.cn/mw690/ad5fbf65ly1g0ubdwwzo5j21b30bjaat.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;解决方法-1&#34;&gt;解决方法&lt;/h4&gt;
&lt;p&gt;调整proxy_read_timeout，连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理
在ingress中添加注释&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-nginx&#34; data-lang=&#34;nginx&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;nginx.ingress.kubernetes.io/proxy-read-timeout:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;600&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;这里需要注意的事该注释的value需要时number类型，不能加s，否则将不生效&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;3-增加白名单&#34;&gt;3. 增加白名单&lt;/h3&gt;
&lt;h4 id=&#34;现象-2&#34;&gt;现象&lt;/h4&gt;
&lt;p&gt;在实际的使用中，会有一部分应用需要设置只可以在办公场地的网络使用，之前使用阿里云 SLB 的时候可以针对端口进行访问控制，但是现在走 ingress ，都是从80 or 443端口进，所以需要在 ingress 设置&lt;/p&gt;
&lt;h4 id=&#34;解决方法-2&#34;&gt;解决方法&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Whitelist source range&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;You can specify allowed client IP source ranges through the nginx.ingress.kubernetes.io/whitelist-source-range annotation. The value is a comma separated list of CIDRs, e.g. 10.0.0.0/24,172.10.0.1.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 ingress 里配置 &lt;code&gt;nginx.ingress.kubernetes.io/whitelist-source-range&lt;/code&gt; ，如有多个ip段，用逗号分隔即可&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-nginx&#34; data-lang=&#34;nginx&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;nginx.ingress.kubernetes.io/whitelist-source-range:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;.0.0.0/24&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果想全局适用，可以在阿里云 SLB 里操作，也可以将该配置加入到 &lt;code&gt;NGINX ConfigMap&lt;/code&gt; 中。&lt;/p&gt;
&lt;h2 id=&#34;preview_only-false-3&#34;&gt;image:
caption: &amp;ldquo;Image from: &lt;a href=&#34;https://www.pexels.com&#34;&gt;&lt;strong&gt;Pexels&lt;/strong&gt;&lt;/a&gt;&amp;rdquo;
focal_point: &amp;quot;&amp;rdquo;
preview_only: false&lt;/h2&gt;
&lt;p&gt;根据工作中遇到的实际问题，持续更新中&amp;hellip;&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;使用NGINX ingress controller的好处就是对于nginx配置相对比较熟悉，性能也不差。相关nginx配置的对应的ingress可以在 &lt;a href=&#34;https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/&#34;&gt;https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/&lt;/a&gt; 上查到。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pod质量服务类别(QoS)</title>
      <link>https://guoxudong.io/en/post/k8s-qos/</link>
      <pubDate>Mon, 04 Mar 2019 19:18:13 +0800</pubDate>
      
      <guid>https://guoxudong.io/en/post/k8s-qos/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;根据Pod对象的requests和limits属性，kubernetes将Pod对象归类到BestEffort、Burstable和Guaranteed三个服务质量（Quality of Service，QoS）类别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Guaranteed
&lt;ul&gt;
&lt;li&gt;cpu:requests=limits&lt;/li&gt;
&lt;li&gt;memory:requests=limits&lt;/li&gt;
&lt;li&gt;这类Pod具有最高优先级&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Burstable
&lt;ul&gt;
&lt;li&gt;至少一个容器设置了cpu或内存资源的requests&lt;/li&gt;
&lt;li&gt;这类Pod具有中等优先级&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BestEffort
&lt;ul&gt;
&lt;li&gt;未有任何一个容器设置requests或limits属性&lt;/li&gt;
&lt;li&gt;这类Pod具有最低优先级&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/ad5fbf65ly1g0rv2ipzqkj20hx0edmx8.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;同级别优先级的Pod资源在OOM时，与自身的requests属性相比，其内存占用比例最大的Pod对象将被首先杀死。如上图同属Burstable类别的Pod A将先于Pod B被杀死，虽然其内存用量小，但与自身的requests值相比，它的占用比例95%要大于Pod B的80%。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>为ingress配置SSL证书，实现HTTPS访问</title>
      <link>https://guoxudong.io/en/post/https-ingress/</link>
      <pubDate>Sat, 29 Dec 2018 21:28:13 +0800</pubDate>
      
      <guid>https://guoxudong.io/en/post/https-ingress/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;devops平台率先在公司内使用kubernetes集群提供后端服务，但是由于之前一直处于探索阶段，所以使用的事http的方式提供后端服务，但是在开发统一入口后，出现了访问HTTPS页面的跨域问题，由此引出了后端服务配置SSL证书的问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;使用rancher配置ssl证书&#34;&gt;使用rancher配置SSL证书&lt;/h1&gt;
&lt;h2 id=&#34;下载ssl证书文件&#34;&gt;下载SSL证书文件&lt;/h2&gt;
&lt;p&gt;首先需要获得SSL证书文件，可以直接在阿里云SSL证书管理控制台下载&lt;/p&gt;
&lt;p&gt;选中需要下载证书，选择下载nginx证书
&lt;img src=&#34;https://guoxudong.io/images/source/zhengshu.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;将证书上传项目&#34;&gt;将证书上传项目&lt;/h2&gt;
&lt;p&gt;打开rancher，选择要使用证书的项目，点击资源中的证书&lt;/p&gt;
&lt;h2 id=&#34;将证书上传项目-1&#34;&gt;将证书上传项目&lt;/h2&gt;
&lt;p&gt;打开rancher，选择要使用证书的项目，点击资源中的证书
&lt;img src=&#34;https://guoxudong.io/images/source/https-1.png&#34; alt=&#34;image&#34;&gt;
添加证书，点击从文件上传
&lt;img src=&#34;https://guoxudong.io/images/source/https-2.png&#34; alt=&#34;image&#34;&gt;
上传证书文件中的秘钥和证书，点击保存即可&lt;/p&gt;
&lt;h1 id=&#34;使用yaml上传证书&#34;&gt;使用yaml上传证书&lt;/h1&gt;
&lt;p&gt;这个证书的原理其实是在相应的命名空间创建了一个包含证书信息的secrets&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;apiVersion&lt;/span&gt;: v1
&lt;span style=&#34;color:#66d9ef&#34;&gt;data&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;tls.crt&lt;/span&gt;: {私钥}
    &lt;span style=&#34;color:#66d9ef&#34;&gt;tls.key&lt;/span&gt;: {证书}
&lt;span style=&#34;color:#66d9ef&#34;&gt;kind&lt;/span&gt;: Secret
&lt;span style=&#34;color:#66d9ef&#34;&gt;metadata&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: keking-cn
    &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt;: devops-plat
&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt;: kubernetes.io/tls
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在kubernetes上运行该yaml即可&lt;/p&gt;
&lt;h1 id=&#34;rancher中证书绑定&#34;&gt;rancher中证书绑定&lt;/h1&gt;
&lt;p&gt;选中需要绑定证书的ingress，点击编辑，选中证书，保存即可（由于ingress-controller中没有绑定默认证书，所以这里不能选中默认）
&lt;img src=&#34;https://guoxudong.io/images/source/https-3.png&#34; alt=&#34;image&#34;&gt;
保存完毕，证书即可生效&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>kubernetes集群概述</title>
      <link>https://guoxudong.io/en/post/k8s-topo/</link>
      <pubDate>Wed, 03 Oct 2018 12:18:13 +0800</pubDate>
      
      <guid>https://guoxudong.io/en/post/k8s-topo/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;随着2017年AWS，Azure和阿里云相继在其原有容器服务上新增了对kubernetes的支持，而Docker官网也在同年10月宣布同时支持Swarm好kubernetes容器编排系统。kubernetes俨然已成为容器编排领域事实上的标准，而2018年更是各大公司相继将服务迁移到kubernetes上，而kubernetes则以惊人更新速度，保持着每个季度发布一个大版本的速度高速发展着。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;kubernetes特征&#34;&gt;kubernetes特征&lt;/h1&gt;
&lt;p&gt;kubernetes是一种在一组主机上运行和协同容器化应用程序的系统，旨在提供可预测性、可拓展性与高可用性的方法来完全管理容器化应用和服务的生命周期平台。用户可以定义应用程序的运行方式，以及与其他应用程序或外部世界交互的途径，并能实现服务的扩容和缩容，执行平滑滚动更新，以及在不同版本的应用程序之间调度流量以测试功能或回滚有问题的部署。kubernetes提供了接口和可组合帆软平台原语，使得用户能够以高度的灵活性和可靠性定义及管理应用程序。&lt;/p&gt;
&lt;h1 id=&#34;kubernetes组件及网络通信&#34;&gt;kubernetes组件及网络通信&lt;/h1&gt;
&lt;p&gt;kubernetes集群的客户端可以分为两类：API Server客户端和应用程序（运行为Pod中的容器）客户端。
&lt;img src=&#34;https://guoxudong.io/images/source/kubernetes-topo.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一类客户端通常包含用户和Pod对象两种，它们通过API Server访问kubernetes集群完成管理任务，例如，管理集群上的各种资源对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二类客户端一般也包含人类用户和Pod对象两种，它们的访问目标是Pod上运行于容器中的应用程序提供的各种具体的服务，如redis或nginx等，不过，这些访问请求通常要经由Service或Ingress资源对象进行。另外，第二类客户端的访问目标对象的操作要经由第一类客户端创建和配置完成后才进行。&lt;/p&gt;
&lt;p&gt;访问API Server时，人类用户一般借助于命令行工具kubectl或图形UI（例如kubernetes dashboard）进行，也通过编程接口进行访问，包括REST API。访问Pod中的应用时，其访问方式要取决于Pod中的应用程序，例如，对于运行Nginx容器的Pod来说，其最常用工具就是浏览器。&lt;/p&gt;
&lt;p&gt;管理员（开发人员或运维人员）使用kubernetes集群的常见操作包括通过控制器创建Pod，在Pod的基础上创建Service供第二类客户端访问，更新Pod中的应用版本（更新和回滚）以及对应用规模进行扩容或缩容等，另外还有集群附件管理、存储卷管理、网络及网络策略管理、资源管理和安全管理等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>容器技术概述</title>
      <link>https://guoxudong.io/en/post/con-in/</link>
      <pubDate>Thu, 30 Aug 2018 18:45:22 +0800</pubDate>
      
      <guid>https://guoxudong.io/en/post/con-in/</guid>
      <description>&lt;h1 id=&#34;背景&#34;&gt;背景&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;自从微服务（Microservice）的出现，出于业务的需要，IT应用模型不断的变革。开发模式从瀑布式到敏捷开发；开发、运维和测试互相配合的devops思想；应用程序架构从单体模型到分层模型再到微服务；部署方式也从面向物理机到虚拟键再到容器；应用程序的基础架构从自建机房到托管再到云计算，等等。这些变革使得IT技术应用的效率大大提升，同时却以&lt;strong&gt;更低的成本交付更高质量的产品&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;尤其是以Docker为代表的容器技术的出现，终结了devops中交付和部署环节因环节、配置及程序本身的不同而造成的动辄几种甚至十几种部署配置的困境，将它们统一在容器镜像（image）之上。这就是我在工作中遇到最先遇到的困境，同时也是我开始研究容器技术的契机。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;如今，越来越多的企业或组织开始开始选择以镜像文件为交付载体。容器镜像之内直接包含了应用程序及其依赖的系统环境、库、基础程序等，从而能够在容器引擎上直接运行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;容器技术概述&#34;&gt;容器技术概述&lt;/h1&gt;
&lt;p&gt;容器是一种轻量级、可移植、自包含的软件打包技术，它使得应用程序可以在几乎任何地方以相同的方式运行。&lt;/p&gt;
&lt;p&gt;容器有应用程序本身和它的环境依赖（库和其他应用程序）两部分组成，并在宿主机（Host）操作系统的用户空间中运行，但与操作系统的其他进程互相隔离，他们的实现机制有别于VMWare、KVM、Xen等实现方案的虚拟化技术。容器与虚拟机的对比关系如下图
&lt;img src=&#34;https://guoxudong.io/images/source/vs.png&#34; alt=&#34;image&#34;&gt;
由于同一个宿主机上的所有容器都共享其底层操作系统（内核空间），这就使得容器在体积上要比传统的虚拟机小很多。另外，启动容器无须启动整个操作系统，所以容器部署和启动的速度更快，开销更小，也更容易迁移。事实上，容器赋予了应用程序超强的可移植能力。&lt;/p&gt;
&lt;h1 id=&#34;容器技术的优势&#34;&gt;容器技术的优势&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;开发方面：“一次构建、到处运行”（Build Once, Run Anywhere）。容器意味着环境隔离和可重复性，开发人员只需为应用创建一个运行环境，并将其打包成容器便可在各种部署环境上运行，并与它所在的宿主机环境隔离。&lt;/li&gt;
&lt;li&gt;运维方面：“一次配置，运行所以”（Configure Once, Run Anything）。一旦配置好标准的容器运行时环境，服务器就可以运行任何容器，这使得运维人员的工作变得更高效、一致和可重复。容器消除了开发、测试、生产环境的不一致性。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
