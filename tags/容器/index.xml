<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>容器 on MaoXian Play</title>
    <link>https://blog.maoxianplay.com/tags/%E5%AE%B9%E5%99%A8/</link>
    <description>Recent content in 容器 on MaoXian Play</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 27 Sep 2018 19:27:03 +0800</lastBuildDate>
    
	<atom:link href="https://blog.maoxianplay.com/tags/%E5%AE%B9%E5%99%A8/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Docker容器启动退出解决方案</title>
      <link>https://blog.maoxianplay.com/2018/docker-quit/</link>
      <pubDate>Thu, 27 Sep 2018 19:27:03 +0800</pubDate>
      
      <guid>https://blog.maoxianplay.com/2018/docker-quit/</guid>
      <description>现象 启动docker容器
docker run –name [CONTAINER_NAME] [CONTAINER_ID]  查看容器运行状态
docker ps -a  发现刚刚启动的mydocker容器已经退出
原因 docker容器的主线程（dockfile中CMD执行的命令）结束，容器会退出
解决办法  可以使用交互式启动
docker run -i [CONTAINER_NAME or CONTAINER_ID]  上面的不太友好，建议使用后台模式和tty选项
docker run -dit [CONTAINER_NAME or CONTAINER_ID]  Docker 容器在后台以守护态（Daemonized）形式运行，可以通过添加 -d 参数来实现
$ sudo docker run -d ubuntu:14.04 /bin/sh -c &amp;quot;while true; do echo hello world; sleep 1; done&amp;quot;  在脚本最后一行添加tail -f /dev/null，这个命令永远完成不了，所以该脚本一直不会执行完，所以该容器永远不会退出。
   TIPs:退出时，使用[ctrl + D]，这样会结束docker当前线程，容器结束，可以使用[ctrl + P][ctrl + Q]退出而不终止容器运行</description>
    </item>
    
    <item>
      <title>容器技术概述</title>
      <link>https://blog.maoxianplay.com/2018/con-ind/</link>
      <pubDate>Thu, 30 Aug 2018 18:45:22 +0800</pubDate>
      
      <guid>https://blog.maoxianplay.com/2018/con-ind/</guid>
      <description> 背景  自从微服务（Microservice）的出现，出于业务的需要，IT应用模型不断的变革。开发模式从瀑布式到敏捷开发；开发、运维和测试互相配合的devops思想；应用程序架构从单体模型到分层模型再到微服务；部署方式也从面向物理机到虚拟键再到容器；应用程序的基础架构从自建机房到托管再到云计算，等等。这些变革使得IT技术应用的效率大大提升，同时却以更低的成本交付更高质量的产品。
尤其是以Docker为代表的容器技术的出现，终结了devops中交付和部署环节因环节、配置及程序本身的不同而造成的动辄几种甚至十几种部署配置的困境，将它们统一在容器镜像（image）之上。这就是我在工作中遇到最先遇到的困境，同时也是我开始研究容器技术的契机。
如今，越来越多的企业或组织开始开始选择以镜像文件为交付载体。容器镜像之内直接包含了应用程序及其依赖的系统环境、库、基础程序等，从而能够在容器引擎上直接运行。
 容器技术概述 容器是一种轻量级、可移植、自包含的软件打包技术，它使得应用程序可以在几乎任何地方以相同的方式运行。
容器有应用程序本身和它的环境依赖（库和其他应用程序）两部分组成，并在宿主机（Host）操作系统的用户空间中运行，但与操作系统的其他进程互相隔离，他们的实现机制有别于VMWare、KVM、Xen等实现方案的虚拟化技术。容器与虚拟机的对比关系如下图 由于同一个宿主机上的所有容器都共享其底层操作系统（内核空间），这就使得容器在体积上要比传统的虚拟机小很多。另外，启动容器无须启动整个操作系统，所以容器部署和启动的速度更快，开销更小，也更容易迁移。事实上，容器赋予了应用程序超强的可移植能力。
容器技术的优势  开发方面：“一次构建、到处运行”（Build Once, Run Anywhere）。容器意味着环境隔离和可重复性，开发人员只需为应用创建一个运行环境，并将其打包成容器便可在各种部署环境上运行，并与它所在的宿主机环境隔离。 运维方面：“一次配置，运行所以”（Configure Once, Run Anything）。一旦配置好标准的容器运行时环境，服务器就可以运行任何容器，这使得运维人员的工作变得更高效、一致和可重复。容器消除了开发、测试、生产环境的不一致性。·  </description>
    </item>
    
    <item>
      <title>centos7安装指定版本的docker</title>
      <link>https://blog.maoxianplay.com/2018/install-docker/</link>
      <pubDate>Tue, 14 Aug 2018 20:05:21 +0800</pubDate>
      
      <guid>https://blog.maoxianplay.com/2018/install-docker/</guid>
      <description>前言  在使用centos7，并使用荫安装搬运工的时候，往往不希望安装最新版本的搬运工，而是希望安装与自己熟悉或者当前业务环境需要的版本，例如目前Kubernetes支持的最新搬运工版本为v17.03，所以就产生了安装指定版本码头工人的需求。
 安装步骤 # 安装依赖包 yum install -y yum-utils device-mapper-persistent-data lvm2 # 添加Docker软件包源 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo #关闭测试版本list（只显示稳定版） sudo yum-config-manager --enable docker-ce-edge sudo yum-config-manager --enable docker-ce-test # 更新yum包索引 yum makecache fast #NO.1 直接安装Docker CE （will always install the highest possible version，可能不符合你的需求） yum install docker-ce #NO.2 指定版本安装 yum list docker-ce --showduplicates|sort -r #找到需要安装的 yum install docker-ce-17.09.0.ce -y #启动docker systemctl start docker &amp;amp; systemctl enable docker  采坑指南  当然本着万事皆有坑的原则，这里也是有坑的，在安装中也是会遇到如下的问题</description>
    </item>
    
  </channel>
</rss>