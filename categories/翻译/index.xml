<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>翻译 on GuoXD Blog·郭旭东的博客</title>
    <link>https://blog.maoxianplay.com/categories/%E7%BF%BB%E8%AF%91/</link>
    <description>Recent content in 翻译 on GuoXD Blog·郭旭东的博客</description>
    <generator>Source Themes academia (https://sourcethemes.com/academic/)</generator>
    <language>zh-Hans</language>
    <copyright>&lt;a rel=&#39;license&#39; href=&#39;http://creativecommons.org/licenses/by-nc/4.0/&#39; target=&#39;_blank&#39;&gt;知识共享署名-非商业性使用 4.0 国际许可协议&lt;/a&gt;</copyright>
    <lastBuildDate>Tue, 06 Aug 2019 14:01:30 +0800</lastBuildDate>
    
	    <atom:link href="https://blog.maoxianplay.com/categories/%E7%BF%BB%E8%AF%91/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>如何构建混合Kubernetes平台</title>
      <link>https://blog.maoxianplay.com/post/how-we-built-our-hybrid-kubernetes-platfor/</link>
      <pubDate>Tue, 06 Aug 2019 14:01:30 +0800</pubDate>
      
      <guid>https://blog.maoxianplay.com/post/how-we-built-our-hybrid-kubernetes-platfor/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;随着3年前重构 &lt;a href=&#34;https://www.dailymotion.com/&#34; target=&#34;_blank&#34;&gt;Dailymotion&lt;/a&gt; 核心API的决定，我们希望提供一种更有效的方式来托管应用程序，&lt;a href=&#34;https://medium.com/dailymotion/deploying-apps-on-multiple-kubernetes-clusters-with-helm-19ee2b06179e&#34; target=&#34;_blank&#34;&gt;促进我们的开发和生产工作流程&lt;/a&gt;。 最终决定使用容器编排平台来实现这一目标，那么自然就选择了 Kubernetes。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那么为什么要建立自己的Kubernetes平台？&lt;/p&gt;

&lt;h2 id=&#34;借由-google-cloud-快速推动的-api-投入生产&#34;&gt;借由 Google Cloud 快速推动的 API 投入生产&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;2016年夏&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;三年前，在 &lt;a href=&#34;https://www.vivendi.com/&#34; target=&#34;_blank&#34;&gt;Vivendi&lt;/a&gt; 收购 Dailymotion 之后，所有开发团队都专注于一个目标：提供全新的 Dailymotion 产品。&lt;/p&gt;

&lt;p&gt;根据对容器、编排解决方案和以前的经验的分析，使我们确信 Kubernetes 是正确的选择。许多开发人员已经掌握了这一概念并知道如何使用 Kubernetes ，这对我们的基础设施转型来说是一个巨大的优势。在基础架构方面，我们需要一个强大而灵活的平台来托管这些新型的云原生应用程序。而公有云为我们提供了极大的便利，于是我们决定在 Google Kubernetes Engine 上部署我们的应用程序，即使之后我们也会在自己的数据中心中进行混合部署。&lt;/p&gt;

&lt;h3 id=&#34;为何选择-gke&#34;&gt;为何选择 GKE ？&lt;/h3&gt;

&lt;p&gt;我们做出这个选择主要是出于技术原因，但也因为我们需要快速提供基础设施来满足 Dailymotion 的业务需求。并且对托管的应用程序（如地理分布，可伸缩性和弹性）有一些要求。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws2.sinaimg.cn/large/ad5fbf65gy1g5py1vm2k2j20hd0bbjtq.jpg&#34; alt=&#34;&#34; /&gt;
&lt;center&gt;Dailymotion 的 GKE 集群&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;Dailymotion 作为一个全球性的视频平台，需要通过减少延迟来改善用户体验。之前我们仅在巴黎提供 &lt;a href=&#34;https://developer.dailymotion.com/&#34; target=&#34;_blank&#34;&gt;API&lt;/a&gt; ，但这样并非最佳，我们希望能够在欧洲、亚洲以及美国托管我们的应用程序。&lt;/p&gt;

&lt;p&gt;这种延迟限制意味着我们在平台的网络设计方面面临着巨大的挑战。大多数云供应商要求我们在每个地区创建一个网络，并将所有这些网络通过 VPN 与托管服务互连，但 Google Cloud 允许我们在所有 Google 地区创建一个完全路由的单一网络，该网络在运营方面提供了便利并提高了效率。&lt;/p&gt;

&lt;p&gt;此外，Google Cloud 的网络和负载均衡服务非常棒。它可以将我们的用户路由到最近的集群，并且在发生故障的情况下，流量会自动路由到另一个区域而无需任何人为干预。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wx4.sinaimg.cn/large/ad5fbf65gy1g5pytelbwnj20jg0avq4x.jpg&#34; alt=&#34;&#34; /&gt;
&lt;center&gt;Google 负载均衡监控&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;我们的平台同样需要使用 GPU，而 Google Cloud 允许我们以非常有效的方式直接在我们的 Kubernetes 集群中使用它们。&lt;/p&gt;

&lt;p&gt;所有这一切使我们在启动后6个月开始接入 Google Cloud 基础架构上的生产流量。&lt;/p&gt;

&lt;p&gt;但是，尽管具有整体优势，但使用共有云服务还是要花费不少成本。这就是为什么我们要评估采取的每项托管服务，以便将来将其内部化。事实上，我们在2016年底开始构建我们的本地集群，并启动了我们的混合策略。&lt;/p&gt;

&lt;h2 id=&#34;在-dailymotion-的内部构建容器编排平台&#34;&gt;在 Dailymotion 的内部构建容器编排平台&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;2016年秋&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;看到整个技术栈已经准备好在生产环境中应用，但&lt;a href=&#34;https://tartiflette.io/&#34; target=&#34;_blank&#34;&gt;API仍在开发中&lt;/a&gt;，这使得我们有时间专注搭建我们的本地集群。&lt;/p&gt;

&lt;p&gt;Dailymotion 多年来在全球拥有自己的内容分发网络，每月有超过30亿的视频播放量。显然，我们希望利用现有的优势并在我们现有的数据中心部署自己的 Kubernetes 集群。&lt;/p&gt;

&lt;p&gt;我的目前拥有6个数据中心的2500多台服务器。所有这些都使用 Saltstack 进行配置，我们开始准备所有需要的公式来创建主节点、工作节点以及 Etcd 集群。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wx2.sinaimg.cn/large/ad5fbf65gy1g5pzm4m985j20jg06tgm7.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;网络部分&#34;&gt;网络部分&lt;/h3&gt;

&lt;p&gt;我们的网络是一个完全路由的网络。每个服务器使用Exabgp通过网络广播自己的IP。我们比较了几个网络插件， &lt;a href=&#34;https://www.projectcalico.org/&#34; target=&#34;_blank&#34;&gt;Calico&lt;/a&gt; 使用的是三层网络，因此这是唯一满足我们需求的网络插件。&lt;/p&gt;

&lt;p&gt;由于我们想要重用基础架构中的所有现有工具，首先要解决的问题是插入一个自制网络工具（我们所有服务器都使用它），通过我们的 Kubernetes 节点通过网络广播 IP 范围。我们让 Calico 为 pod 分配 IP，但不使用它与我们的网络设备进行BGP会话。路由实际上是由Exabgp处理的，它宣布了Calico使用的子网。这使我们可以从内部网络访问任何pod，尤其是来自我们的负载均衡器。&lt;/p&gt;

&lt;h3 id=&#34;我们如何管理入口流量&#34;&gt;我们如何管理入口流量&lt;/h3&gt;

&lt;p&gt;为了将传入的请求路由到正确的服务，我们希望使用 Ingress Controllers 与 Kubernetes 的入口资源集成。&lt;/p&gt;

&lt;p&gt;3年前，nginx-ingress-controller 是最成熟的控制器 ，并且 Nginx 已经使用多年，并以其稳定性和性能而闻名。&lt;/p&gt;

&lt;p&gt;在我们的设计中，我们决定在专用的 10Gbps 刀片服务器上托管我们的控制器。每个控制器都插入其所属集群的 kube-apiserver 端点。在这些服务器上，我们还使用Exabgp来广播公共或私有IP。我们的网络拓扑允许我们使用来自这些控制器的BGP将所有流量直接路由到我们的pod，而无需使用NodePort服务类型。这样可以避免节点之间的水平流量，从而提高效率。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws3.sinaimg.cn/large/ad5fbf65gy1g5q05ex27bj20in0fbt9q.jpg&#34; alt=&#34;&#34; /&gt;
&lt;center&gt;从 Internet 到 pods 的流量&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;现在我们已经看到了我们如何构建混合平台，我们可以深入了解流量迁移本身。&lt;/p&gt;

&lt;h2 id=&#34;将流量从-google-cloud-迁移到-dailymotions-基础架构&#34;&gt;将流量从 Google Cloud 迁移到 Dailymotions 基础架构&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;2018年秋&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;经过近2年的构建、测试和微调，我们发现自己拥有完整的 Kubernetes 技术栈，可以接收部分流量。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wx2.sinaimg.cn/large/ad5fbf65gy1g5q0b3o8laj20jg06sq36.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;目前，我们的路由策略非常简单，但足以解决我们的问题。除了我们的公共IP（Google Cloud和Dailymotion）之外，我们还使用AWS Route 53 来定义策略并将终端用户流量引入我们选择的集群。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws2.sinaimg.cn/large/ad5fbf65gy1g5q0ds3spjj20jg07a0tk.jpg&#34; alt=&#34;&#34; /&gt;
&lt;center&gt;使用Route 53的路由策略示例&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;在 Google Cloud 上很简单，因为我们为所有群集使用唯一的IP，并且用户被路由到他最近的 GKE 群集。对于我们来说，我们不使用相同的技术，因此我们每个群集都有不同的IP。&lt;/p&gt;

&lt;p&gt;在此次迁移过程中，我们将目标国家逐步纳入我们的集群并分析其收益。&lt;/p&gt;

&lt;p&gt;由于我们的GKE集群配置了自动调节自定义指标，因此它们会根据传入流量进行扩展/缩小。&lt;/p&gt;

&lt;p&gt;在正常模式下，区域的所有流量都路由到我们的内部部署集群，而GKE集群则使用Route 53提供的运行状况检查作为故障转移。&lt;/p&gt;

&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;

&lt;p&gt;我们接下来的步骤是完全自动化我们的路由策略，以实现自动混合策略，不断增强我们的用户体验。在效益方面，我们大大降低了云的成本，甚至改善了API响应时间。我们相信我们的云平台足以在需要时处理更多流量。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用 Helm 在多集群部署应用</title>
      <link>https://blog.maoxianplay.com/post/deploying-apps-on-multiple-kubernetes-clusters-with-hel/</link>
      <pubDate>Sun, 14 Jul 2019 14:16:56 +0800</pubDate>
      
      <guid>https://blog.maoxianplay.com/post/deploying-apps-on-multiple-kubernetes-clusters-with-hel/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.dailymotion.com/&#34; target=&#34;_blank&#34;&gt;Dailymotion&lt;/a&gt; 在生产环境使用 Kubernetes 已经3年了，但是也面临着多集群部署应用的挑战，这也是在过去的几年中我一直努力优化工具和改进工作流的原因。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;本文将重点介绍我们如何在全球多个 Kubernetes 集群上部署我们的应用程序。&lt;/p&gt;

&lt;p&gt;为了将应用一次部署到多个 Kubernetes 集群，我们使用了 &lt;a href=&#34;https://helm.sh/&#34; target=&#34;_blank&#34;&gt;Helm&lt;/a&gt;，并将所有 chart 存储在一个 git 仓库中。我们使用 &lt;strong&gt;umbrella&lt;/strong&gt; 来部署由多个服务组成的完整应用程序，这基本上是一个声明依赖关系的 chart ，其允许我们在单个命令行中引导我们的 API 及其服务。&lt;/p&gt;

&lt;p&gt;此外，我们在使用 Helm 之前会运行一个 python 脚本，用来进行检查，构建 chart ，添加 secrets 并部署我们的应用程序。所有这些任务都是使用 docker 镜像在 CI 平台上完成的。&lt;/p&gt;

&lt;p&gt;下面就进行详细介绍&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意！：&lt;/strong&gt; 当你阅读这篇博文的时候，Helm 3 的第一个 &lt;a href=&#34;https://github.com/helm/helm/releases/tag/v3.0.0-alpha.1&#34; target=&#34;_blank&#34;&gt;release&lt;/a&gt; 已经发布。这个版本带来了一系列增强功能，肯定会解决我们过去遇到的一些问题。&lt;/p&gt;

&lt;p&gt;image:
  caption: &amp;ldquo;Image from: &lt;a href=&#34;https://www.pexels.com&#34; target=&#34;_blank&#34;&gt;&lt;strong&gt;Pexels&lt;/strong&gt;&lt;/a&gt;&amp;ldquo;
  focal_point: &amp;ldquo;&amp;rdquo;&lt;/p&gt;

&lt;h2 id=&#34;preview-only-false&#34;&gt;preview_only: false&lt;/h2&gt;

&lt;h2 id=&#34;charts-开发流程&#34;&gt;Charts 开发流程&lt;/h2&gt;

&lt;p&gt;在开发应用程序时，我们使用&lt;a href=&#34;https://git-scm.com/book/en/v2/Git-Branching-Branching-Workflows&#34; target=&#34;_blank&#34;&gt;分支工作流&lt;/a&gt;，开发 chart 时也使用相同流程。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先，&lt;strong&gt;dev&lt;/strong&gt; 分支用于构建要在开发集群上进行测试的 chart 。&lt;/li&gt;
&lt;li&gt;然后，当发起 PR 请求到 &lt;strong&gt;master&lt;/strong&gt; 分支时，将发布到演示环境中进行验证。&lt;/li&gt;
&lt;li&gt;最终，我们将 PR 请求提交的修改合并到 &lt;strong&gt;prod&lt;/strong&gt; 分支，将这个修改应用于生产环境。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们使用 &lt;a href=&#34;https://chartmuseum.com/&#34; target=&#34;_blank&#34;&gt;Chartmuseum&lt;/a&gt; 作为私有仓库来存储 chart ，每个环境都有一个 。这样我们就可以在&lt;strong&gt;环境之间实现明确的隔离&lt;/strong&gt;，并且确保该 chart 在生产环境中使用之前已经过测试。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wx2.sinaimg.cn/large/ad5fbf65gy1g50h10d4xbj20ys0ee75e.jpg&#34; alt=&#34;&#34; /&gt;
&lt;center&gt;每个环境的 Chart 仓库&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;值得注意的是，当开发人员 push 代码到他们的 dev 分支时，他们的 chart 版本也会自动 push 到 dev 环境的 Chartmuseum 。因此，所有开发人员都使用相同的 dev 存储库，他们必须小心的指定自己的 chart 版本，以避免使用其他人的对 chart 的更改。&lt;/p&gt;

&lt;p&gt;此外，我们的 python 脚本通过使用 &lt;a href=&#34;https://kubeval.instrumenta.dev/&#34; target=&#34;_blank&#34;&gt;Kubeval&lt;/a&gt; 在它们推送到 Chartmusem 之前验证 Kubernetes 对象与 Kubernetes OpenAPI 规范。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;chart 开发工作流&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://ws3.sinaimg.cn/large/ad5fbf65gy1g50hg9gmh2j20gr047t8o.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;根据 &lt;a href=&#34;https://gazr.io/&#34; target=&#34;_blank&#34;&gt;gazr.io&lt;/a&gt; 规范设置我们的 pipeline 任务（lint，unit-test）。&lt;/li&gt;
&lt;li&gt;push docker 镜像，该镜像包含部署应用程序的 Python 工具。&lt;/li&gt;
&lt;li&gt;根据分支名称设置相应环境。&lt;/li&gt;
&lt;li&gt;使用 Kubeval 检查 Kubernetes yamls 。&lt;/li&gt;
&lt;li&gt;自动增加 chart 版本及其父项（取决于更改的 chart ）。&lt;/li&gt;
&lt;li&gt;将 chart push 到与其环境对应的 Chartmuseum 。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;管理集群差异&#34;&gt;管理集群差异&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Cluster federation&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们使用 &lt;a href=&#34;https://kubernetes.io/docs/concepts/cluster-administration/federation/&#34; target=&#34;_blank&#34;&gt;Kubernetes cluster federation&lt;/a&gt;，它允许我们从单个 API 端声明 Kubernetes 对象。但是我们遇到的问题是，无法在 federation 端中创建某些 Kubernetes 对象，因此很难维护 federation 对象和其他的群集对象。&lt;/p&gt;

&lt;p&gt;为了解决这个问题，我们决定独立管理我们的集群，反而使这个过程变得更加容易（我们使用的是 federation v1，v2 可能有所改善）。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;平台地理分布&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;目前，我们的平台分布在6个地区，3个在自己的数据中心，3个在公有云。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/ad5fbf65gy1g50klup6yaj212w0ftq4h.jpg&#34; alt=&#34;&#34; /&gt;
&lt;center&gt;分布式部署&lt;/center&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Helm global values&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;4个全局的 Helm value 定义集群间的差异。这些是我们所有 chart 的最小默认值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;    global:
        cloud: True
        env: staging
        region: us-central1
        clusterName: staging-us-central1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;center&gt;global values&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;这些信息有助于我们为应用程序定义上下文，它们可用于监控，跟踪，记录，进行外部调用，扩展等许多内容&amp;hellip;&amp;hellip;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;cloud&lt;/strong&gt;：我们有一个混合 Kubernetes 集群。例如，我们的 API 部署在 GCP 和我们自己的数据中心。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;env&lt;/strong&gt;：对于非生产环境，某些值可能会发生变化。本质上是资源定义和自动扩展配置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;region&lt;/strong&gt;：此信息用于标识群集的位置，并可用于定义外部服务的最近端点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;clusterName&lt;/strong&gt;：如果我们想要为每个群集定义一个值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面是一个具体的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;{{/* Returns Horizontal Pod Autoscaler replicas for GraphQL*/}}
{{- define &amp;quot;graphql.hpaReplicas&amp;quot; -}}
{{- if eq .Values.global.env &amp;quot;prod&amp;quot; }}
{{- if eq .Values.global.region &amp;quot;europe-west1&amp;quot; }}
minReplicas: 40
{{- else }}
minReplicas: 150
{{- end }}
maxReplicas: 1400
{{- else }}
minReplicas: 4
maxReplicas: 20
{{- end }}
{{- end -}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;center&gt;helm template example&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;请注意，此逻辑在帮助模板中定义，以保持 Kubernetes YAML 的可读性。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;声明应用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们的部署工具基于几个 YAML 文件，下面是我们声明服务及其每个集群的扩展拓扑（副本数量）的示例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;releases:
  - foo.world
 
foo.world:                # Release name
  services:               # List of dailymotion&#39;s apps/projects
    foobar:
      chart_name: foo-foobar
      repo: git@github.com:dailymotion/foobar
      contexts:
        prod-europe-west1:
          deployments:
            - name: foo-bar-baz
              replicas: 18
            - name: another-deployment
              replicas: 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;center&gt;service definition&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;这是部署工作流的所有步骤，最后一步将在多个生产集群上同时部署应用程序。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/ad5fbf65gy1g50ldllp33j20mw0bxglz.jpg&#34; alt=&#34;&#34; /&gt;
&lt;center&gt;Jenkins deployment steps&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;secrets-怎么办&#34;&gt;Secrets 怎么办&lt;/h2&gt;

&lt;p&gt;在安全领域，我们专注于跟踪可能在不同位置传播的所有的 Secrets ，并将其存储在巴黎的 &lt;a href=&#34;https://www.vaultproject.io/&#34; target=&#34;_blank&#34;&gt;Vault&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;我们的部署工具负责从 Vault 检索加密的值，并在部署时将其注入 Helm 。&lt;/p&gt;

&lt;p&gt;为此，我们定义了存储在 Vault 中的 Secrets 与我们的应用程序所需的 Secrets 之间的映射，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;secrets: 
     - secret_id: &amp;quot;stack1-app1-password&amp;quot;
       contexts:
         - name: &amp;quot;default&amp;quot;
           vaultPath: &amp;quot;/kv/dev/stack1/app1/test&amp;quot;
           vaultKey: &amp;quot;password&amp;quot;
         - name: &amp;quot;cluster1&amp;quot;
           vaultPath: &amp;quot;/kv/dev/stack1/app1/test&amp;quot;
           vaultKey: &amp;quot;password&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;定义将 Secrets 写入 Vault 时要遵循的通用规则。&lt;/li&gt;
&lt;li&gt;如果 Secrets 有特定的上下文/集群，则必须添加特定条目。&lt;/li&gt;
&lt;li&gt;否则，将使用默认值。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于此列表中的每个项目，将在 Kubernetes Secrets 中插入一个 key/value 。这样我们 chart 中的 Secrets 模板非常简单。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
data:
{{- range $key,$value := .Values.secrets }}
{{ $key }}: {{ $value | b64enc | quote }}
{{ end }}
kind: Secret
metadata:
name: &amp;quot;{{ .Chart.Name }}&amp;quot;
labels:
chartVersion: &amp;quot;{{ .Chart.Version }}&amp;quot;
tillerVersion: &amp;quot;{{ .Capabilities.TillerVersion.SemVer }}&amp;quot;
type: Opaque
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;警告与限制&#34;&gt;警告与限制&lt;/h2&gt;

&lt;p&gt;image:
  caption: &amp;ldquo;Image from: &lt;a href=&#34;https://www.pexels.com&#34; target=&#34;_blank&#34;&gt;&lt;strong&gt;Pexels&lt;/strong&gt;&lt;/a&gt;&amp;ldquo;
  focal_point: &amp;ldquo;&amp;rdquo;&lt;/p&gt;

&lt;h2 id=&#34;preview-only-false-1&#34;&gt;preview_only: false&lt;/h2&gt;

&lt;h3 id=&#34;操作多个存储库&#34;&gt;操作多个存储库&lt;/h3&gt;

&lt;p&gt;目前，chart 和应用程序开发是分离的。这意味着开发人员必须处理两个 git 存储库，一个用于应用程序，另一个用于定义如何在 Kubernetes 上部署。而2个 git 存储库意味着两个工作流程，这对于新手来说可能相当复杂。&lt;/p&gt;

&lt;h3 id=&#34;管理-umbrella-charts-可能很棘手&#34;&gt;管理 umbrella charts 可能很棘手&lt;/h3&gt;

&lt;p&gt;如前所述，umbrella charts 非常适合定义依赖关系并快速部署多个应用程序。同时我们使用 &lt;code&gt;--reuse-values&lt;/code&gt; 选项，以避免每次部署作为 umbrella charts 一部分的应用程序时都要传递所有值。&lt;/p&gt;

&lt;p&gt;在我们的 CD 工作流中，只有2个值会定期更改：副本数量和镜像标签（版本）。对于其他更稳定的值，需要手动更新，而且这些值并不是很容易弄清楚。此外，我们曾遇到过部署 umbrella charts 的一个错误导致严重的中断。&lt;/p&gt;

&lt;h3 id=&#34;更新多个配置文件&#34;&gt;更新多个配置文件&lt;/h3&gt;

&lt;p&gt;添加新应用程序时，开发人员必须更改多个文件：应用程序声明， Secrets 列表，如果应用程序是 umbrella charts 的一部分，则将其添加到依赖。&lt;/p&gt;

&lt;h3 id=&#34;在-vault-上-jenkins-权限过大&#34;&gt;在 Vault 上， Jenkins 权限过大&lt;/h3&gt;

&lt;p&gt;目前，我们有一个 &lt;a href=&#34;https://www.vaultproject.io/docs/auth/approle.html&#34; target=&#34;_blank&#34;&gt;AppRole&lt;/a&gt; 可以读取 Vault 的所有 Secrets 。&lt;/p&gt;

&lt;h3 id=&#34;回滚过程不是自动化的&#34;&gt;回滚过程不是自动化的&lt;/h3&gt;

&lt;p&gt;回滚需要在多个集群上运行该命令，这可能容易出错。我们制作本操作手册是因为我们要确保应用正确的版本 ID 。&lt;/p&gt;

&lt;h2 id=&#34;gitops-实践&#34;&gt;GitOps 实践&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;目标&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们的想法是将 chart 放回到它部署的应用程序的存储库下。工作流程与应用同时开发，例如，无论何时在主服务器上合并分支，都会自动触发部署。这种方法与当前工作流程的主要区别在于，所有内容都将通过 git 进行管理（应用程序本身以及我们在 Kubernetes 中部署它的方式）。&lt;/p&gt;

&lt;p&gt;这样做优点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从开发人员的角度来看，更容易理解。学习如何在本地 chart 中应用更改将更容易。&lt;/li&gt;
&lt;li&gt;将服务 deployment 定义在与此服务的代码相同的位置。&lt;/li&gt;
&lt;li&gt;移除 umbrella charts 管理。服务将拥有自己的 Helm 版本。这使得应用程序生命周期管理（回滚，升级）形成闭环，不会影响其他服务。&lt;/li&gt;
&lt;li&gt;git 功能对 chart 管理的好处：回滚，审计日志&amp;hellip;&amp;hellip;如果要还原 chart 更改，可以使用 git 进行更改。同时部署将自动触发。&lt;/li&gt;
&lt;li&gt;我们考虑使用 Skaffold 等工具改进开发工作流程，这些工具允许开发人员在类似于生产的环境中测试他们的更改。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;2步迁移&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们的开发人员已使用上述工作流程2年，因此我们需要尽可能顺利地进行迁移。这就是为什么我们决定在达到目标之前添加一个中间步骤。&lt;/p&gt;

&lt;p&gt;第一步很简单：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;我们将保留一个类似的结构来配置我们的应用程序部署，但是在名为 “DailymotionRelease” 的单个对象中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: &amp;quot;v1&amp;quot;
kind: &amp;quot;DailymotionRelease&amp;quot;
metadata:
name: &amp;quot;app1.ns1&amp;quot;
environment: &amp;quot;dev&amp;quot;
branch: &amp;quot;mybranch&amp;quot;
spec:
slack_channel: &amp;quot;#admin&amp;quot;
chart_name: &amp;quot;app1&amp;quot;
scaling:
- context: &amp;quot;dev-us-central1-0&amp;quot;
  replicas:
    - name: &amp;quot;hermes&amp;quot;
      count: 2
- context: &amp;quot;dev-europe-west1-0&amp;quot;
  replicas:
    - name: &amp;quot;app1-deploy&amp;quot;
      count: 2
secrets:
- secret_id: &amp;quot;app1&amp;quot;
  contexts:
    - name: &amp;quot;default&amp;quot;
      vaultPath: &amp;quot;/kv/dev/ns1/app1/test&amp;quot;
      vaultKey: &amp;quot;password&amp;quot;
    - name: &amp;quot;dev-europe-west1-0&amp;quot;
      vaultPath: &amp;quot;/kv/dev/ns1/app1/test&amp;quot;
      vaultKey: &amp;quot;password&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;每个应用程序一个版本（不再使用 umbrella charts ）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将 chart 加入应用程序 git 存储库中&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们已经开始向所有开发人员科普这个词，并且迁移过程已经开始。第一步仍然使用 CI 平台进行控制。我将在短期内撰写另一篇博文，介绍第二步：我们如何通过 &lt;a href=&#34;https://github.com/weaveworks/flux&#34; target=&#34;_blank&#34;&gt;Flux&lt;/a&gt; 实现向 GitOps 工作流程的迁移。将描述我们的设置和面临的挑战（多个存储库，Secrets 等）。 敬请期待！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【转】Kubernetes 儿童插图指南</title>
      <link>https://blog.maoxianplay.com/post/the-childrens-illustrated-guide-to-kubernetes/</link>
      <pubDate>Fri, 05 Jul 2019 09:50:58 +0800</pubDate>
      
      <guid>https://blog.maoxianplay.com/post/the-childrens-illustrated-guide-to-kubernetes/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;转自掘金社区，原文地址：&lt;a href=&#34;https://juejin.im/post/5d1b2a656fb9a07edc0b7058&#34; target=&#34;_blank&#34;&gt;https://juejin.im/post/5d1b2a656fb9a07edc0b7058&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;kubernetes-儿童插图指南&#34;&gt;Kubernetes 儿童插图指南&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://ws4.sinaimg.cn/large/ad5fbf65gy1g4nwsdbr8wj20qo0hs0w2.jpg&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://wx3.sinaimg.cn/large/ad5fbf65gy1g4nwt5keovj210u0shmyc.jpg&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://wx4.sinaimg.cn/large/ad5fbf65gy1g4nwteb85hj20qo0hsk5v.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;献给所有试图向孩子们解释软件工程的家长。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/ad5fbf65gy1g4nwu2t40sj20qo0hswqv.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;很久很久以前，有一个叫 Phippy 的应用程序。她是一个简单的应用程序，由 PHP 编写且只有一个页面。她住在一个需要和其他可怕的应用程序分享环境的主机中，她不认识这些应用程序并且不愿意和他们来往。她希望她能拥有一个属于自己的环境：只有她自己和她可以称之为家的 Web 服务器。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wx1.sinaimg.cn/large/ad5fbf65gy1g4nwutz6f2j20qo0hsq90.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;每个应用程序都有个运行所依赖的环境。对于 PHP 应用程序来说，这个环境可能包括 Web 服务器，一个可读文件系统和 PHP 引擎本身。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wx2.sinaimg.cn/large/ad5fbf65gy1g4nwvduq0mj20qo0hsdu8.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;有一天，一只善良的鲸鱼出现了。他建议小 Phippy 住在容器里，这样可能会更快乐。所以应用程序 Phippy 迁移到了容器中。这个容器很棒，但是……它有点像一个漂浮在大海中央的豪华起居室。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wx2.sinaimg.cn/large/ad5fbf65gy1g4nwwr0uk3j20qo0hs0zi.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;容器提供了一个独立的环境，应用程序可以在这个环境中运行。但是这些孤立的容器常常需要被管理并与外面的世界连接。对于孤立的容器而言，共享文件系统、网络通信、调度、负载均衡和分发都是要面对的挑战。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wx4.sinaimg.cn/large/ad5fbf65gy1g4nwx3kj32j20qo0hswr7.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;鲸鱼耸了耸肩。“对不起，孩子。”他说着，消失在海面下。就在 Phippy 甚至开始绝望时，一位驾驶着巨轮的船长出现在海平线上。这艘船由几十个绑在一起的木筏组成，但从外面来看，它就像一艘巨轮。
“你好呀，这位 PHP 应用程序朋友。我是 Kube 船长。”睿智的老船长说。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wx3.sinaimg.cn/large/ad5fbf65gy1g4nwxm9w44j20qo0hsn3b.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;“Kubernetes” 在希腊语中是船长的意思。我们可以从这个单词中得到 Cybernetic 和 Gubernatorial 这两个词组。Kubernetes 项目专注于构建一个健壮的平台，用于在生产环境中运行数千个容器。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wx2.sinaimg.cn/large/ad5fbf65gy1g4nwxzqi7vj20qo0hsgxn.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;“我是 Phippy。”小应用程序说。&lt;/p&gt;

&lt;p&gt;“很高兴认识你。”船长一边说，一边在她身上贴上了一张标有姓名的标签。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wx3.sinaimg.cn/large/ad5fbf65gy1g4nwygks8xj20qo0hs0zy.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Kubernetes 使用标签作为“名牌”来标识事物。它可以根据这些标签进行查询。标签是开放性的：你可以用他们来表示角色、稳定性或其他重要的属性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/ad5fbf65gy1g4nwyt7gtqj20qo0hsdso.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;船长建议应用程序把她的容器搬到船上的一个船舱中。Phippy 很高兴地把她的容器搬到 Kube 船长巨轮的船舱内。Phippy 觉得这里像家一样。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/ad5fbf65gy1g4nwzc5uqej20qo0hswlp.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在 Kubernetes 中，Pod 代表一个可运行的工作单元。通常，你会在 Pod 中运行一个容器。但是对于一些容器紧密耦合的情况，你可以选择在同一个 Pod 中运行多个容器。Kubernetes 负责将你的 Pod 和网络以及 Kubernetes 的其余环境相连。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wx2.sinaimg.cn/large/ad5fbf65gy1g4nwztzwfsj20qo0hsqdi.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Phippy 有一些不同寻常的兴趣，她很喜欢遗传学和绵羊。所以她问船长：“如果我想克隆我自己，是否可以根据需求克隆任意次数呢？”&lt;/p&gt;

&lt;p&gt;“这很容易。”船长说。船长把 Phippy 介绍给了 Replication Controller。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws4.sinaimg.cn/large/ad5fbf65gy1g4nx08r8toj20qo0hsdnl.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Replication Controller 提供一种管理任意数量 Pod 的方法。一个 Replication Controller 包含一个 Pod 模板，该模板可以被复制任意次数。通过 Replication Controller，Kubernetes 将管理 Pod 的生命周期，包括伸缩、滚动更新和监控。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wx2.sinaimg.cn/large/ad5fbf65gy1g4nx0phj56j20qo0hsnb3.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;无数个日夜，小应用程序在她的船舱中与她的复制品相处十分愉快。但与自己为伍并没有所说的那么好……即使你拥有 N 个自己的克隆体。
Kube 船长慈祥地笑了笑：“我正好有一样东西。”
他刚开口，在 Phippy 的 Replication Controller 和船的其他部分之间打开了一条隧道。Kube 船长笑着说：“即使你的复制品来了又去，这条隧道始终会留在这里，你可以通过它发现其他 Pod，其他 Pod 也可以发现你！”&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws2.sinaimg.cn/large/ad5fbf65gy1g4nx160hjkj20qo0hsjyp.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;服务告知 Kubernetes 环境的其余部分（包括其他 Pod 和 Replication Controller）你的应用程序包含了哪些服务，当 Pod 来来往往，服务的 IP 地址和端口始终保持不变。其他应用程序可以通过 Kurbenetes 服务发现找到你的服务。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wx2.sinaimg.cn/large/ad5fbf65gy1g4nx1kbahcj20qo0hsk2e.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;多亏了这些服务，Phippy 开始探索船的其他部分。不久之后，Phippy 遇到了 Goldie。他们成了最好的朋友。有一天，Goldie 做了一件不同寻常的事。她送给 Phippy 一件礼物。Phippy 看了礼物一眼，悲伤的泪水夺眶而出。
“你为什么这么伤心呢？”Goldie 问道。
“我喜欢这个礼物，但我没有地方可以放它！”Phippy 抽噎道。
但 Goldie 知道该怎么做。“为什么不把它放入卷中呢？”&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws4.sinaimg.cn/large/ad5fbf65gy1g4nx2ibi95j20qo0hsdnp.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;卷表示容器可以访问和存储信息的位置。对于应用程序，卷显示为本地文件系统的一部分。但卷可以由本地存储、Ceph、Gluster、持久性块存储，以及其他存储后端支持。
Phippy 喜欢在 Kube 船长的船上生活，她很享受来自新朋友的陪伴（Goldie 的每个克隆人都同样令人愉悦）。但是，当她回想起在可怕的主机度过的日子，她想知道她是否也可以拥有一点自己的隐私。
“这听起来像是你所需要的，”Kube 船长说，“这是一个命名空间。”&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws2.sinaimg.cn/large/ad5fbf65gy1g4nx2nyz4uj20qo0hs10l.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;命名空间是 Kubernetes 内部的分组机制。服务、Pod、Replication Controller 和卷可以在命名空间内部轻松协作，但命名空间提供了与集群其他部分一定程度的隔离。
Phippy 与她的新朋友一起乘坐 Kube 船长的巨轮航行于大海之上。她经历了许多伟大的冒险，但最重要的是，Phippy 找到了自己的家。
所以 Phippy 从此过上了幸福的生活。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws2.sinaimg.cn/large/ad5fbf65gy1g4nx34vepkj21120shwek.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>什么是 DevOps ？DevOps 是如何工作的？</title>
      <link>https://blog.maoxianplay.com/post/all-about-devops-fundamentalsyou-ever-wanted-to-know/</link>
      <pubDate>Thu, 09 May 2019 09:55:11 +0800</pubDate>
      
      <guid>https://blog.maoxianplay.com/post/all-about-devops-fundamentalsyou-ever-wanted-to-know/</guid>
      <description>

&lt;p&gt;在当前的 IT 实践中，为了支持高效和快捷的软件开发，出现了巨大的转变：在单体应用的软件架构正在逐渐被微服务架构取代的情况下，开发、 QA 和运维团队为了摆脱了之前相互孤立的状况，开始相互关联并融合统一，我们将其称为DevOps。&lt;/p&gt;

&lt;p&gt;当今如果一个技术驱动型企业想要以客户为导向来进行快速的软件迭代，那么他们需要更快速的软件开发和交付周期。而这些需求直接导致了 DevOps 文化的核心 CI/CD 实践的诞生。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;CI 持续集成：一种专注于使发布更容易的软件开发实践。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;CD 持续交付：是持续集成的延伸，以确保您可以以可持续的方式快速向客户发布新的更改。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;早期整个 SDLC 都是线性和顺序的，这拉长了产品的发布周期。但随着快速变化的市场动态、激烈的竞争和多变的客户需求，这些都会导致公司无法继续使用原先开发流程。他们必须更贴近客户，需要不断创新以保持他们的参与。而 DevOps 为此提供了解决方案，并被技术驱动的公司广泛采用，用来改进其快速交付的流程和实践。&lt;/p&gt;

&lt;p&gt;那么让我们试着了解什么是 DevOps ？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DevOps 定义：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;提到 DevOps 我经常引用 w.r.t 的话：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;任何公司在学会使用最佳 DevOps 实践进行协作、统一和自动化所有开发和运维流程之前，都将无法扩展和维持。这是一种将每个人联系在一起实现共同目标的文化。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;是时候让所有团队成员与他们的部门密切合作，采用工具和实践来高效地交付软件产品。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://www.atlassian.com/devops&#34; target=&#34;_blank&#34;&gt;Atlassian 将 DevOps 定义为&lt;/a&gt;：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;DevOps 是一组软件开发和运维团队之间的自动化流程实践，以便他们可以快速、可靠地构建，测试和发布软件。DevOps 的概念建立在为过去相对孤立的团队之间建立合作文化的基础上。其带来的好处包括更加可靠、更快的软件发布，快速解决关键问题的能力，以及更好地管理计划外的工作。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon 将 DevOps 定义为：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;文化理念、实践和工具的结合，提高了团队的高速交付应用程序和服务的能力：与使用单体应用的软件开发架构管理流程的团队相比，以更快的速度开发和改进产品。这种速度使团队能够更好地为客户服务，并在市场竞争中占据有利地位。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Microsoft 以更简化的方式定义 DevOps：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“DevOps 可以为我们的终端客户持续提供价值的人员，流程和产品的结合。”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;我认为 DevOps 的最佳解释为：它是一种文化，是一种将人放在首位团队理念，为他们提供适宜的环境，使他们能够蓬勃发展，因此无论他们属于什么部门，都可以通过明确的流程进行协作和沟通，从而实现目标。&lt;/p&gt;

&lt;h2 id=&#34;devops-是如何工作的&#34;&gt;DevOps 是如何工作的？&lt;/h2&gt;

&lt;p&gt;如上所述，DevOps 没有任何固定的规则和实践，但它更像是通过来自不同部门具有不同的技能的团队在一起以实现预期的结果的文化。那么它实际上是如何工作的，让我通过下图简要解释一下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws2.sinaimg.cn/large/ad5fbf65gy1g2v3dnchftj20jg065dgv.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;因此，开发人员，QA 和运维团队使用 CI/CD 实践来实现客户的预期目标。开发人员编写代码并将其提交到 GitHub 等源码控制工具。DevOps 工程师使用 CI 工具来提取代码，来进行自动化测试，并通过 CD 工具部署到处理生产或测试服务器。&lt;/p&gt;

&lt;p&gt;开发和运维人员一起工作，并使用各种工具进行 CI/CD 和监控，以快速响应客户需求并修复问题和错误。&lt;/p&gt;

&lt;h2 id=&#34;devops工具在devops周期的各个阶段&#34;&gt;DevOps工具在DevOps周期的各个阶段：&lt;/h2&gt;

&lt;p&gt;如下所示：
&lt;img src=&#34;https://ws2.sinaimg.cn/large/ad5fbf65gy1g2v3ukk6kzj20xc0e5dvj.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;DevOps 工程师可以使用多种工具在整个 DevOps 生命周期的每个阶段获取期望的结果。&lt;/p&gt;

&lt;h3 id=&#34;计划&#34;&gt;计划：&lt;/h3&gt;

&lt;p&gt;您可以使用 &lt;strong&gt;Jira&lt;/strong&gt; 或 &lt;strong&gt;Azure DevOps Board&lt;/strong&gt; 以敏捷方式管理和规划您的工作。&lt;/p&gt;

&lt;h3 id=&#34;开发&#34;&gt;开发：&lt;/h3&gt;

&lt;p&gt;对于代码管理， &lt;strong&gt;Git&lt;/strong&gt; 以分布式方式管理代码版本历史、分支、推送和拉取机制的首要工具。您还可以使用 &lt;strong&gt;Microsoft TFVC&lt;/strong&gt;（Team Foundation Version Control），这是一个集中版本控制系统。&lt;/p&gt;

&lt;h3 id=&#34;测试&#34;&gt;测试：&lt;/h3&gt;

&lt;p&gt;要进行自动化测试，您可以使用 &lt;strong&gt;Selenium&lt;/strong&gt; 、 &lt;strong&gt;JUnit&lt;/strong&gt; 和 &lt;strong&gt;Apache JMeter&lt;/strong&gt; 。&lt;/p&gt;

&lt;h3 id=&#34;集成&#34;&gt;集成：&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Jenkins&lt;/strong&gt; 是目前最受欢迎的 CI 工具之一，它可以做到无缝地集成开发和运维流程。&lt;/p&gt;

&lt;p&gt;其他 CI 工具还有 &lt;strong&gt;Travis&lt;/strong&gt; ＆ &lt;strong&gt;Bamboo&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;部署和配置管理&#34;&gt;部署和配置管理：&lt;/h3&gt;

&lt;p&gt;Docker 是最受欢迎和广泛使用的持续部署工具之一。它也是软件容器化工具。&lt;/p&gt;

&lt;p&gt;其他部署和配置管理工具还有 &lt;strong&gt;Kubernetes&lt;/strong&gt; 、 &lt;strong&gt;Chef&lt;/strong&gt; 、&lt;strong&gt;Ansible&lt;/strong&gt; 和 &lt;strong&gt;Puppet&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;Kubernetes 是一个开源容器管理（编排）工具。其容器管理职责包括容器部署，容器扩展和伸缩以及容器的负载均衡。&lt;/p&gt;

&lt;h3 id=&#34;监控&#34;&gt;监控：&lt;/h3&gt;

&lt;p&gt;将产品部署到正确的位置后，持续的监控就变得至关重要。 &lt;strong&gt;Nagios&lt;/strong&gt; 、 &lt;strong&gt;Splunk&lt;/strong&gt; 和 &lt;strong&gt;New Relics&lt;/strong&gt; 是广泛使用的持续监控工具。&lt;/p&gt;

&lt;h2 id=&#34;devops-最佳实践&#34;&gt;DevOps 最佳实践：&lt;/h2&gt;

&lt;p&gt;正如文章开头所讨论的那样，为了使技术驱动的公司变得更加以客户为导向，他们需要将自己从单体应用的软件开发实践转变为为客户发布产品的敏捷方式。让我们试着了解他们需要采用的最佳 DevOps实践：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;持续集成&lt;/li&gt;
&lt;li&gt;持续交付&lt;/li&gt;
&lt;li&gt;微服务&lt;/li&gt;
&lt;li&gt;基础设施即代码&lt;/li&gt;
&lt;li&gt;监控和日志&lt;/li&gt;
&lt;li&gt;沟通与协作&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;让我简要解释一下&lt;/p&gt;

&lt;h3 id=&#34;1-持续集成&#34;&gt;1. 持续集成：&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Amazon 将 CI 定义为：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;DevOps 软件开发实践，开发人员定期将代码修改合并到中央存储库，然后运行自动构建和测试。持续集成通常是指软件发布过程的构建或集成阶段，并且需要自动化组件（例如，CI 或构建服务）。持续集成的目的是更快地发现和解决问题，提高软件质量，并减少验证和发布新软件更新所需的时间。&lt;/p&gt;

&lt;h3 id=&#34;2-持续交付&#34;&gt;2.持续交付：&lt;/h3&gt;

&lt;p&gt;持续交付是一种软件开发实践，其中开发人员完成的任何代码更改都会自动为发布到生产环境做好准备。&lt;/p&gt;

&lt;p&gt;通过在构建阶段之后将所有的代码更改部署到测试环境或生产环境，持续交付可在持续集成时进行扩展。&lt;/p&gt;

&lt;h3 id=&#34;3-微服务-敏捷开发的架构&#34;&gt;3. 微服务：敏捷开发的架构&lt;/h3&gt;

&lt;p&gt;这是一种新的软件设计方法，您可以将单个应用程序拆分为一组小型服务/模块。与单体应用架构将所有前端和后端代码库以及数据库都全部部署在同一个服务器地址中相比，基于微服务架构的应用程序被分解为服务，其中每个服务器都在其中运行使用基于 HTTP 的应用程序编程接口（API），通过定义良好的接口使自己与其他服务进行通信。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;按照 Amazon 的介绍：&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;微服务是围绕业务能力构建的; 每项服务的范围都是一个简单的用途。您可以使用不同的框架或编程语言来编写微服务并将它们作为单个服务或一组服务独立部署。&lt;/p&gt;

&lt;h3 id=&#34;4-基础设施即代码-iac&#34;&gt;4. 基础设施即代码：IaC&lt;/h3&gt;

&lt;p&gt;是通过机器可读定义文件（代码库）管理和配置计算机数据中心的过程，而不是物理硬件配置或交互式配置工具。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wx1.sinaimg.cn/large/ad5fbf65gy1g2v5f38rbij20sg0g0764.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazon 定义 IaC 为：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;作为使用代码和软件开发技术（例如版本控制和持续集成）来配置和管理基础架构的实践。云服务的 API 驱动模型使开发人员和系统管理员能够以编程方式大规模地与基础架构交互，而不需要手动设置和配置资源。&lt;/p&gt;

&lt;p&gt;因此，开发人员可以使用基于代码的工具与基础架构进行交互，使其更像应用程序。这使得可以使用标准化模式快速部署基础架构和服务器，使用最新的补丁和版本进行更新，或以副本的方式进行复制部署。&lt;/p&gt;

&lt;p&gt;传统的服务（生命周期）自动化和配置管理工具用于完成IaC。现在企业也在使用连续配置自动化工具或独立的 IaC 框架，例如 &lt;strong&gt;Microsoft 的 PowerShell DSC&lt;/strong&gt; 或 &lt;strong&gt;AWS CloudFormation&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;5-监控与日志&#34;&gt;5. 监控与日志&lt;/h3&gt;

&lt;p&gt;公司可以通过监控指标和日志，来了解其应用程序和基础架构的运行情况。APM（&lt;strong&gt;Application performance management&lt;/strong&gt; 应用程序性能管理）将 IT 指标转换为有意义的业务指标，致力于检测和诊断复杂的应用程序性能问题，以维持预期的服务等级。&lt;/p&gt;

&lt;p&gt;通过捕获、分类、分析应用程序和基础架构生成的数据和日志，团队可以了解更新是如何影响用户的，从而深入了解问题或报错的根本原因。&lt;/p&gt;

&lt;p&gt;wiki 中介绍：&lt;/p&gt;

&lt;p&gt;密切监控两组性能指标。第一组性能指标定义了应用程序终端用户所体验的性能。性能的一个示例是峰值负载下的平均响应时间，包括加载和响应时间。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;负载是应用程序处理的事务量，例如，每秒事务数（tps）、每秒请求数、每秒页数。在没有被计算机的搜索、计算、传输等需求加载的情况下，大多数应用程序都足够快，这就是开发人员在开发过程中可能无法捕获性能问题的原因。&lt;/li&gt;
&lt;li&gt;响应时间是应用程序在此类负载下响应用户操作所需的时间。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;6-沟通与协作&#34;&gt;6. 沟通与协作&lt;/h3&gt;

&lt;p&gt;在我看来：&lt;/p&gt;

&lt;p&gt;团队中的 DevOps 作为一种实践取得成功，需要2个基本支柱：沟通和协作，才能非常有效地工作。如果没有这种感觉并理解紧密结合团队工作的重要性，那么采用 DevOps 最佳实践将非常困难。&lt;/p&gt;

&lt;p&gt;增加团队中的沟通和协作是 DevOps文化 的关键方面之一。有了这种文化，团队就会以良好的态度和动力聚集在一起，围绕信息共享建立强有力的文化规范，并通过沟通工具和应用促进沟通，使团队的所有部门能够更加紧密地协调共同的目标。&lt;/p&gt;

&lt;h2 id=&#34;为何选择devops-它的好处是什么&#34;&gt;为何选择DevOps？它的好处是什么？&lt;/h2&gt;

&lt;p&gt;要了解 DevOps 提升的价值已经其如何被公司所采用：&lt;/p&gt;

&lt;p&gt;让我们看看由 veritis 带给您的以下信息图表。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws4.sinaimg.cn/large/ad5fbf65gy1g390lc1h7jj20rs2ffapj.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;以上给出的图表清楚地阐述了 DevOps 实践的主要好处：&lt;/p&gt;

&lt;h3 id=&#34;速度&#34;&gt;速度&lt;/h3&gt;

&lt;p&gt;DevOps 促进团队的高速开发，以便您可以更快地为客户进行创新，更好地适应不断变化的市场，并在推动业务成果方面提高效率。&lt;/p&gt;

&lt;h3 id=&#34;快速交付&#34;&gt;快速交付&lt;/h3&gt;

&lt;p&gt;通过基于 CI/CD 的 DevOps 文化，缩短了应用程序发布周期，允许更快的客户反馈和有意义的创新在团队内的蓬勃发展。您可以更快地发布新功能并修复错误，更快地响应客户的需求并建立竞争优势。&lt;/p&gt;

&lt;h3 id=&#34;可靠性&#34;&gt;可靠性&lt;/h3&gt;

&lt;p&gt;DevOps 使您能够通过持续集成和持续交付等实践不断提高您的软件质量，以测试每项变更的功能和安全性。这造就了可靠和经过测试的应用程序和强大的基础设施的开发。DevOps 持续监控和记录实践可以帮助您实时了解软件的性能。&lt;/p&gt;

&lt;h3 id=&#34;文化&#34;&gt;文化&lt;/h3&gt;

&lt;p&gt;DevOps 培养了一种伟大的工作文化，在其文化模式下建立更有效的团队，强调所有权和责任等价值观。&lt;/p&gt;

&lt;h3 id=&#34;安全&#34;&gt;安全&lt;/h3&gt;

&lt;p&gt;通过采用 DevOps 模型，组织可以使用基础架即代码和策略即代码，在不牺牲安全性的情况下大规模定义和跟踪合规性。他们可以在保持控制和合规性的同时快速进步。&lt;/p&gt;

&lt;h2 id=&#34;devops-的挑战&#34;&gt;DevOps 的挑战&lt;/h2&gt;

&lt;p&gt;在团队中实施 DevOps 文化并不容易。没有标准的规则可以参考，它更像是改变个人和团队的心态的游戏。这就像要求人们离开他们的舒适区。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;“当你试图在团队中带来任何相当大的变化时，一开始可能看起来很难，但当你有足够大的意愿时，就会发生变化，并渐进达成目标。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因此，让我们看看采用 DevOps 作为文化的一些常见挑战。&lt;/p&gt;

&lt;h3 id=&#34;1-dev-vs-ops-心态&#34;&gt;1. Dev Vs Ops 心态&lt;/h3&gt;

&lt;p&gt;由于长期的开发和运维团队一直在孤立地工作，完成不同的任务。所以他们经过精心调整，以不同的方式思考和行动。开发人员试图尽快创新并做出改变，运维人员则试图保持 100％ 的服务可用性。他们的目标和优先事项是不同的，所以如果我们必须将 DevOps 作为团队中的文化实践，那么如果他们的心态还是两个孤立的部分，那么 DevOps 必将黯然失色。&lt;/p&gt;

&lt;p&gt;DevOps 的实践就是将团队整合在一起，打破 IT 组织内部的孤岛。因此，将它们整合为统一单元以实现共同目标是任何公司在采用 DevOps 实践时需要克服的第一个障碍。&lt;/p&gt;

&lt;h3 id=&#34;2-从传统基础设施转向微服务架构&#34;&gt;2. 从传统基础设施转向微服务架构&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://wx2.sinaimg.cn/large/ad5fbf65gy1g390r8z5r5j21fp0otjwk.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;多年来，这些公司一直存在遗留的基础设施，但如果他们必须快速创新，他们必须摆脱这种方法并采用更具可扩展性的微服务架构。将基础设施即代码与微服务一起使用是迈向持续创新未来的又一步。&lt;/p&gt;

&lt;p&gt;然而，将架构变为微服务架构系统存在很大的障碍。采用微服务架构需要采用最佳的 DevOps 实践以及 CI/CD 实践。这为团队带来了巨大的工作量和运维挑战，同时也增加了成本因素。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;确实，将开发与部署转变为现代的软件开发方案可能会很痛苦，但一旦采用就可以使您的团队变得更加高效与可扩展。&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-开发和运维工具集的冲突&#34;&gt;3. 开发和运维工具集的冲突&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://ws2.sinaimg.cn/large/ad5fbf65gy1g390s7jogmj20p00egjsv.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;开发团队的目标和指标完全不同，因此他们可能需要一个运维团队可能不需要的工具集。因此，必须将两个团队聚集在一起，以了解他们两者可以合作的位置，并整合对他们两者都有意义的工具，并统一他们可以监控的目标和指标。&lt;/p&gt;

&lt;p&gt;一些团队可能不愿意使用传统工具，这些工具不仅技术上较差，而且由于兼容性问题也会降低整个基础架构的速度。因此，请确保正在使用的工具与公司的产品愿景保持一致。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;无论我们在公司方面与个人方面有多么不同，我们都必须摒弃差异并作为一个整体来实现客户需求和解决客户的问题。如果我们能够在我们团队的工作文化中吸收这种理念，那么 DevOps 将成为重视过程和收益的宝贵实践。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>8分钟入门 K8S</title>
      <link>https://blog.maoxianplay.com/post/an-8-minute-introduction-to-k8s/</link>
      <pubDate>Tue, 30 Apr 2019 13:38:12 +0800</pubDate>
      
      <guid>https://blog.maoxianplay.com/post/an-8-minute-introduction-to-k8s/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;读完 &lt;a href=&#34;https://www.amazon.com/Kubernetes-Running-Dive-Future-Infrastructure/dp/1491935677&#34; target=&#34;_blank&#34;&gt;Kubernetes: Up and Running&lt;/a&gt; 后，我写下了这篇文章。旨在为那些认为文章 &lt;a href=&#34;https://blog.maoxianplay.com/posts/cant/&#34; target=&#34;_blank&#34;&gt;TL;DR&lt;/a&gt; 的人进行一些总结，这同时也是一种强迫自己检查所阅读内容的好方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;基于 Google &lt;a href=&#34;https://kubernetes.io/blog/2015/04/borg-predecessor-to-kubernetes/&#34; target=&#34;_blank&#34;&gt;Borg&lt;/a&gt; 的开源系统 K8S( Kubernetes ) 是一个非常强大的容器编排调度系统。 其整个生态系统，包括：工具，模块，附加组件等，都是使用 Golang 语言编写的，这使得 K8S 及其周边生态系统基本上是面向 API 对象、运行速度非常快的二进制文件的集合，并且这些二进制文件都有很好的文档记录，易于编写和构建应用程序。&lt;/p&gt;

&lt;p&gt;在深入了解之前，我想先介绍一下 K8S 的竞争对手：ECS 、 Nomad 和 Mesos 。ECS 是 AWS 自己的业务编排解决方案，而最近 AWS 上也引入了一个托管的 K8S 系统 &amp;ndash; EKS 。两者都提供 &lt;a href=&#34;https://aws.amazon.com/fargate/&#34; target=&#34;_blank&#34;&gt;FARGATE&lt;/a&gt; ，允许用户运行其应用并忽略其运行物理资源。&lt;/p&gt;

&lt;p&gt;K8S 作为一个开源系统，在采用量上毫无疑问是最大赢家，同时它也可以以托管形式在三个主要云提供商上提供服务。然而，它比其他系统更加复杂。K8S 可以处理几乎任何类型的容器化工作负载，但这并不意味着每个人都需要它。用户也可以选择其他解决方案，例如，单独部署在 AWS 上的互联网产品可以在生产环境很好的使用 ECS 而非 K8S。&lt;/p&gt;

&lt;p&gt;话虽如此，k8s也有其神奇之处 &amp;ndash; 它可以在任何地方部署，同时拥有一个活跃的社区和数百个核心开发人员，以及其广泛生态系统中的数千个其他开源贡献者。它快速、新颖、模块化和面向 API ，使其成为对于构建插件和服务非常友好的系统。&lt;/p&gt;

&lt;h2 id=&#34;话不多说-这里把-k8s-分为的11个部分介绍&#34;&gt;话不多说，这里把 K8S 分为的11个部分介绍&lt;/h2&gt;

&lt;h3 id=&#34;1-pods&#34;&gt;1. Pods&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Pods&lt;/strong&gt; 是 K8S 中创建或部署的最小基本单位。一个 pod 可以由多个容器组成，这些容器将形成一个部署在单个节点上的单元。一个 pod 包含一个容器之间共享的 IP。在微服务中， pod 将是执行某些后端工作或提供传入请求的微服务的单个实例。&lt;/p&gt;

&lt;h3 id=&#34;2-nodes&#34;&gt;2. Nodes&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Node&lt;/strong&gt; 就是服务器。它们是 K8S 部署其 pod 的“裸机”（也可以是虚拟机）。Nodes 为 K8S 提供可用的群集资源，以保持数据，运行作业，维护工作负载和创建网络路由。&lt;/p&gt;

&lt;h3 id=&#34;3-labels-annotations&#34;&gt;3. Labels &amp;amp; Annotations&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Labels&lt;/strong&gt; 是 K8S 及其终端用户过滤和筛选系统中类似资源的方式，也是一个资源需要“访问”或与另一个资源关联的粘合剂。例如：一个 Service 想要开放 Deployment 的端口。无论是监控，记录，日志，测试，任何k8s资源都应添加 Labels 以供进一步检查。例如： &lt;code&gt;app=worker&lt;/code&gt; ，一个给系统中所有工作 pod 的标签，稍后可以使用 &lt;code&gt;kubectl&lt;/code&gt; 工具或 k8s api 使用 &lt;code&gt;--selector&lt;/code&gt; 字段进行选择。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Annotations&lt;/strong&gt; 与 Labels 非常类似，但是它通常以字符串的形式用于存储元数据，但他不能用于标识和选择对象，通常也不会被 Kubernetes 直接使用，其主要目的是方便工具或用户的阅读和查找等。&lt;/p&gt;

&lt;h3 id=&#34;4-服务发现&#34;&gt;4. 服务发现&lt;/h3&gt;

&lt;p&gt;作为编排调度器，控制不同工作负载的资源，K8S 管理 pods 、jobs 和其他任何需要网络通信的物理资源。 K8S 使用 &lt;a href=&#34;https://kubernetes.io/docs/concepts/overview/components/#etcd&#34; target=&#34;_blank&#34;&gt;etcd&lt;/a&gt; 管理这些。 etcd 是 K8S 的“内部”数据库， Master 节点使用它来知道一切资源都在哪里。K8S 还为您的服务提供了实时的 “服务发现” - 所有 Pod 都使用的自定义 DNS 服务（CoreDNS），您可以通过解析其他服务的名称来获取其 IP 地址和端口。它不需要任何设置，在 K8S 集群中“开箱即用”。&lt;/p&gt;

&lt;h3 id=&#34;5-replicasets&#34;&gt;5. ReplicaSets&lt;/h3&gt;

&lt;p&gt;虽然 pod 运行任务，但通常单个实例是不够的。出于对冗余和负载处理的考虑，需要进行复制容器，即“弹性缩放”。K8S 使用 &lt;strong&gt;ReplicaSet&lt;/strong&gt; 来实现伸缩扩展。根据副本的数量来表示系统的期望状态，并且在任何给定时刻保持系统的当前状态。&lt;/p&gt;

&lt;p&gt;这也是配置自动扩展的地方，在系统负载高时创建新的副本，以及在不再需要这些资源来支持运行工作负载时减少扩展。简单的讲就是：少则增加，多增删除。&lt;/p&gt;

&lt;h3 id=&#34;6-daemonsets&#34;&gt;6. DaemonSets&lt;/h3&gt;

&lt;p&gt;有时，某些应用程序在每个节点上只需要一个实例。最好的例子就是像 &lt;a href=&#34;https://www.elastic.co/products/beats/filebeat&#34; target=&#34;_blank&#34;&gt;FileBeat&lt;/a&gt; 这样的日志采集组件。为了让 agent 从节点上收集日志，它需要运行在所有节点上，但只需要一个实例即可。为了创建满足上面需求的的工作负载，K8S 使用 &lt;strong&gt;DaemonSets&lt;/strong&gt; 来完成这个工作。&lt;/p&gt;

&lt;h3 id=&#34;7-statefulsets&#34;&gt;7. StatefulSets&lt;/h3&gt;

&lt;p&gt;虽然大多数微服务都是无状态的应用程序，但是还是有一部分并不是。有状态的工作负载需要由某种可靠的磁盘卷来支持。虽然应用程序容器本身可以是不变的，并且可以用更新的版本或更健康的实例来替换它们，但是即使使用其他副本也是需要持久化的数据。为此，&lt;strong&gt;StatefulSets&lt;/strong&gt; 允许部署整个生命周期内需要运行在同一节点的应用程序。它还保留了它的 “名称” ; 容器内的 &lt;code&gt;hostname&lt;/code&gt; 和整个集群中服务发现的名称。一个包含3个 ZooKeeper 的 StatefulSet 可以命名为 &lt;code&gt;zk-1&lt;/code&gt; ，&lt;code&gt;zk-2&lt;/code&gt; 和 &lt;code&gt;zk-3&lt;/code&gt; 还可以扩展为包含其他成员，如 &lt;code&gt;zk-4&lt;/code&gt; ， &lt;code&gt;zk-5&lt;/code&gt; 等&amp;hellip; StatefulSets 还需要管理 PVC 。&lt;/p&gt;

&lt;h3 id=&#34;8-jobs&#34;&gt;8. Jobs&lt;/h3&gt;

&lt;p&gt;K8S 核心团队考察了绝大多数需要使用编排系统的应用程序。虽然大多数应用程序需要持续的正常运行时间来处理服务请求，例如 Web 服务，但有时也需要运行批量任务并在任务完成后进行清理。如果您愿意，可以使用小型无服务器环境。而在 K8S 中实现这一功能，可以使用 &lt;strong&gt;Job&lt;/strong&gt; 资源。Jobs 正是听起来的那样，一个工作负载容器来完成特定的工作，并在成功后被销毁。一个很好的例子是设置一组 worker ，从要处理和存储的队列中读取任务。一旦队列为空，直到下一批准备好进行处理，都不再需要启动 worker。&lt;/p&gt;

&lt;h3 id=&#34;9-configmaps-secrets&#34;&gt;9. ConfigMaps &amp;amp; Secrets&lt;/h3&gt;

&lt;p&gt;如果您还不熟悉 &lt;a href=&#34;https://12factor.net/&#34; target=&#34;_blank&#34;&gt;Twelve-Factor App manifest&lt;/a&gt; 《&lt;a href=&#34;../12-factor&#34;&gt;十二要素应用&lt;/a&gt;》 ，可以点击链接了解一下。现代应用程序的一个关键概念是无环境，可通过注入的环境变量进行配置。应用程序应完全与其所在位置无关。&lt;strong&gt;ConfigMaps&lt;/strong&gt; 在 K8S 中实现这一重要概念。其本质上是环境变量的 key-value 列表，这些变量被传递给正在运行的工作负载以确定不同的 runtime 行为。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Secrets&lt;/strong&gt; 与 &lt;strong&gt;ConfigMaps&lt;/strong&gt; 类似，通过加密的方式防止密钥、密码、证书等敏感信息泄漏。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;我个人认为在任何系统上使用密码的最佳选择是 Hashicorp 的 Vault 。请务必阅读我去年写的关于它的&lt;a href=&#34;https://medium.com/prodopsio/security-for-dummies-protecting-application-secrets-made-easy-5ef3f8b748f7&#34; target=&#34;_blank&#34;&gt;文章&lt;/a&gt;，关于 Vault 可以为你的产品提供的功能，以及我的一位同事写的另一篇更具技术性的[文章](&lt;a href=&#34;https://medium.com/prodopsio/taking-your-hashicorp-vault-to-the-next-level-8549e7988b24）。&#34; target=&#34;_blank&#34;&gt;https://medium.com/prodopsio/taking-your-hashicorp-vault-to-the-next-level-8549e7988b24）。&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;10-deployments&#34;&gt;10. Deployments&lt;/h3&gt;

&lt;p&gt;为了使新版本快速替换原有的应用程序，我们希望将构建、测试和发布在一块来实现 &lt;a href=&#34;https://www.ibm.com/developerworks/community/blogs/beingagile/entry/short_feedback_loops_everywhere?lang=en&#34; target=&#34;_blank&#34;&gt;short feedback loops&lt;/a&gt; 。K8S 使用 Deployments 来不断部署新软件，Deployments 是一组用来描述特定运行工作负载的元数据。例如：发布新版本，bug 修复，甚至是回滚（这是k8s的另一个内部选项）。&lt;/p&gt;

&lt;p&gt;在 K8S 中部署软件有两个主要&lt;strong&gt;策略&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Replacement&lt;/strong&gt;：将使用新副本替换您的整个工作负载，整个过程需要强制停机。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;RollingUpdate&lt;/strong&gt;：k8s通过两种特定配置来实现使用新的 Pods 实例滚动更新：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;MaxAvailable&lt;/code&gt; ： 该设置表示在部署新版本时可用的工作负载的百分比（或确切数量），100％表示“我有2个容器，保持2个存活并在整个部署期间正常提供服务”。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MaxSurge&lt;/code&gt; ： 该设置表示升级期间总 Pod 数最多可以超出期望的百分比（或数量），100％表示“我有 X 个容器，再部署 X 个容器，然后开始推出旧容器”。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;11-storage&#34;&gt;11. Storage&lt;/h3&gt;

&lt;p&gt;K8S 在存储上添加了一层抽象，工作负载可以为不同的任务请求特定的存储，甚至可以管理持续的时间可以超过某个pod的生命周期。为了简短起见，我想向您介绍我最近发布的关于k8s存储的&lt;a href=&#34;https://medium.com/prodopsio/k8s-will-not-solve-your-storage-problems-5bda2e6180b5&#34; target=&#34;_blank&#34;&gt;文章&lt;/a&gt;，特别是为什么它不能完全解决数据库部署等数据持久性要求。&lt;/p&gt;

&lt;h2 id=&#34;概念性理解&#34;&gt;概念性理解&lt;/h2&gt;

&lt;p&gt;K8S 是根据一些指导方向设计和开发的，考虑到社区的性质，每个特征、概念和想法都被内置于系统中。此外，终端用户会以某种方式使用该系统，作为一个开源和免费的系统，不属于任何人，你可以用它做任何你想要做的事。&lt;/p&gt;

&lt;p&gt;面向 API ：系统中的每个部分都以一种可通过记录良好且可操作的 API 进行交互的方式进行构建。核心开发人员确保作为终端用户的您可以进行更改，查询和更新，用来提供更好的用户体验。&lt;/p&gt;

&lt;p&gt;工具友好 ： 作为上面一点的衍生，K8S 是热衷于在其 API 周围创建工具的。它将自身做为一个原始平台，以可定制的方式构建，以供其他人使用，并进一步开发用于不同的工具。有些已经变得非常有名并被广泛使用，如 Spinnaker ，Istio 和许多其他功工具。&lt;/p&gt;

&lt;p&gt;声明性状态 ： 鼓励用户使用具有声明性描述的系统而不是命令式描述。这意味着系统的状态和组件最好被描述为在某种版本控制（如 git ）中管理的代码，而不会因为某一处手动更改也对整体有影响。这样，k8s更容易&lt;a href=&#34;https://en.wikipedia.org/wiki/Disaster_recovery&#34; target=&#34;_blank&#34;&gt;灾难恢复&lt;/a&gt; ，易于在团队之间分享和传递。&lt;/p&gt;

&lt;h2 id=&#34;最后&#34;&gt;最后&lt;/h2&gt;

&lt;p&gt;本文试图将重点放在 K8S 的介绍和主要概念上，当然，K8S 还有其他非常重要的领域，比如物理系统构建模块，如 &lt;code&gt;kubelet&lt;/code&gt;， &lt;code&gt;kube-proxy&lt;/code&gt; ， &lt;code&gt;api-server&lt;/code&gt; 和终端操作工具：&lt;code&gt;kubectl&lt;/code&gt;。我将在下一篇文章中讨论以及介绍这些很酷的功能。&lt;/p&gt;

&lt;p&gt;原文地址： &lt;a href=&#34;https://medium.com/prodopsio/an-8-minute-introduction-to-k8s-94fda1fa5184&#34; target=&#34;_blank&#34;&gt;https://medium.com/prodopsio/an-8-minute-introduction-to-k8s-94fda1fa5184&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>困难的 Kubernetes</title>
      <link>https://blog.maoxianplay.com/post/kubernetes-is-har/</link>
      <pubDate>Wed, 24 Apr 2019 10:18:46 +0800</pubDate>
      
      <guid>https://blog.maoxianplay.com/post/kubernetes-is-har/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;虽然 Kubernetes 赢得了容器之站，但是其仍然很难使用并且时长引起事故。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我想我应该给这篇文章做一点序言。 &lt;a href=&#34;https://kubernetes.io/&#34; target=&#34;_blank&#34;&gt;kubernetes&lt;/a&gt; 为许多应用程序提供新的 runtime ，如果使用得当，它可以成为一个强大的工具，并且可以将您冲复杂的开发生命周期中解放出来。然而在过去的几年里，我看到很多人和公司都会搭建他们的 Kubernetes ，但常常只是处于测试阶段，从未进入到生产。&lt;/p&gt;

&lt;h2 id=&#34;kubernetes-是如何运作的&#34;&gt;Kubernetes 是如何运作的？&lt;/h2&gt;

&lt;p&gt;粗略的讲， Kubernetes 或者 K8S 看起来十分简单。您运行的 Kubernetes 节点至少被分为两类：Master 和 Workers。Master 节点通常不运行任何真实的工作负载，那是 Workers 节点的工作。&lt;/p&gt;

&lt;p&gt;Kubernetes 的 Master 节点包含一个名叫 API server 的组件，其提供的 API 可以通过 &lt;code&gt;kubectl&lt;/code&gt; 调用。此外还包括一个 scheduler ，负责调度容器，决定容器运行在哪个节点。最后一个组件是 controller-manager ，它实际上是一组多个控制器，负责处理节点中断、复制、加入 services 和 pods ，并且处理授权相关内容。所有的数据都存储在 etcd 中，这是一个可信赖的分布式键值存储服务（包含一些非常酷的功能）。总而言之，Master 节点负责管理集群，这里没什么特别大的惊喜。&lt;/p&gt;

&lt;p&gt;另一方面， 真实的工作负载运行在 Worker 节点上。为此，它还包括许多组件。首先，Worker 节点上会运行 &lt;strong&gt;&lt;em&gt;kubelet&lt;/em&gt;&lt;/strong&gt; ，它是与该节点上的容器一起运行的 API ，负责与管控组件沟通，并按照管控组件指示管理 Worker 节点。另一个组件就是 &lt;strong&gt;&lt;em&gt;kube-proxy&lt;/em&gt;&lt;/strong&gt; ，其负责转发网络连接，根据您的配置运行容器。可能还有其他东西，如 &lt;strong&gt;&lt;em&gt;kube-dns&lt;/em&gt;&lt;/strong&gt; 或 &lt;strong&gt;&lt;em&gt;gVisor&lt;/em&gt;&lt;/strong&gt;。您还需要集成某种 &lt;strong&gt;&lt;em&gt;overlay network&lt;/em&gt;&lt;/strong&gt; 或底层网络设置，以便 Kubernetes 可以管理您的 pod 之间的网络。&lt;/p&gt;

&lt;p&gt;如果您想要一个更完整的概述，建议去看 Kelsey Hightowers 的 &lt;a href=&#34;https://github.com/kelseyhightower/kubernetes-the-hard-way&#34; target=&#34;_blank&#34;&gt;Kubernetes  -  The Hard Way&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;生产就绪的-kubernetes&#34;&gt;生产就绪的 Kubernetes&lt;/h2&gt;

&lt;p&gt;到目前为止，这听起来并不太糟糕。只是安装几个程序、配置、证书等。不要误会我的意思，这仍然是一个学习曲线，但这也不是系统管理员不能处理的问题。&lt;/p&gt;

&lt;p&gt;然而，简单地手动安装 Kubernetes 并不代表其已经完全准备就绪，所以让我们谈谈让这个东西运行起来所需的步骤。&lt;/p&gt;

&lt;p&gt;首先，&lt;strong&gt;安装&lt;/strong&gt;。如果您想要某种自动安装，无论是使用 Ansible ， Terraform 还是其他工具。&lt;a href=&#34;https://github.com/kubernetes/kops&#34; target=&#34;_blank&#34;&gt;kops&lt;/a&gt; 可以帮助您解决这个问题，但是使用 kops 意味着您将不知道它是如何设置的，并且当您以后想要调试某些东西时可能会引起一些其他问题。应对此自动化进行测试，并定期进行检查。&lt;/p&gt;

&lt;p&gt;其次，您需要&lt;strong&gt;监控&lt;/strong&gt;您的 Kubernetes 安装。所以您需要 &lt;a href=&#34;https://prometheus.io/&#34; target=&#34;_blank&#34;&gt;Prometheus&lt;/a&gt; 、 &lt;a href=&#34;https://grafana.com/&#34; target=&#34;_blank&#34;&gt;Grafana&lt;/a&gt; 等工具。您是在 Kubernetes 里面运行它吗？ 如果您的 Kubernetes 有问题，那么您的监控是否会也会挂掉？ 或者您单独运行它？ 如果是，那么您在哪里运行它？&lt;/p&gt;

&lt;p&gt;另外值得注意的是&lt;strong&gt;备份&lt;/strong&gt;。如果您的 Master 崩溃，数据无法恢复并且您需要重新配置系统上的所有 pod ，您会怎么做？您是否测试了再次运行 CI 系统中所有作业所需的时间？您有灾难恢复计划吗？&lt;/p&gt;

&lt;p&gt;现在，既然我们在谈论 CI 系统，那么您需要为您的镜像运行 Docker 镜像仓库。当然，您可以再次在 Kubernetes 上做，但如果 Kubernetes 崩溃&amp;hellip;&amp;hellip;您知道这个后果。当然，CI 系统与运行版本控制系统都有这个问题。理想情况下，这些系统是与生产环境隔离的，以便在系统出现问题时，至少可以访问 git ，来进行重新部署等操作。&lt;/p&gt;

&lt;h2 id=&#34;数据存储&#34;&gt;数据存储&lt;/h2&gt;

&lt;p&gt;最后，我们来谈谈最重要的部分：存储。Kubernetes 本身并不提供存储解决方案。当然，您可以将存储挂载到主机安装目录，但这既不推荐也不简单。&lt;/p&gt;

&lt;p&gt;基本上需要在 Kubernetes 下使用某种存储。例如，&lt;a href=&#34;https://rook.io/&#34; target=&#34;_blank&#34;&gt;rook&lt;/a&gt; 使得运行 &lt;a href=&#34;https://ceph.com/&#34; target=&#34;_blank&#34;&gt;Ceph&lt;/a&gt; 作为底层块存储需求的变得相对简单，但我对 Ceph 的体验是它还有有很多地方需要调整，所以您绝不是只需点击下一步就能走出困境。&lt;/p&gt;

&lt;h2 id=&#34;调试&#34;&gt;调试&lt;/h2&gt;

&lt;p&gt;在与开发人员谈论 Kubernetes 时，一种常见的回答经常出现：在使用 Kubernetes 时，人们常常在调试应用程序时遇到问题。即使是一个例如容器未能启动的简单问题，也会引起混乱。&lt;/p&gt;

&lt;p&gt;当然，这是一个教育问题。在过去的几十年中，开发人员已经学会了调试的“经典”步骤：在 &lt;code&gt;/vat/log/&lt;/code&gt; 中查看日志等。但是对于容器，我们甚至不知道容器运行在哪个服务器上，因此它呈现出了一种范式转换。&lt;/p&gt;

&lt;h2 id=&#34;问题-复杂&#34;&gt;问题：复杂&lt;/h2&gt;

&lt;p&gt;您可能已经注意到我正在跳过共有云提供商给您的东西，即使它不是一个完整的托管 Kubernetes。当然，如果您使用托管的 Kubernetes 解决方案，这很好，除了调试之外，您不需要处理上面这些问题。&lt;/p&gt;

&lt;p&gt;Kubernetes 拥有许多可以移动组件，但 Kubernetes 本身也并不能提供完整的解决方案。例如，&lt;a href=&#34;https://www.openshift.com/&#34; target=&#34;_blank&#34;&gt;RedHat OpenShift&lt;/a&gt; 可以，但它需要花钱，并且仍然需要添加自己的东西。&lt;/p&gt;

&lt;p&gt;现在Kubernetes正处于 &lt;a href=&#34;https://www.gartner.com/en/research/methodologies/gartner-hype-cycle&#34; target=&#34;_blank&#34;&gt;Gartner hype cycle&lt;/a&gt; 的顶峰，每个人都想要它，但很少有人真正理解它。在接下来的几年里，不少公司必须意识到 Kubernetes 并不是银弹，而如何正确有效地使用它才是关键。&lt;/p&gt;

&lt;p&gt;我认为，如果您有能力将 Ops 团队专门用于为开发人员来维护底层平台，那么运行自己的 Kubernetes 是值得的。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;本文作者：&lt;a href=&#34;https://pasztor.at/&#34; target=&#34;_blank&#34;&gt;Janos Pasztor&lt;/a&gt;  2018-12-04&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;原文地址：&lt;a href=&#34;https://pasztor.at/blog/kubernetes-is-hard&#34; target=&#34;_blank&#34;&gt;https://pasztor.at/blog/kubernetes-is-hard&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>什么的容器？Docker 工作原理及容器化简易指南</title>
      <link>https://blog.maoxianplay.com/post/what-are-containers-a-simple-guide-to-containerization-and-how-docker-works/</link>
      <pubDate>Sat, 20 Apr 2019 19:54:50 +0800</pubDate>
      
      <guid>https://blog.maoxianplay.com/post/what-are-containers-a-simple-guide-to-containerization-and-how-docker-works/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Docker 非常棒！&lt;/strong&gt; 它使软件开发者无需担心配置和依赖性，在任何地方打包，发送和运行他们的应用程序。而在与 kubernetes 相结合后，它使应用集群部署和管理变得更方便。这使得 Docker 深受软件开发者的喜爱，越来越多的开发者开始使用 Docker。&lt;/p&gt;

&lt;p&gt;那么 Docker 到底是什么？&lt;/p&gt;

&lt;p&gt;它是构建、测试、部署和发布&lt;strong&gt;容器化&lt;/strong&gt;应用的&lt;strong&gt;平台&lt;/strong&gt;。称其为平台是因为 Docker 其实是一套用于管理与容器相关的所有事物的工具。作为 Docker 的核心，接下来我们将深入探讨容器。&lt;/p&gt;

&lt;h2 id=&#34;什么是容器&#34;&gt;什么是容器？&lt;/h2&gt;

&lt;p&gt;容器提供了在计算机上的隔离环境中安装和运行应用程序的方法。在容器内运行的应用程序仅可使用于为该容器分配的资源，例如：CPU，内存，磁盘，进程空间，用户，网络，卷等。在使用有限的容器资源的同时，并不与其他容器冲突。您可以将容器视为简易计算机上运行应用程序的隔离沙箱。&lt;/p&gt;

&lt;p&gt;这个概念听起来很熟悉，有些类似于虚拟机。但它们有一个关键的区别：容器使用的一种非常不同的，轻量的技术来实现资源隔离。容器利用了底层 Linux 内核的功能，而不是虚拟机采用的  &lt;a href=&#34;https://en.wikipedia.org/wiki/Hypervisor&#34; target=&#34;_blank&#34;&gt;hypervisor&lt;/a&gt; 的方法。换句话说，容器调用 Linux 命令来分配和隔离出一组资源，然后在此空间中运行您的应用程序。我们快速来看下两个这样的功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;namespaces&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;简单的讲就是，&lt;a href=&#34;http://man7.org/linux/man-pages/man7/namespaces.7.html&#34; target=&#34;_blank&#34;&gt;Linux namespace&lt;/a&gt; 允许用户在独立进程之间隔离 CPU 等资源。进程的访问权限及可见性仅限于其所在的 namespaces 。因此，用户无需担心在一个 namespace 内运行的进程与在另一个 namespace 内运行的进程冲突。甚至可以同一台机器上的不同容器中运行具有相同 PID 的进程。同样的，两个不同容器中的应用程序可以使用相同的端口。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;cgroups&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://man7.org/linux/man-pages/man7/cgroups.7.html&#34; target=&#34;_blank&#34;&gt;cgroups&lt;/a&gt; 允许对可用资源设置限制和约束。例如，您可以在一台拥有 16G 内存的计算机上创建一个 namespace ，限制其内部进程可用内存为 1GB。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;到这，您可能已经猜到 Docker 的工作原理了。当您请求 Docker 运行容器时，Docker 会在您的计算机上设置一个资源隔离的环境。然后 Docker 会将打包的应用程序和关联的文件复制到 namespace 内的文件系统中，此时环境的配置就完成了。之后 Docker 会执行您指定的命令运行应用程序。&lt;/p&gt;

&lt;p&gt;简而言之，Docker 通过使用 Linux namespace 和 cgroup（以及其他一些命令）来协调配置容器，将应用程序文件复制到为容器分配的磁盘，然后运行启动命令。Docker 还附带了许多其他用于管理容器的工具，例如：列出正在运行的容器，停止容器，发布容器镜像等许多其他工具。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://wx4.sinaimg.cn/large/ad5fbf65gy1g2a8h1rc6lj211a0rcjsu.jpg&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;与虚拟机相比，容器更轻量且速度更快，因为它利用了 Linux 底层操作系统在隔离的环境中运行。虚拟机的 hypervisor 创建了一个非常牢固的边界，以防止应用程序突破它，而&lt;a href=&#34;https://sysdig.com/blog/container-isolation-gone-wrong/&#34; target=&#34;_blank&#34;&gt;容器的边界不那么强大&lt;/a&gt;。另一个区别是，由于 namespace 和 cgroups 功能仅在 Linux 上可用，因此容器无法在其他操作系统上运行。此时您可能想知道 Docker 如何在 macOS 或 Windows 上运行？ Docker 实际上使用了一个技巧，并在非 Linux 操作系统上安装 Linux 虚拟机，然后在虚拟机内运行容器。&lt;/p&gt;

&lt;p&gt;让我们利用目前为止学到的所有内容，从头开始创建和运行 Docker 容器。如果你还没有将 Docker 安装在你的机器上，可以参考&lt;a href=&#34;https://docs.docker.com/install/&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt;安装 Docker 。在这个示例中，我们将创建一个 Docker 容器，下载一个用 C语言 写的 Web 服务，编译并运行它，然后使用浏览器访问这个 Web 服务。&lt;/p&gt;

&lt;p&gt;我们将从所有 Docker 项目开始的地方：创建一个 &lt;code&gt;Dockerfile&lt;/code&gt; 开始。此文件描述了如何创建用于运行容器的 docker 镜像。既然我们还没有聊到镜像，那么让我们看一下&lt;a href=&#34;https://docs.docker.com/get-started/#images-and-containers&#34; target=&#34;_blank&#34;&gt;镜像的官方定义&lt;/a&gt;：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;镜像是一个可执行包，其包含运行应用程序所需的代码、运行时、库、环境变量和配置文件，容器是镜像的运行时实例。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单的讲，当你要求 Docker 运行一个容器时，你必须给它一个包含如下内容的镜像：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;包含应用程序及其所有依赖的&lt;strong&gt;文件系统快照&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;容器启动时的运行命令。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在 Docker 的世界，使用别人的镜像作为基础镜像来创建自己的镜像是十分普遍的。例如，官方 reds Docker 镜像就是基于 Debian 文件系统快照（&lt;a href=&#34;http://www.ethernetresearch.com/geekzone/building-linux-rootfs-from-scratch/&#34; target=&#34;_blank&#34;&gt;rootfs tarball&lt;/a&gt;），并安装在其上配置 Redis。&lt;/p&gt;

&lt;p&gt;在我们的示例中，我们选择 &lt;a href=&#34;https://hub.docker.com/_/alpine&#34; target=&#34;_blank&#34;&gt;Alpine Linux&lt;/a&gt; 为基础镜像。当您在 Docker 中看到 “alpine” 时，它通常意味着一个精简的基本镜像。 Alpine Linux 镜像大小只有约为5 MB！&lt;/p&gt;

&lt;p&gt;在您的计算机创建一个新目录（例如 &lt;code&gt;dockerprj&lt;/code&gt; ），然后新建一个 &lt;code&gt;Dockerfile&lt;/code&gt; 文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;umermansoor:dockerprj$ touch Dockerfile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将如下内容粘贴到 &lt;code&gt;Dockerfile&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-docker&#34;&gt;# Use Alpine Linux rootfs tarball to base our image on
FROM alpine:3.9 

# Set the working directory to be &#39;/home&#39;
WORKDIR &#39;/home&#39;

# Setup our application on container&#39;s file system
RUN wget http://www.cs.cmu.edu/afs/cs/academic/class/15213-s00/www/class28/tiny.c \
  &amp;amp;&amp;amp; apk add build-base \
  &amp;amp;&amp;amp; gcc tiny.c -o tiny \
  &amp;amp;&amp;amp; echo &#39;Hello World&#39; &amp;gt;&amp;gt; index.html

# Start the web server. This is container&#39;s entry point
CMD [&amp;quot;./tiny&amp;quot;, &amp;quot;8082&amp;quot;]

# Expose port 8082
EXPOSE 8082 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个 &lt;code&gt;Dockerfile&lt;/code&gt; 包含创建镜像的内容说明。我们创建镜像基于 Alpine Linux（&lt;a href=&#34;http://www.ethernetresearch.com/geekzone/building-linux-rootfs-from-scratch/&#34; target=&#34;_blank&#34;&gt;rootfs tarball&lt;/a&gt;），并将工作目录设置为 &lt;code&gt;/home&lt;/code&gt; 。接下来下载，编译并创建了一个用C编写的简单 Web 服务器的可执行文件，然后指定在运行容器时要执行的命令，并将容器端口8082暴露给主机。&lt;/p&gt;

&lt;p&gt;现在，我们就可以构建镜像了。在 &lt;code&gt;Dockerfile&lt;/code&gt; 的同级目录运行 &lt;code&gt;docker build&lt;/code&gt; 命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;umermansoor:dockerprj$ docker build -t codeahoydocker .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果这个命令成功了，您将看到：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Successfully tagged codeahoydocker:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时我们的镜像就创建成功了，该镜像主要包括：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;文件系统快照（Alpine Linux 和 我们安装的 Web 服务）&lt;/li&gt;
&lt;li&gt;启动命令（&lt;code&gt;./tiny 8092&lt;/code&gt;）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;http://wx4.sinaimg.cn/large/ad5fbf65gy1g2aakgpe16j20zo0bqjt5.jpg&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;既然成功构建了镜像，那么我们可以使用如下命令运行容器。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;umermansoor:dockerprj$ docker run -p 8082:8082 codeahoydocker:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;让我们了解下这里发生了什么。&lt;/p&gt;

&lt;p&gt;通过 &lt;code&gt;docker run&lt;/code&gt; 命令，我们请求 Docker 基于 &lt;code&gt;codeahoydocker:latest&lt;/code&gt; 镜像创建和启动一个容器。&lt;code&gt;-p 8082:8082&lt;/code&gt; 将本地的8082端口映射到容器的8082端口（容器内的 Web 服务器正在监听8082端口上的连接）。打开你的浏览器并访问 localhost:8082/index.html 。你将可以看到 &lt;strong&gt;&lt;em&gt;Hello World&lt;/em&gt;&lt;/strong&gt; 信息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://wx4.sinaimg.cn/large/ad5fbf65gy1g2aazadeamj20yo0rcq5e.jpg&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最后我想补充一点，虽然 Docker 非常棒，而且对于大多数项目来说它是一个不错的选择，但我们并非处处都要使用它。在我的工作中，Docker 与 Kubernetes 结合使用，可以非常轻松地部署和管理后端微服务，我们不必为每个服务配置新的运行环境。另一方面，对于性能密集型应用程序，Docker 可能不是最佳选择。我经手的其中一个项目必须处理来自移动游戏客户端的 TCP 长连接（每台机器1000个），这时 Docker 网络出现了很多问题，导致无法将它用于该项目。&lt;/p&gt;

&lt;p&gt;希望上面这些内容有用。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这篇文章由 &lt;a href=&#34;https://www.linkedin.com/in/umansoor&#34; target=&#34;_blank&#34;&gt;Umer Mansoor&lt;/a&gt; 撰写，可以在 &lt;a href=&#34;https://www.facebook.com/codeahoy&#34; target=&#34;_blank&#34;&gt;Facebook&lt;/a&gt; 或 &lt;a href=&#34;https://twitter.com/codeahoy&#34; target=&#34;_blank&#34;&gt;Twitter&lt;/a&gt; 上关注并留下评论。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;原文地址： &lt;a href=&#34;https://codeahoy.com/2019/04/12/what-are-containers-a-simple-guide-to-containerization-and-how-docker-works/&#34; target=&#34;_blank&#34;&gt;https://codeahoy.com/2019/04/12/what-are-containers-a-simple-guide-to-containerization-and-how-docker-works/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kustomize: 无需模板定制你的 kubernetes 配置</title>
      <link>https://blog.maoxianplay.com/post/introducing-kustomize-template-free-configuration-customization-for-kubernetes/</link>
      <pubDate>Mon, 15 Apr 2019 17:23:21 +0800</pubDate>
      
      <guid>https://blog.maoxianplay.com/post/introducing-kustomize-template-free-configuration-customization-for-kubernetes/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;作者：Jeff Regan (Google), Phil Wittrock (Google) 2018-05-29&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果你在运行 kubernetes 集群，你可能会拷贝一些包含 kubernetes API 对象的 YAML 文件，并且根据你的需求来修改这些文件，通过这些 YAML 文件来定义你的 kubernetes 配置。&lt;/p&gt;

&lt;p&gt;但是这种方法存在很难找到配置的源头并对其进行改进。今天 Google 宣布推出 &lt;strong&gt;Kustomize&lt;/strong&gt; ，一个作为 &lt;a href=&#34;https://github.com/kubernetes/community/tree/master/sig-cli&#34; target=&#34;_blank&#34;&gt;SIG-CLI&lt;/a&gt; 子项目的命令行工具。这个工具提供了一个全新的、纯粹的声明式的方法来定制 kubernetes 配置，遵循并利用我们熟悉且精心设计的 Kubernetes API。&lt;/p&gt;

&lt;p&gt;有这样一个常见的场景，在互联网上可以看到别人的 CMS（content management system，内容管理系统）的 kubernetes 配置，这个配置是一组包括 Kubernetes API 对象的 YAML 描述文件。然后，在您自己公司的某个角落，您找到一个你非常了解的数据库，希望用它来该 CMS 的数据。&lt;/p&gt;

&lt;p&gt;你希望同时使用它们，此外，你希望自定义配置文件以便你的资源实例在集群中显示，并通过添加一个标签来区分在同一集群中做同样事情的其他资源。同时也希望为其配置适当的 CPU 、内存和副本数。&lt;/p&gt;

&lt;p&gt;此外，你还想要配置整个配置的多种变化：一个专门用于测试和实验的小服务实例（就计算资源而言），或更大的用于对外提供服务的生产级别的服务实例。同时，其他的团队也希望拥有他们自己的服务实例。&lt;/p&gt;

&lt;h2 id=&#34;定制就是复用&#34;&gt;定制就是复用&lt;/h2&gt;

&lt;p&gt;kubernetes 的配置并不是代码（是使用 YAML 描述的 API 对象，严格来说应该是数据），但是配置的生命周期与代码的生命周期有许多相似之处。&lt;/p&gt;

&lt;p&gt;你需要在版本控制中保留配置。所有者的配置不必与使用者的配置相同。配置可以作为整体的一部分。而用户希望为在不同的情况下复用这些配置。&lt;/p&gt;

&lt;p&gt;与代码复用相同，一种复用配置的方法是简单的全部拷贝并进行自定义。像代码一样，切断与源代码的联系使得从改进变的十分困难。许多团队和环境都使用这种方法，每个团队和环境都拥有自己的配置，这使得简单的升级变得十分棘手。&lt;/p&gt;

&lt;p&gt;另一种复用方法是将源代码抽象为参数化模板。使用一个通过执行脚本来替换所需参数的模板处理工具生成配置，通过为同一模板设置不同的值来达到复用的目的。而这种方式面临的问题是模板和参数文件并不在 kubernetes API 资源的规范中，这种方式必定是一种包装了 kubernetes API 的新东西、新语言。虽然这种方式很强大，但是也带来了学习成本和安装工具的成本。不同的团队需要不同的更改，因此几乎所有可以包含在 YAML 文件中的规范都会需要抽象成参数。&lt;/p&gt;

&lt;h2 id=&#34;自定义配置的新选择&#34;&gt;自定义配置的新选择&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;kustomize&lt;/strong&gt; 中工具的声明与规范是由名为 &lt;code&gt;kustomization.yaml&lt;/code&gt; 的文件定义。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;kustomize&lt;/strong&gt; 将会读取声明文件和 Kubernetes API 资源文件，将其组合然后将完整的资源进行标准化的输出。输出的文本可以被其他工具进一步处理，或者直接通过 &lt;strong&gt;kubectl&lt;/strong&gt; 应用于集群。&lt;/p&gt;

&lt;p&gt;例如，如果 &lt;code&gt;kustomization.yaml&lt;/code&gt; 文件包括：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;commonLabels:
  app: hello
resources:
- deployment.yaml
- configMap.yaml
- service.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;确保这三个文件与 &lt;code&gt;kustomization.yaml&lt;/code&gt; 位于同一目录下，然后运行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kustomize build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将创建包含三个资源的 YAML 流，其中 &lt;code&gt;app: hello&lt;/code&gt; 为每个资源共同的标签。&lt;/p&gt;

&lt;p&gt;同样的，你可以使用 &lt;strong&gt;&lt;em&gt;commonAnnotations&lt;/em&gt;&lt;/strong&gt; 字段给所有资源添加注释， &lt;strong&gt;&lt;em&gt;namePrefix&lt;/em&gt;&lt;/strong&gt; 字段为所有的资源添加共同的前缀名。这些琐碎而有常见的定制只是一个开始。&lt;/p&gt;

&lt;p&gt;一个更常见的例子是，你需要为一组相同资源设置不同的参数。例如：开发、演示和生产的参数。&lt;/p&gt;

&lt;p&gt;为此，&lt;strong&gt;Kustomize&lt;/strong&gt; 允许用户以一个应用描述文件 （YAML 文件）为基础（Base YAML），然后通过 Overlay 的方式生成最终部署应用所需的描述文件。两者都是由 kustomization 文件表示。基础（Base）声明了共享的内容（资源和常见的资源配置），Overlay 则声明了差异。&lt;/p&gt;

&lt;p&gt;这里是一个目录树，用于管理集群应用程序的 &lt;strong&gt;&lt;em&gt;演示&lt;/em&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;em&gt;生产&lt;/em&gt;&lt;/strong&gt; 配置参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;someapp/
├── base/
│   ├── kustomization.yaml
│   ├── deployment.yaml
│   ├── configMap.yaml
│   └── service.yaml
└── overlays/
    ├── production/
    │   └── kustomization.yaml
    │   ├── replica_count.yaml
    └── staging/
        ├── kustomization.yaml
        └── cpu_count.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;someapp/base/kustomization.yaml&lt;/code&gt; 文件指定了公共资源和常见自定义配置（例如，它们一些相同的标签，名称前缀和注释）。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;someapp/overlays/production/kustomization.yaml&lt;/code&gt; 文件的内容可能是：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;commonLabels:
  env: production
bases:
- ../../base
patches:
- replica_count.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个 kustomization 指定了一个 &lt;strong&gt;&lt;em&gt;patch&lt;/em&gt;&lt;/strong&gt; 文件 &lt;code&gt;replica_count.yaml&lt;/code&gt; ，其内容可能是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  name: the-deployment
spec:
  replicas: 100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;patch&lt;/em&gt;&lt;/strong&gt; 是部分的资源声明，在这个例子中是 Deployment 的补丁 &lt;code&gt;someapp/base/deployment.yaml&lt;/code&gt; ，仅修改了副本数用以处理生产流量。&lt;/p&gt;

&lt;p&gt;该补丁不仅仅是一个无上下文 {parameter name，value} 元组。其作为部分 deployment spec，可以通过验证，即使与其余配置隔离读取，也具有明确的上下文和用途。&lt;/p&gt;

&lt;p&gt;要为生产环境创建资源，请运行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kustomize build someapp/overlays/production
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果将作为一组完整资源打印到标准输出，并准备应用于集群。可以用类似的命令定义演示环境的配置。&lt;/p&gt;

&lt;h2 id=&#34;综上所述&#34;&gt;综上所述&lt;/h2&gt;

&lt;p&gt;使用 &lt;strong&gt;kustomize&lt;/strong&gt; ，您可以仅使用 Kubernetes API 资源文件就可以管理任意数量的 Kubernetes 定制配置。kustomize 的每个产物都是纯 YAML 的，每个都可以进行验证和运行的。&lt;strong&gt;kustomize&lt;/strong&gt; 鼓励通过 fork/modify/rebase 这样的&lt;a href=&#34;https://github.com/kubernetes-sigs/kustomize/blob/master/docs/workflows.md&#34; target=&#34;_blank&#34;&gt;工作流&lt;/a&gt;来管理海量的应用描述文件。&lt;/p&gt;

&lt;p&gt;尝试&lt;a href=&#34;https://github.com/kubernetes-sigs/kustomize/tree/master/examples/helloWorld&#34; target=&#34;_blank&#34;&gt;hello world&lt;/a&gt;示例，开始使用 &lt;strong&gt;kustomize&lt;/strong&gt; 吧！有关的反馈与讨论，可以通过加入&lt;a href=&#34;https://groups.google.com/forum/#!forum/kustomize&#34; target=&#34;_blank&#34;&gt;邮件列表&lt;/a&gt;或提 &lt;a href=&#34;https://github.com/kubernetes-sigs/kustomize/issues/new&#34; target=&#34;_blank&#34;&gt;issue&lt;/a&gt;，欢迎提交PR。&lt;/p&gt;

&lt;h2 id=&#34;译者按&#34;&gt;译者按&lt;/h2&gt;

&lt;p&gt;随着 kubernetes 1.14 的发布，kustomize 被集成到 &lt;code&gt;kubectl&lt;/code&gt; 中，用户可以利用 &lt;code&gt;kubectl apply -k dir/&lt;/code&gt; 将指定目录的 &lt;code&gt;kustomization.yaml&lt;/code&gt; 提交到集群中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;原文链接&lt;/strong&gt; &lt;a href=&#34;https://kubernetes.io/blog/2018/05/29/introducing-kustomize-template-free-configuration-customization-for-kubernetes/&#34; target=&#34;_blank&#34;&gt;https://kubernetes.io/blog/2018/05/29/introducing-kustomize-template-free-configuration-customization-for-kubernetes/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Devops入门手册</title>
      <link>https://blog.maoxianplay.com/post/devops-tutorial/</link>
      <pubDate>Tue, 09 Apr 2019 13:21:56 +0800</pubDate>
      
      <guid>https://blog.maoxianplay.com/post/devops-tutorial/</guid>
      <description>

&lt;h1 id=&#34;devops-是什么&#34;&gt;DevOps 是什么？&lt;/h1&gt;

&lt;p&gt;“DevOps” 这个词是 &lt;code&gt;development&lt;/code&gt; 和 &lt;code&gt;operations&lt;/code&gt; 这两个词的组合。它是一种促进开发和运维团队之间的协作，以自动化和可重复的方式更快地将代码部署到生产中的&lt;strong&gt;文化&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;DevOps 帮助团体提高软件和服务的交付速度。它使团队能够更好地为客户服务，并提高在市场中的竞争力。&lt;/p&gt;

&lt;p&gt;简而言之， DevOps 可以定义为通过更好的沟通和协作，使开发和运维保持一致。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://wx4.sinaimg.cn/large/ad5fbf65gy1g1wbobryucj20db07dq2w.jpg&#34; alt=&#34;what is devops&#34; /&gt;&lt;/p&gt;

&lt;p&gt;本手册中，您将学到：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#devops-是什么&#34;&gt;DevOps 是什么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#为什么需要-devops&#34;&gt;为什么需要 DevOps ？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#devops-与传统运维有什么不同&#34;&gt;DevOps 与传统运维有什么不同？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#为什么使用-devops&#34;&gt;为什么使用 DevOps ？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#devops-的生命周期&#34;&gt;DevOps 的生命周期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#devops-的工作流&#34;&gt;DevOps 的工作流&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;devops-与敏捷有什么不同-devops-vs-agile&#34; target=&#34;_blank&#34;&gt;DevOps 与敏捷有什么不同？ DevOps VS Agile&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#devops-原则&#34;&gt;DevOps 原则&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#谁可以做-devops-工程师&#34;&gt;谁可以做 DevOps 工程师？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#devops-工程师的角色-职责和技能&#34;&gt;DevOps 工程师的角色、职责和技能&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#devops-工程师可以挣多少钱&#34;&gt;DevOps 工程师可以挣多少钱？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#devops-培训认证&#34;&gt;DevOps 培训认证&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#devops-自动化工具&#34;&gt;DevOps 自动化工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#devops-的未来是怎样的&#34;&gt;DevOps 的未来是怎样的？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#总结&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;为什么需要-devops&#34;&gt;为什么需要 DevOps ？&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;在实行 DevOps 之前，开发和运维团队是完全孤立的。&lt;/li&gt;
&lt;li&gt;测试和部署是设计在构建之后完成的独立活动。因此，他们比实际构建周期消耗更多时间。&lt;/li&gt;
&lt;li&gt;在不使用 DevOps 的情况下，团队成员将大量时间花在测试，部署和设计上，而不是构建项目。&lt;/li&gt;
&lt;li&gt;手动部署代码会导致生产中出现人为错误。&lt;/li&gt;
&lt;li&gt;开发和运维团队都有各自的时间表，时间的不同步导致生产交付进一步延误。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;提高软件交付率是业务方最迫切的需求。根据 Forrester Consulting Study 统计，只有17％的团队可以足够快地交付软件。更是证明了这一痛点。&lt;/p&gt;

&lt;h1 id=&#34;devops-与传统运维有什么不同&#34;&gt;DevOps 与传统运维有什么不同？&lt;/h1&gt;

&lt;p&gt;让我们将传统软件瀑布开发模型与 DevOps 进行比较，以了解 DevOps 带来的变化。&lt;/p&gt;

&lt;p&gt;我们假设有一个应用程序计划在2周内上线，代码完成80％。该应用程序是一个新的发布，从购买服务器开始&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;瀑布式开发&lt;/th&gt;
&lt;th&gt;DevOps&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;订购新服务器后，开发团队需要进行测试。运维团队根据需求文档开始部署基础设施。&lt;/td&gt;
&lt;td&gt;订购新服务器后，开发和运维团队根据需求文档共同调试部署新服务器。这样开发人员可以更好地了解服务器的基础架构。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;关于故障转移，冗余策略，数据中心位置和存储要求的规划存在偏差，因为开发人员对应用程序有深入了解，但他们无法提供任何协助。&lt;/td&gt;
&lt;td&gt;由于开发人员的加入，有关故障转移，冗余策略，灾难恢复，数据中心位置和存储要求的规划非常准确。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;运维团队对开发团队的进展一无所知。只能根据运维团队理解制定监控计划。&lt;/td&gt;
&lt;td&gt;在 DevOps 中，运维团队完全了解开发人员的进展。通过互动，共同制定满足运维和业务需求的监控计划。他们还使用应用程序性能监视（APM）工具以优化应用。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;在上线之前，压力测试使应用程序崩溃。发布延迟了。&lt;/td&gt;
&lt;td&gt;在上线之前，压力测试使应用程序有点慢。开发团队迅速解决了瓶颈问题。该应用程序按时发布。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;为什么使用-devops&#34;&gt;为什么使用 DevOps ？&lt;/h1&gt;

&lt;p&gt;DevOps 允许敏捷开发团队实施持续集成和持续交付。这有助于他们更快地将产品推向市场。&lt;/p&gt;

&lt;p&gt;其他重要原因是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;可预测性：&lt;/strong&gt; DevOps 可以显着降低新版本的故障率。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自愈性：&lt;/strong&gt; 可以随时将应用回滚到较早的版本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可维护性：&lt;/strong&gt; 在新版本崩溃或当前系统不可用的情况下，可以毫不费力地进行恢复。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;上线时间：&lt;/strong&gt; DevOps 通过简化软件交付流程将上线时间缩短至50％。对于互联网和移动应用时间更短。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更高的质量：&lt;/strong&gt; DevOps 帮助团队提高应用程序开发的质量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;降低风险：&lt;/strong&gt; DevOps 在软件交付的生命周期中包含安全检查。它有助于减少整个软件生命周期中的安全风险。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;弹性：&lt;/strong&gt; 软件系统的运行状态更稳定，更安全，更改是可审计的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;成本效益：&lt;/strong&gt; DevOps 在软件开发过程中提供了成本效益，这始终是互联网公司管理层所期望的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;将大的代码库分成小块：&lt;/strong&gt; DevOps 是基于敏捷编程方法的。因此，它允许将大的代码库分解为更小且易于管理的块。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;什么时候使用-devops&#34;&gt;什么时候使用 DevOps ？&lt;/h3&gt;

&lt;p&gt;DevOps 应该用于大型分布式应用程序，例如电子商务站点或托管在云平台上的应用程序。&lt;/p&gt;

&lt;h3 id=&#34;什么时候不使用-devops&#34;&gt;什么时候不使用 DevOps？&lt;/h3&gt;

&lt;p&gt;它不应该用于关键任务应用程序，如银行，电力设施和其他敏感数据站点。此类应用程序需要对生产环境进行严格的访问控制，详细的变更管理策略，完善的数据中心访问控制策略。&lt;/p&gt;

&lt;h1 id=&#34;devops-的生命周期&#34;&gt;DevOps 的生命周期&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;http://wx3.sinaimg.cn/large/ad5fbf65gy1g1wekkedpcj20k509mjrp.jpg&#34; alt=&#34;devops Lifecycle&#34; /&gt;&lt;/p&gt;

&lt;p&gt;DevOps 是开发和运维之间的深度集成。在不了解 DevOps 生命周期的情况下，是无法真正理解 DevOps 的。&lt;/p&gt;

&lt;p&gt;以下是有关 DevOps生命周期的简要信息：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;开发&lt;/p&gt;

&lt;p&gt;在此阶段，整个开发过程分为小的开发周期。这有利于 DevOps 团队加快软件开发和交付过程。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;测试&lt;/p&gt;

&lt;p&gt;QA 团队使用 &lt;code&gt;Selenium&lt;/code&gt; 等自动化测试工具来识别和修复新代码中的错误。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;集成&lt;/p&gt;

&lt;p&gt;在此阶段，新功能与主分支代码集成，并进行测试。只有持续集成和测试才能实现持续交付。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;部署&lt;/p&gt;

&lt;p&gt;在此阶段，部署过程持续进行。它的执行方式是任何时候在代码中进行的任何更改都不应影响高流量网站的运行。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;监测&lt;/p&gt;

&lt;p&gt;在此阶段，运维团队将负责处理不合适的系统行为或生产中发现的错误。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;devops-的工作流&#34;&gt;DevOps 的工作流&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;http://wx4.sinaimg.cn/large/ad5fbf65gy1g1wewdq1elj20g009fa9y.jpg&#34; alt=&#34; DevOps Work Flow &#34; /&gt;&lt;/p&gt;

&lt;p&gt;工作流允许排列和分离用户最需要的任务。它还能够在配置任务时反应其最理想过程。&lt;/p&gt;

&lt;h1 id=&#34;devops-与敏捷有什么不同-devops-vs-agile&#34;&gt;DevOps 与敏捷有什么不同？ DevOps VS Agile&lt;/h1&gt;

&lt;p&gt;这是一个典型的IT流程&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://wx4.sinaimg.cn/large/ad5fbf65gy1g1wfmrcbafj20nq05wdg0.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;敏捷解决了客户和开发人员沟通中的问题&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://wx4.sinaimg.cn/large/ad5fbf65gy1g1wfn81bchj20no05q3ys.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;DevOps 解决了开发人员运维人员沟通中的问题&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://wx4.sinaimg.cn/large/ad5fbf65gy1g1wfnk7fi3j20nt05vt90.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;敏捷&lt;/th&gt;
&lt;th&gt;DevOps&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;强调打破开发人员和管理层之间的障碍。&lt;/td&gt;
&lt;td&gt;DevOps 是关于软件开发和运维团队的。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;解决客户需求与开发团队之间的距离。&lt;/td&gt;
&lt;td&gt;解决开发和运维团队之间的距离。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;重点关注功能和非功能准备。&lt;/td&gt;
&lt;td&gt;它侧重于运维和业务准备。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;敏捷开发主要涉及公司对开发方式的思考。&lt;/td&gt;
&lt;td&gt;DevOps 强调以最可靠和最安全的方式部署软件，而这些方式并不总是最快的。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;敏捷开发非常注重培训所有团队成员，使他们拥有各种相同的技能。因此，当出现问题时，任何团队成员都可以在没有团队领导的情况下从别的成员那里获得帮助。&lt;/td&gt;
&lt;td&gt;DevOps 在开发和运维团队之间传播技能，并保持一致的沟通。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;敏捷开发管理 “sprint” ，意味着时间更短（不到一个月），并且在此期间将产生和发布多个功能。&lt;/td&gt;
&lt;td&gt;DevOps 努力争取主要版本的稳定可靠，而不是更小和更频繁的发布版本。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;devops-原则&#34;&gt;DevOps 原则&lt;/h1&gt;

&lt;p&gt;这里有六个在采用 DevOps 时必不可少的原则：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;以客户为中心：&lt;/strong&gt; DevOps 团队必须以客户为中心，因为是他们不断向我的产品和服务投资。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;端到端的责任：&lt;/strong&gt; DevOps 团队需要在产品的整个生命周期提供性能支持。这提高了产品的水平和质量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;持续改进：&lt;/strong&gt; DevOps 文化专注于持续改进，以尽量减少浪费。它不断加快产品或服务改进的速度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动化一切：&lt;/strong&gt; 自动化是 DevOps 流程的重要原则。这不仅适用于软件开发，同时也适用于整个基础架构环境。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;作为一个团队工作：&lt;/strong&gt; 在 DevOps 文化角色中，设计人员，开发人员和测试人员已经定义。他们所需要做的就是作为一个团队完成合作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;监控和测试所有内容：&lt;/strong&gt; DevOps 团队拥有强大的监控和测试程序是非常重要的。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;谁可以做-devops-工程师&#34;&gt;谁可以做 DevOps 工程师？&lt;/h1&gt;

&lt;p&gt;DevOps 工程师是一名IT专业人员，他与软件开发人员，系统运维人员和其他IT人员一起管理代码发布。DevOps 应具备与开发，测试和运维团队进行沟通和协作的硬技能和软技能。&lt;/p&gt;

&lt;p&gt;DevOps 方法需要对代码版本进行频繁的增量更改，这意味着频繁的部署和测试方案。尽管 DevOps 工程师需要偶尔从头开始编码，但重要的是他们应该具备软件开发语言的基础知识。&lt;/p&gt;

&lt;p&gt;DevOps 工程师将与开发团队的工作人员一起解决连接代码的元素（如库或软件开发工具包）所需的编码和脚本。&lt;/p&gt;

&lt;h1 id=&#34;devops-工程师的角色-职责和技能&#34;&gt;DevOps 工程师的角色、职责和技能&lt;/h1&gt;

&lt;p&gt;DevOps 工程师负责软件应用程序平台的生产和持续维护。&lt;/p&gt;

&lt;p&gt;以下是 DevOps 工程师的一些角色，职责和技能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;能够跨平台和应用程序域执行系统故障排除和问题解决。&lt;/li&gt;
&lt;li&gt;通过开放的，标准的平台有效管理项目。&lt;/li&gt;
&lt;li&gt;提高项目可见性和可追溯性。&lt;/li&gt;
&lt;li&gt;通过协作提高开发质量并降低开发成本。&lt;/li&gt;
&lt;li&gt;分析、设计和评估自动化脚本和系统。&lt;/li&gt;
&lt;li&gt;通过使用最佳的云安全解决方案确保系统的安全。&lt;/li&gt;
&lt;li&gt;DevOps 工程师应该具备问题解决者和快速学习者的软技能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;devops-工程师可以挣多少钱&#34;&gt;DevOps 工程师可以挣多少钱？&lt;/h1&gt;

&lt;p&gt;DevOps 是最热门的IT专业之一。这就是为什么那里都有很多机会的原因。因此，即使是初级DevOps工程师的薪酬水平也相当高。在美国，初级DevOps工程师的平均年薪为78,696美元。&lt;/p&gt;

&lt;h1 id=&#34;devops-培训认证&#34;&gt;DevOps 培训认证&lt;/h1&gt;

&lt;p&gt;DevOps 培训认证可以帮助任何渴望成为 DevOps 工程师职业的人。认证可从 Amazon web services 、 Red Hat 、 Microsoft Academy 、 DevOps Institute 获得。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://aws.amazon.com/cn/certification/certified-devops-engineer-professional/&#34; target=&#34;_blank&#34;&gt;AWS Certified DevOps Engineer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;此 DevOps 工程师证书将测试您如何使用最常见的 DevOps 模式在 AWS 上开发，部署和维护应用程序。它还会评估 DevOps 方法的核心原则。&lt;/p&gt;

&lt;p&gt;该认证有两个必要条件：认证费用为300美元，持续时间为170分钟。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.redhat.com/en/services/training-and-certification&#34; target=&#34;_blank&#34;&gt;Red Hat Certification&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;红帽为 DevOps 专业人士提供不同级别的认证，如下所示:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Red Hat Certificate of Expertise in Platform-as-a-Service&lt;/li&gt;
&lt;li&gt;Red Hat Certificate of Expertise in Containerized Application Development&lt;/li&gt;
&lt;li&gt;Red Hat Certificate of Expertise in Ansible Automation&lt;/li&gt;
&lt;li&gt;Red Hat Certificate of Expertise in Configuration Management&lt;/li&gt;
&lt;li&gt;Red Hat Certificate of Expertise in Container Administration&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://devopsinstitute.com/&#34; target=&#34;_blank&#34;&gt;Devops Institute&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Devops Institute是围绕新兴 DevOps 实践的全球学习社区。该组织正在为 DevOps 能力资格设置质量标准。Devops Institute目前提供三个课程和认证。&lt;/p&gt;

&lt;p&gt;公司提供的认证课程有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DevOps Foundation&lt;/li&gt;
&lt;li&gt;DevOps Foundation Certified&lt;/li&gt;
&lt;li&gt;Certified Agile Service Manager&lt;/li&gt;
&lt;li&gt;Certified Agile Process Owner&lt;/li&gt;
&lt;li&gt;DevOps Test Engineering&lt;/li&gt;
&lt;li&gt;Continuous Delivery Architecture&lt;/li&gt;
&lt;li&gt;DevOps Leader&lt;/li&gt;
&lt;li&gt;DevSecOps Engineering&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;devops-自动化工具&#34;&gt;DevOps 自动化工具&lt;/h1&gt;

&lt;p&gt;所有测试流程自动化并对其进行配置以实现至关重要的速度和灵活性。此过程称为 DevOps 自动化。&lt;/p&gt;

&lt;p&gt;维护庞大的IT基础架构的大型 DevOps 团队面临的困难可以简要分为六个不同的类别。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;基础设施自动化&lt;/li&gt;
&lt;li&gt;配置管理&lt;/li&gt;
&lt;li&gt;部署自动化&lt;/li&gt;
&lt;li&gt;性能管理&lt;/li&gt;
&lt;li&gt;日志管理&lt;/li&gt;
&lt;li&gt;监测&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;让我们看看每个类别中的工具以及它们如何解决痛点：&lt;/p&gt;

&lt;h3 id=&#34;基础设施自动化&#34;&gt;基础设施自动化&lt;/h3&gt;

&lt;p&gt;亚马逊网络服务（AWS）：作为云服务，您无需建立实际的数据中心。此外，它们易于按需扩展。没有前期硬件成本。它可以配置为自动根据流量配置更多服务器。&lt;/p&gt;

&lt;h3 id=&#34;配置管理&#34;&gt;配置管理&lt;/h3&gt;

&lt;p&gt;Chef：它是一个有用的 DevOps 工具，用于提升速度，规模和一致性。它可用于简化复杂任务并执行配置管理。使用此工具，DevOps 团队可以避免在一万台服务器上进行更改。相反，只需要在一个地方进行更改，这些更改会自动反映在其他服务器中。&lt;/p&gt;

&lt;h3 id=&#34;部署自动化&#34;&gt;部署自动化&lt;/h3&gt;

&lt;p&gt;Jenkins：该工具有助于持续集成和测试。通过在部署构建后快速查找问题，更​​轻松地集成项目更改。&lt;/p&gt;

&lt;h3 id=&#34;日志管理&#34;&gt;日志管理&lt;/h3&gt;

&lt;p&gt;Splunk：可以解决在一个地方聚合，存储和分析所有日志的问题的工具。&lt;/p&gt;

&lt;h3 id=&#34;性能管理&#34;&gt;性能管理&lt;/h3&gt;

&lt;p&gt;App Dynamic：它是一个 DevOps 工具，提供实时性能监控。此工具收集的数据可帮助开发人员在发生问题时进行调试。&lt;/p&gt;

&lt;h3 id=&#34;监控&#34;&gt;监控&lt;/h3&gt;

&lt;p&gt;Nagios：在基础架构和相关服务出现故障时通知相关人员也很重要。Nagios 就是这样一种工具，它可以帮助 DevOps 团队找到并纠正问题。&lt;/p&gt;

&lt;h1 id=&#34;devops-的未来是怎样的&#34;&gt;DevOps 的未来是怎样的？&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;团队将代码部署周期转换为数周和数月，而不是数年。&lt;/li&gt;
&lt;li&gt;很快就会看到，DevOps 工程师可以比企业中的任何其他人更多地接近和管理终端用户。&lt;/li&gt;
&lt;li&gt;DevOps 正在成为IT人员的重要技能。例如，Linux 招聘进行的一项调查发现，25％的受访者的求职者寻求 DevOps 工作。&lt;/li&gt;
&lt;li&gt;DevOps 和持续交付将继续存在。因为公司需要发展，他们别无选择，只能改变。然而，DevOps 概念的主流化则需要5到10年。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;DevOps 是一种促进开发和运维团队之间的协作，以自动化和可重复的方式更快地将代码部署到生产中的&lt;strong&gt;文化&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;在 DevOps 出现之前运维和开发团队完全独立。&lt;/li&gt;
&lt;li&gt;手动部署代码会导致生产中出现人为错误。&lt;/li&gt;
&lt;li&gt;在旧的软件开发流程中，运维团队不了解开发团队的进度。因此，运维团队只能根据他们自己的理解制定了基础设施的购买和监控计划。&lt;/li&gt;
&lt;li&gt;在 DevOps 流程中，运维团队充分了解开发人员的进度。采购和监控计划准确无误。&lt;/li&gt;
&lt;li&gt;DevOps 提供可维护性，可预测性，更高质量的代码和更准确的上线时间。&lt;/li&gt;
&lt;li&gt;敏捷流程侧重于功能和非功能准备，而 DevOps 则侧重于IT基础架构方面。&lt;/li&gt;
&lt;li&gt;DevOps 生命周期包括开发，测试，集成，部署和监控。&lt;/li&gt;
&lt;li&gt;DevOps 工程师将与开发团队工作人员合作，以解决编码和脚本编写需求。&lt;/li&gt;
&lt;li&gt;DevOps 工程师应该具备问题解决者的软技能，并且是一个快速学习者。&lt;/li&gt;
&lt;li&gt;DevOps 认证可从 Amazon web services，Red Hat，Microsoft Academy，DevOps Institute 获得&lt;/li&gt;
&lt;li&gt;DevOps 可帮助团队将代码部署周期转换为数周和数月，而不是数年。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;原文链接&lt;/strong&gt; &lt;a href=&#34;https://www.guru99.com/devops-tutorial.html&#34; target=&#34;_blank&#34;&gt;https://www.guru99.com/devops-tutorial.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh是什么，我们又为什么需要它</title>
      <link>https://blog.maoxianplay.com/post/whats-a-service-mesh-and-why-do-i-need-one/</link>
      <pubDate>Mon, 25 Mar 2019 18:17:20 +0800</pubDate>
      
      <guid>https://blog.maoxianplay.com/post/whats-a-service-mesh-and-why-do-i-need-one/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;作者：William Morgan 发表于2017年4月25日，2018年11月26日有所修改。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Service Mesh 是一个专门使服务与服务之间的通信变得安全、快速和可靠的的基础设施。如果你正在在构建一个云原生（ Cloud Native ）应用，那么你一定需要 Service Mesh 。&lt;/p&gt;

&lt;p&gt;在过去的一年中， Service Mesh 成为了云原生技术栈的关键组件。像 Paypal ,  Ticketmaster 和 Credit Karma 这样的大厂，已经将 Service Mesh 加入到他们的全部应用中。并且在2017年1月，开源的 Service Mesh 软件 Linkerd 加入云原生基金会（ CNCF ），成为云原生基金会（ CNCF ）的官方项目。但是什么是真正的 Service Mesh ？它又为何突然变的如此重要？&lt;/p&gt;

&lt;p&gt;在这篇文章，我会讲解 Service Mesh 的定义，并通过应用服务架构过去十年的发展追溯其起源。并将 Service Mesh 与其他相似的概念（包括 API 网关，边缘代理以及 ESB （enterprise service bus））进行区分。最终，将会描述 Service Mesh 的发展方向，以及随着云原生概念的普及，Service Mesh 发生的变化。&lt;/p&gt;

&lt;h2 id=&#34;什么是-service-mesh&#34;&gt;什么是 Service Mesh&lt;/h2&gt;

&lt;p&gt;Service Mesh 这个服务网络专注于处理服务和服务间的通讯。其主要负责构造一个稳定可靠的服务通讯的基础设施，并让整个架构更为的先进和 Cloud Native。在工程中，Service Mesh 基本来说是一组轻量级的服务代理和应用逻辑的服务在一起，并且对于应用服务是透明的。&lt;/p&gt;

&lt;p&gt;Service Mesh 作为独立层的概念与云原生应用的兴起有关。在云原生模式，单个应用可能有数百个服务组成，每个服务又可能有上千个实例，而每个实例都有可能被像 kubernetes 这样的服务调度器不断调度从而不断变化状态。而这些复杂的通信又普遍是服务运行时行为的一部分，这时确保端到端的通信的性能和可靠性就变的至关重要。&lt;/p&gt;

&lt;h2 id=&#34;service-mesh-就是一个网络模型吗&#34;&gt;Service Mesh 就是一个网络模型吗？&lt;/h2&gt;

&lt;p&gt;Service Mesh 是一个位于 TCP/IP 上的抽象层的网络模型。它假定底层 L3/L4 网络存在并且能够从一点向另一点传输数据。（它还假定这个网络和环境的其他方面一样不可靠，所以 Service Mesh 也必须能够处理网络故障。）&lt;/p&gt;

&lt;p&gt;在某些方面，Service Mesh 就像是网络七层模型中的第四层 TCP 协议。其把底层的那些非常难控制的网络通讯方面的控制面的东西都管了（比如：丢包重传、拥塞控制、流量控制），而更为上面的应用层的协议，只需要关心自己业务应用层上的事了。&lt;/p&gt;

&lt;p&gt;与 TCP 不同的是， Service Mesh 想要达成的目的不仅仅是正常的网络通讯。它为应用提供了统一的，可视化的以及可控制的控制平面。Service Mesh 是要将服务间的通信从无法发现和控制的基础设施中分离出来，并对其进行监控、管理和控制。&lt;/p&gt;

&lt;h2 id=&#34;service-mesh-实际上做了什么&#34;&gt;Service Mesh 实际上做了什么？&lt;/h2&gt;

&lt;p&gt;在云原生应用中传递可靠的请求是十分复杂的。而 &lt;a href=&#34;https://linkerd.io/#_ga=2.114183109.310878331.1553762133-1927878916.1553476024&#34; target=&#34;_blank&#34;&gt;Linkerd&lt;/a&gt; 提供了服务熔断、重试、负载均衡、熔断降级等功能，通过其强大的功能来管理那些必须运行在复杂环境中的服务。&lt;/p&gt;

&lt;p&gt;这里列举一个通过 Linkerd 向服务发出请求的简单流程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;通过 Linkerd 的动态路由规则来确定打算连接哪个服务。这个请求是要路由到生产环境还是演示环境？是请求本地数据中心的服务还是云上的服务？是请求正在测试的最新版的服务还是已经在生产中经过验证的老版本？所有的这些路由规则都是动态配置的，可以全局应用也可以部分应用。&lt;/li&gt;
&lt;li&gt;找到正确的目的服务后， Linkerd 从一个或几个相关的服务发现端点检索实例池。如果这些信息与 Linkerd 的服务发现信息不同， Linkerd 会决定信任哪些信息来源。&lt;/li&gt;
&lt;li&gt;Linkerd 会根据观察到的最近的响应延迟来选择速度最快的实例。&lt;/li&gt;
&lt;li&gt;Linkerd 发送请求给这个实例，记录延迟和响应类型。&lt;/li&gt;
&lt;li&gt;如果这个实例挂了、无响应或者无法处理请求， Linkerd 会再另一个实例上重试这个请求。（但只有在请求是幂等的时候）&lt;/li&gt;
&lt;li&gt;如果一个实例一直请求失败， Linkerd 会将其移出定时重试的负载均衡池。&lt;/li&gt;
&lt;li&gt;如果请求超时， Linkerd 会主动将请求失效，而不是进一步重试从而增加负载。&lt;/li&gt;
&lt;li&gt;Linkerd 会记录指标和分布式的追踪上述行为的各个方面，将他们保存在集中的指标系统中。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上只是简化版的介绍， Linkerd 还可以启动和重试 TLS ，执行协议升级，动态切换流量，甚至在故障之后数据中心的切换。
&lt;img src=&#34;http://wx4.sinaimg.cn/large/ad5fbf65ly1g1in1q1jnuj20sg0gbt99.jpg&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;值得注意的是，这些功能旨在为每个实例和应用程序提供弹性伸缩。而大规模的分布式系统（无论是如何构建的）都有一个共同特点：都会因为许多小的故障，而升级为全系统灾难性的故障。Service Mesh 则被设计为通过快速的失效和减少负载来保护整个系统免受这样灾难性的故障。&lt;/p&gt;

&lt;h2 id=&#34;为什么-service-mesh-是必要的&#34;&gt;为什么 Service Mesh 是必要的？&lt;/h2&gt;

&lt;p&gt;Service Mesh 本质上并不是什么新技术，而是功能所在位置的转变。Web 应用需要管理复杂的服务通信，Service Mesh 模式的起源和演变过程可以追溯到15年前。&lt;/p&gt;

&lt;p&gt;参考2000年左右中型 Web 应用的典型三层架构，在这个架构中，应用被分为三层：应用逻辑、web 服务逻辑、存储逻辑。层之间的通信虽然复杂，但是毕竟范围有限，最多只有2跳。这里并不是 “Mesh” 的，但在每层中处理跳转的代码是存在通信逻辑的。&lt;/p&gt;

&lt;p&gt;当这种架构向更大规模发展的时候，这种通信方式就无以为继了。像 Google , Netflix , 和 Twitte ，在面临巨大的请求流量的时候，他们的实现了云原生应用的前身：应用被分割成了许多服务（现在称作“微服务”），这些服务组成了一种网格结构。在这些系统中，通用通信层突然兴起，表现为“胖客户端”的形式 - Twitter 的 Finagle, Netflix 的 Hystrix 和 Google 的 Stubby 都是很典型的例子。&lt;/p&gt;

&lt;p&gt;现在看来，像 Finagle 、Stubby 和 Hystrix 这样的库就是最早的 Service Mesh。虽然它们是为特定环境、语言和框架定制了，但都是作为基础设施专门用于管理服务间的通信，并（在 Finagle 和 Hystrix 开源的情况下）在其他公司的应用中被使用。&lt;/p&gt;

&lt;p&gt;这三个组件都有应用自适应机制，以便在负载中进行拓展，并处理在云环境中的部分故障。但是对于数百个服务或数千个实例，以及不时需要重新调度的业务层实例，单个请求通过的调用链可能变的非常复杂，而且服务可能由不同的语言编写，这时基于库的解决方案可能就不再适用了。&lt;/p&gt;

&lt;p&gt;服务通信的复杂性和重要性导致我们急需一个专门的基础设施层来处理服务间的通信，该层需要与业务代码解耦，并且具有捕获底层环境的动态机制。这就是 Service Mesh 。&lt;/p&gt;

&lt;h2 id=&#34;service-mesh-的未来&#34;&gt;Service Mesh 的未来&lt;/h2&gt;

&lt;p&gt;Service Mesh 在云生态下迅速的成长，并且有着令人激动的未来等待探索。对无服务器计算（Serverless， 例如 Amazon 的 &lt;a href=&#34;https://aws.amazon.com/lambda/&#34; target=&#34;_blank&#34;&gt;Lambda&lt;/a&gt;）适用的 Service Mesh 网络模型，在云生态系统中角色的自然拓展。Service Mesh 可能成为服务身份和访问策略这些在云原生领域还是比较新的技术的基础。最后，Service Mesh ，如之前的TCP / IP，将推进加入到底层的基础架构中。就像 Linkerd 是由像 Finagle 这样的系统发展而来，Service Mesh 将作为单独的用户空间代理添加到云原生技术栈中继续发展。&lt;/p&gt;

&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;

&lt;p&gt;Service Mesh 是云原生技术栈的关键技术。Linkerd 成立仅1年就成为了云原生基金会（CNCF）的一部分，拥有蓬勃发展的社区和贡献者。使用者从像 Monzo 这样颠覆英国银行业的创业公司，到像 Paypal、 Ticketmaster 和 Credit Karma 这样的互联网大厂，再到像 Houghton Mifflin Harcourt 这样经营了数百年的公司。&lt;/p&gt;

&lt;p&gt;使用者和贡献者每天都在 Linkerd 社区展示 Service Mesh 创造的价值。我们将致力于打造这一令人惊叹的产品，并继续发展壮大我们的社区，&lt;a href=&#34;https://linkerd.io/#_ga=2.40265824.310878331.1553762133-1927878916.1553476024&#34; target=&#34;_blank&#34;&gt;加入我们吧&lt;/a&gt;！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;原文链接&lt;/strong&gt; &lt;a href=&#34;https://buoyant.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/&#34; target=&#34;_blank&#34;&gt;https://buoyant.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
