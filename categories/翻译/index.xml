<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>翻译 on GuoXD Blog·郭旭东的博客</title>
    <link>https://guoxudong.io/categories/%E7%BF%BB%E8%AF%91/</link>
    <description>Recent content in 翻译 on GuoXD Blog·郭旭东的博客</description>
    <generator>Source Themes academia (https://sourcethemes.com/academic/)</generator>
    <language>zh-Hans</language>
    <copyright>&lt;a rel=&#39;license&#39; href=&#39;http://creativecommons.org/licenses/by-nc/4.0/&#39; target=&#39;_blank&#39;&gt;知识共享署名-非商业性使用 4.0 国际许可协议&lt;/a&gt;</copyright>
    <lastBuildDate>Thu, 09 Apr 2020 09:06:57 +0800</lastBuildDate>
    
	    <atom:link href="https://guoxudong.io/categories/%E7%BF%BB%E8%AF%91/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>导致你的微服务走向失败的11个原因</title>
      <link>https://guoxudong.io/post/11-reasons-why-you-are-going-to-fail-with-microservices/</link>
      <pubDate>Thu, 09 Apr 2020 09:06:57 +0800</pubDate>
      
      <guid>https://guoxudong.io/post/11-reasons-why-you-are-going-to-fail-with-microservices/</guid>
      <description>&lt;p&gt;在过去的几年里，我对多个正在进行数字化转型的产品团队进行了架构审查。发现大多数团队都会使用微服务架构来构建产品，他们使用微服务架构的意图都是正确的：更快的开发速度、更好的可扩展性、更小的独立团队、独立的部署、使用合适的技术来完成工作等等。但大多数时候，我发现团队在使用微服务时都很不顺利，他们没能利用微服务的优势。在这篇文章中，我将分享导致你的微服务走向失败的11个原因。&lt;/p&gt;
&lt;p&gt;对于刚接触微服务的人来说，我推荐阅读 Martin Fowler 的&lt;a href=&#34;https://martinfowler.com/articles/microservices.html&#34;&gt;《微服务》&lt;/a&gt;一文。文章中对微服务架构定义非常好。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;微服务架构风格这种开发方法，是以开发一组小型服务的方式来开发一个独立的应用系统。其中每个小型服务都运行在自己的进程中，并经常采用 HTTP 资源 API 这样轻量的机制来相互通信。这些服务围绕业务功能进行构建，并能通过全自动的部署机制来进行独立部署。这些微服务可以使用不同的语言来编写，并且可以使用不同的数据存储技术。对这些微服务，我们仅做最低限度的集中管理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;原因一管理层低估了微服务开发的复杂性&#34;&gt;原因一：管理层低估了微服务开发的复杂性&lt;/h2&gt;
&lt;p&gt;我曾与多个非常看好微服务客户合作过，对他们来说，微服务是解决他们所有问题的&lt;strong&gt;银弹&lt;/strong&gt;。在我看来，大多数团队及其管理层都低估了微服务开发的复杂性。&lt;/p&gt;
&lt;p&gt;要开发微服务，开发人员首先需要一个高效的本地开发环境。&lt;/p&gt;
&lt;p&gt;当你的系统中的服务开始增加时，在一台机器上运行应用程序的多个子程序就会变得很困难。特别是当你使用像 Java 这样消耗相对较多内存的语言来构建应用程序时，这种情况就更容易发生。&lt;/p&gt;
&lt;p&gt;以下是关于本地开发环境配置的相关要点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;本地开发首先需要一台好的开发机器。然而，大多数公司都想使用所有最新的、最先进的技术，但又不想换掉可怜的 Windows 开发机。我见过开发人员使用 VDI 虚拟云桌面或配置很差的机器来构建基于微服务的系统，开发人员受限于他们的开发机器，这降低了他们的工作效率，他们无法完全按照自己的想法在本地运行程序。而另一个副作用就是，开发人员不能快速得到反馈。如果你必须等待几分钟才能运行集成测试套件，那么你宁愿不写更多的集成测试套件来增加你的痛苦。糟糕的开发机助长了糟糕的开发实践。&lt;/li&gt;
&lt;li&gt;当为开发人员配备了合适的机器，接下来的事情就是确保所有的服务都使用统一的构建工具。你应该能够在一个新的机器上构建整个应用程序，而不需要太多的配置。根据我的经验，即使是使用微服务，使用一个可以构建整个应用程序的根构建脚本也是有帮助的。&lt;/li&gt;
&lt;li&gt;而下一点很重要，就是要让开发者能够在系统上轻松运行部分应用。在配置好所有的端口和存储卷的情况下，使用多个 &lt;code&gt;docker-compose&lt;/code&gt; 文件来启动不同的服务。&lt;/li&gt;
&lt;li&gt;接下来，如果你使用了 Kubernetes 这样的容器调度工具，那么你应该使用像 &lt;code&gt;Telepresence&lt;/code&gt; 这样的工具，它可以让你在 Kubernetes 集群中轻松调试应用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果一个团队不了解微服务开发的复杂性，那么随着时间的推移，团队的开发速度会明显下降。&lt;/p&gt;
&lt;h2 id=&#34;原因二没有将依赖和工具更新到最新版本的程序&#34;&gt;原因二：没有将依赖和工具更新到最新版本的程序&lt;/h2&gt;
&lt;p&gt;在架构审查时我发现有些新的平台居然已经出现了遗留问题。团队没有确保依赖包版本最新，也没有确保数据库等工具处于最新版本。所以，两年前才开始的项目到今天发现居然已经欠了几个月的技术债了。&lt;/p&gt;
&lt;p&gt;很多团队在几年前就开始使用 Spring Cloud Netflix OSS 项目构建微服务。而现在他们开始使用像 Kubernetes 这样的容器调度工具，但由于他们之前使用的是 Netflix OSS，所以他们并没有使用 Kubernetes 提供的所有功能。当 Kubernetes 内置了服务发现功能后，他们仍然在使用 Eureka 作为服务发现。另外，使用 Istio 这样的服务网格，使你可以摆脱 Netflix OSS 提供的大部分功能。这有助于降低代码复杂性，而将更多很复杂的问题交给基础设施平台来解决。&lt;/p&gt;
&lt;p&gt;还有一点要记住，就是要保持所有服务的依赖版本同步。我最近在帮助一个使用 Spring Boot 构建微服务的客户，在过去两年中，他们已经构建了 20 多个 Spring Boot 服务。在他们的环境中，他们使用的 Spring Boot 版本从 1.5 到 2.1 不等。这意味着，当有人配置他们的机器时，他们必须下载多个版本的 Spring Boot。此外，他们还缺少了 Spring Boot 自 1.5 版本以来的许多改进。&lt;/p&gt;
&lt;p&gt;我们的建议是，各团队应为这些升级问题设立专门的技术债务项目。这些技术债务项目应该作为架构委员会会议的一部分进行讨论并定期解决。在我的上一个项目中，我们每三个月进行一次一周的 sprint，来将所有的依赖项更新到最新版本。&lt;/p&gt;
&lt;p&gt;同时，团队也应该投入时间将数据库、消息队列和缓存等工具升级到最新版本。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;译者按：这里的最新版本应该是最新的稳定版本，即 &lt;code&gt;stable&lt;/code&gt; 版本，而不是 &lt;code&gt;latest&lt;/code&gt; 版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;原因三在本地开发中使用公共服务&#34;&gt;原因三：在本地开发中使用公共服务&lt;/h2&gt;
&lt;p&gt;由于本地开发效果的不理想，大多数团队开始依赖共享环境来提供关键服务。其中第一个就是数据库，大多数年轻的开发者并没有意识到基于数据库的共享开发并不好。以下是我认为共享数据库主要的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;团队成员需要建立一个约定，以免一个开发者把另一个开发者写的数据抹掉。这种工作方式是痛苦且容易失败的，迟早会拖累整个团队。&lt;/li&gt;
&lt;li&gt;导致开发人员害怕实验性测试，因为他们的工作会影响到其他一些团队成员的工作。我们都知道，更好的学习方式是实验和快速反馈。有了公共数据库后，实验就会变得十分困难。&lt;/li&gt;
&lt;li&gt;另一个副作用是，独立地测试变化变得困难。这使你的集成测试变得很不稳定，从而进一步降低了开发速度。&lt;/li&gt;
&lt;li&gt;公共数据库要像对待宠物一样对待，因为你不希望它出现哪怕一个不一致的、不可预测的状态。你可能会有一个开发人员想在表是空的时候测试边缘情况，但其他人则需要这个表的记录。&lt;/li&gt;
&lt;li&gt;只有公共数据库才有系统工作所需的所有数据。团队成员会随着时间的推移失去了更改的可追溯性，所以没有人知道他们是如何在自己的机器上复制同样的设置的。唯一的办法就是将完整的数据库转储，并与它一起工作。&lt;/li&gt;
&lt;li&gt;当你没有连接到网络时，很难工作。这种情况一般发生在长时间的通勤或坐飞机时。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数据库只是公共服务的一个例子，它也可以是消息队列、像 Redis 这样的集中式缓存或者其他任何一个服务可能变化的服务。&lt;/p&gt;
&lt;p&gt;解决这个问题的最好方法是让开发人员在自己的机器上运行数据库（使用 docker 运行），并创建 SQL 脚本来设置模式和初始化主数据。这些 SQL 脚本应该像其他代码一样被保存在版本控制中，并像其他代码一样进行维护。&lt;/p&gt;
&lt;h2 id=&#34;原因四版本控制托管平台缺乏可视性&#34;&gt;原因四：版本控制托管平台缺乏可视性&lt;/h2&gt;
&lt;p&gt;我的一个客户，他们使用的是 Gitlab 版本控制平台，其中有 5 个产品，1000 多个版本库，每个产品都由多个微服务组成。而我问他们的第一个问题是：哪些服务和代码库是产品 A 的一部分。&lt;/p&gt;
&lt;p&gt;解决这个问题的最好方法是在一开始就以某种方式对你的微服务进行分组，这样你就可以随时了解你的产品生态系统。Gitlab提供了创建组的方式，然后在其中创建项目仓库。Github 没有分组功能，你可以使用主题或命名惯例来实现。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我个人更喜欢单库，因为我觉得真的很方便。而大多数开发者都认为这是一种反模式。我同意 &lt;a href=&#34;https://danluu.com/monorepo/&#34;&gt;Dan Lua 的帖子&lt;/a&gt;，他在帖子中提到了以下好处:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;简化的组织结构&lt;/li&gt;
&lt;li&gt;简化了依赖性&lt;/li&gt;
&lt;li&gt;工具化&lt;/li&gt;
&lt;li&gt;跨项目变更&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;原因五没有明确的服务定义&#34;&gt;原因五：没有明确的服务定义&lt;/h2&gt;
&lt;p&gt;大多数团队都不知道如何划分微服务。围绕微服务的划分，产生了很多混乱和迷惑。让我们举个例子，你的应用程序有一个类似于插件的机制，将与多个第三方服务进行集成。每个集成是否应该是一个微服务？我见过多个团队走的是每个集成都要创建一个微服务的道路。随着集成数量的增加，这种做法很快就变得难以管理。这些服务通常都太小了，以至于它们作为一个单独的流程来运行会增加更多的开销。&lt;/p&gt;
&lt;p&gt;我认为大服务少，总比小服务多好。在一个企业组织内创建一个部门的模型，按照 DDD 的要求，将一个域分为子域和有边界的内容。有边界的内容代表了公司内部的一个部门，比如财务和营销部门。你可能会认为这可能会导致出现大型的微服务，认为这样做是不对的。但是，根据我的经验，将单体重构到微服务总是比反过来更容易。随着你获得更多的信息，你可以进行更细粒度的微服务划分。你可以应用单一责任原则来了解你的微服务是否变得太大，做的事情太多，然后将其分解成更小的独立服务。任何服务都不应该直接与另一个服务的数据库进行连接，它们只应该通过公开的接口进行通信。你可以在 Microservices.io 网站上阅读更多关于&lt;a href=&#34;https://microservices.io/patterns/decomposition/decompose-by-subdomain.html&#34;&gt;按子域模式分解&lt;/a&gt;的内容。&lt;/p&gt;
&lt;p&gt;我也遵循了 &lt;a href=&#34;https://github.com/fpereiro/backendlore&#34;&gt;backendlore&lt;/a&gt; 文档中提到的建议。这个建议可以帮助限制服务与服务之间的通信，而这是导致基于微服务的系统中性能低下的首要原因。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果两块信息是相互依存的，那么它们应该属于一个服务。换句话说，一个服务的自然边界应该是其数据的自然边界。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;原因六没有明确的代码复用策略&#34;&gt;原因六：没有明确的代码复用策略&lt;/h2&gt;
&lt;p&gt;我的一个客户，他们在所有基于 Java 的微服务中都复制了四个与一个特定的功能有关 Java 文件。所以，如果在那个基础代码上发现了一个 bug，就需要修改所有的项目。而在时间压力下，会有些项目没有被修复。这样就会浪费更多的时间，同时也增加了挫折感。&lt;/p&gt;
&lt;p&gt;并不是说开发团队都不知道怎么做是正确的，但组织架构总会让人们使用默认的容易出错的方式做事。&lt;/p&gt;
&lt;p&gt;正确的方法是使用 Bintray 或 Nexus 这样的智能管理器，并在那里发布依赖关系。然后，每个微服务都应该依赖该库。当发布新版本的库时，所有的微服务都应该被更新和重新部署。&lt;/p&gt;
&lt;p&gt;使用微服务并不意味着你要抛弃迄今为止对我们有效的最佳实践。你需要在构建工具方面投入更多精力，让微服务升级变得容易且自动化，这样就不需要人手工去做这些事情了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在没有合适的工具和自动化的情况下使用微服务是灾难性的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;原因七多语言方案&#34;&gt;原因七：多语言方案&lt;/h2&gt;
&lt;p&gt;我发现有的团队以最佳实践的名义使用多种编程语言、多种数据库、多种缓存。这一切在项目的初始阶段都是可行的，但当你的产品投入生产后，弊端就会展露。就像我们在使用 Java 的 Spring Boot 框架构建应用，但当我们意识到 Java 消耗的内存比较多，性能也比较差时，就决定改用 Node.js。这个理由是站不住脚的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;**Node.js 的性能比 Java 更好。**如果你有基于 IO 的工作负载，Node.js 的性能通常会更好。但在任何计算密集型的工作负载上，Java 都能&lt;a href=&#34;https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/javascript.html&#34;&gt;击败&lt;/a&gt; node.js。通过调整，也可以使 Java 对 IO 工作负载有更好的性能。Spring Boot Reactor 在 IO 工作负载方面的性能就相当于 Node.js。&lt;/li&gt;
&lt;li&gt;**Node.js 的内存消耗比 Java 少。**这是部分事实，因为 Node.js 应用程序通常比 Java 消耗的内存少。Java 的 Spring Boot 应用程序并不像大多数人想象的那样糟糕。我在其中一个 Spring Boot Java Microservice 上运行了一个加载测试，内存消耗仍然不到 1GB。你可以通过 OpenJ9 JVM，限制类路径上的依赖性，以及调整默认的 JVM 参数来优化 Java 的内存利用率。另外，在 Java 中还有一些新的 Spring Boot 的替代品，如 Micronaut 和 Quarkus，其内存消耗相当于 Node.js。&lt;/li&gt;
&lt;li&gt;**Node.js 比 Java 更有生产力。**这取决于写代码的开发人员。使用静态分析工具的 Java 可以帮助在开发生命周期的早期发现问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;大多数时候，这一切都取决于具体情况。如果你的开发人员不成熟，那么无论你使用什么编程语言，你都会开发出糟糕的产品。&lt;/p&gt;
&lt;p&gt;我建议一个公司公布一个团队可以使用的语言列表。我认为 2-3 种语言是个不错的数字。另外，请列举一下为什么应该使用一种语言而不是另一种语言的原因。&lt;/p&gt;
&lt;p&gt;在选择语言之前，你应该考虑多种因素：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;是否容易找到成熟的企业级软件开发者？&lt;/li&gt;
&lt;li&gt;重新培训开发人员学习新技术是否容易？我们发现，Java 开发人员相对来说比较容易学习 Golang。&lt;/li&gt;
&lt;li&gt;初始团队之外的开发人员是否能够轻松地维护他人编写的代码？&lt;/li&gt;
&lt;li&gt;工具和依赖库方面的生态体系是否成熟？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这不仅限于编程语言，也适用于数据库。如果你的系统中已经有 MongoDB，那么你为什么要在你的系统中再引入 ArangoDB 呢？它们都主要是文档数据库。&lt;/p&gt;
&lt;h2 id=&#34;原因八人的依赖性&#34;&gt;原因八：人的依赖性&lt;/h2&gt;
&lt;p&gt;这不是微服务所特有的，但在微服务生态中却变得更加猖獗。原因是大多数团队都专注于自己的具体服务，所以他们并不了解整个系统。在与不同客户的合作中，我发现只有一小部分架构师了解整体情况。但这些架构师的问题是，他们在日常工作中并不活跃，所以他们对开发的影响也是有限的。&lt;/p&gt;
&lt;p&gt;我认为最好的办法是确保所有的团队都有一个成员来自架构组，这样他们就可以使自己的团队与整个架构团队的路线图和目标保持一致，扁平化的管理有助于整个团队的成熟。&lt;/p&gt;
&lt;h2 id=&#34;原因九缺乏文档&#34;&gt;原因九：缺乏文档&lt;/h2&gt;
&lt;p&gt;过去的几年中，我接触的大多数团队都在文档方面挣扎。很多开发人员和架构师要么不写文档，要么他们写的文档没有用。即使他们想写，也不知道应该如何记录他们的架构。&lt;/p&gt;
&lt;p&gt;我们至少应记录以下内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设计文件&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://c4model.com/&#34;&gt;C4 模型&lt;/a&gt;中的内容图和容器图&lt;/li&gt;
&lt;li&gt;以&lt;a href=&#34;(http://thinkrelevance.com/blog/2011/11/15/documenting-architecture-decisions)&#34;&gt;架构决策记录&lt;/a&gt;的形式跟踪关键的架构决策&lt;/li&gt;
&lt;li&gt;开发人员入职指南&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我建议所有的文件都要在版本控制系统中进行维护。&lt;/p&gt;
&lt;h2 id=&#34;原因十功能盖过平台成熟度&#34;&gt;原因十：功能盖过平台成熟度&lt;/h2&gt;
&lt;p&gt;这个原因我在其他地方已经简单地提到过，但我认为这个原因值得作为一个顶层原因来提及。微服务比传统的单体应用要复杂得多，因为你正在构建一个分布式系统，里面有很多组件，而大多数开发人员还不能理解系统的不同故障模式。大多数微服务在构建时都太过乐观，如果管理层过早的专注于业务功能，而忽略了系统平台本身的成熟度，那么必将失败。在一个薄弱的平台上构建的功能是无法提供价值的。&lt;/p&gt;
&lt;p&gt;企业需要进入平台思维。平台思维并不只是指使用容器和 Kubernetes。它们是解决方案的一部分，但其本身不是完整的解决方案。你需要考虑分布式跟踪、可观察性、混沌测试、函数调用与网络调用、安全服务与服务之间的通信、可调试性等问题。这需要认真的努力和调试，建立成熟可靠的平台和工具团队。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你是一个资源有限的初创企业，我的建议是重新思考你的微服务战略。请你明白你正在进入的是什么。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;原因十一缺乏自动化测试&#34;&gt;原因十一：缺乏自动化测试&lt;/h2&gt;
&lt;p&gt;大多数团队都知道自动化测试对产品的整体质量有多重要，但他们仍然没有做。微服务架构为测试的地点和方式提供了更多的选择。如果你不做彻底的自动化测试，那么你将会失败得很惨。&lt;/p&gt;
&lt;p&gt;关于这一点，我就不多写了，因为网上很多文章都有涉及该问题。下图是我从 Martin Fowler 网站上发表的&lt;a href=&#34;https://martinfowler.com/articles/microservice-testing/&#34;&gt;《微服务测试》&lt;/a&gt;文章中摘录的，讲的是基于微服务系统的测试金字塔。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tvax3.sinaimg.cn/large/ad5fbf65gy1gdnnsqieu8j20bb0913yo.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;原文地址：https://medium.com/xebia-engineering/11-reasons-why-you-are-going-to-fail-with-microservices-29b93876268b&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes 中优化流量和安全性需要注意的7点要求</title>
      <link>https://guoxudong.io/post/7-requirements-for-optimized-traffic-flow-and-security-in-kubernetes/</link>
      <pubDate>Tue, 18 Feb 2020 14:15:42 +0800</pubDate>
      
      <guid>https://guoxudong.io/post/7-requirements-for-optimized-traffic-flow-and-security-in-kubernetes/</guid>
      <description>&lt;p&gt;根据 &lt;a href=&#34;https://portworx.com/wp-content/uploads/2018/12/Portworx-Container-Adoption-Survey-Report-2018.pdf&#34;&gt;Portworx 在2018年进行的一项调查&lt;/a&gt;，五分之四的企业现在正在使用容器，其中83％的企业正在生产环境中使用。而这个数字在2017年只有67％，很明显，容器不仅仅是一种时尚。&lt;/p&gt;
&lt;p&gt;但是，随着容器的流行，一些公司开始在 Kubernetes 内建立有效的流量控制和安全策略。&lt;/p&gt;
&lt;p&gt;作为容器调度和集群管理平台，Kubernetes 致力于提供出色的基础架构，因此被无数公司采用。它刚刚开源五周年，最近在福布斯发表的一篇名为&lt;a href=&#34;https://www.forbes.com/sites/janakirammsv/2019/05/25/5-exciting-facts-about-kubernetes-on-the-eve-of-its-5th-anniversary/#87a930c3e736&#34;&gt;《Kubernetes “the most popular open source project of our times”》&lt;/a&gt;的文章表示，Kubernetes 已被 Capital One，ING Group，Philips，VMware 和 Huawei 等公司使用。&lt;/p&gt;
&lt;p&gt;对于使用微服务架构（MSA）开发来应用程序的公司来说，Kubernetes 具有许多优势，特别是在应用程序部署方面。&lt;/p&gt;
&lt;p&gt;出于上面这些原因，研发团队有必要了解 Kubernetes 独有的流量和安全情况。在本文中，我们将介绍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kubernetes 是什么。&lt;/li&gt;
&lt;li&gt;Kubernetes 面临的挑战。&lt;/li&gt;
&lt;li&gt;Kubernetes 中的七个最重要的流量和安全要求。&lt;/li&gt;
&lt;li&gt;关于开发和操作简便性的注意事项。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;让我们开始吧。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-是什么&#34;&gt;Kubernetes 是什么&lt;/h2&gt;
&lt;p&gt;Kubernetes 是一个开源的容器编排系统。根据 &lt;a href=&#34;https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/&#34;&gt;Kubernetes’ own definition&lt;/a&gt;，它是一个可移植且可扩展的程序，用于管理容器化的工作负载和服务，并提供以容器为中心的管理环境。&lt;/p&gt;
&lt;p&gt;下图描述了 Kubernetes 的基本工作方式。图中可以看到一个主节点和两个工作节点。主节点用来告诉工作程序节点需要做什么工作，而工作程序节点则执行主节点提供给它们的指令。同时可以添加其他 Kubernetes 工作节点以扩展基础架构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tvax1.sinaimg.cn/large/ad5fbf65gy1gc0k2knw9zj20r30czq6p.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果仔细观察，您会发现在每个部分中都出现了 “Docker” 一词。Docker 是一个容器平台，非常适合在单个物理机或虚拟机（VM）上运行容器。&lt;/p&gt;
&lt;p&gt;但是，如果您要在多个不同的应用程序中使用数百个容器，且您不希望将它们全部放在一台计算机上。这是催生 Kubernetes 的挑战之一。&lt;/p&gt;
&lt;p&gt;使用 overlay 网络（如上图中的红色条所示），主节点中的容器不必知道它需要与之通信的容器位于哪个节点，就可以直接与之通信。&lt;/p&gt;
&lt;p&gt;Kubernetes 的另一个主要功能是将信息打包到 “pod” 中，如果应用程序由多个容器组成，则可以将这些容器组成一个 pod ，并共享整个生命周期。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-面临的挑战&#34;&gt;Kubernetes 面临的挑战&lt;/h2&gt;
&lt;p&gt;像所有其他容器编排系统一样，Kubernetes 也面临的诸多挑战，其中包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部和外部网络是隔离的。&lt;/li&gt;
&lt;li&gt;容器和容器的 IP 地址会发生变化。&lt;/li&gt;
&lt;li&gt;微服务之间没有访问控制。&lt;/li&gt;
&lt;li&gt;没有应用程序层的可见性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;让我们更深入地探讨这些挑战。Kubernetes 的网络不是常规的网络，因为尽管使用了 overlay 网络，但内部和外部网络却是彼此不通的。&lt;/p&gt;
&lt;p&gt;另外，Kubernetes 会隔离发生故障的节点或 Pod，以防止它们关闭整个应用程序。这可能导致节点之间的IP地址频繁更改。想要发现容器或容器的IP地址的服务就必须弄清楚新的IP地址是什么。&lt;/p&gt;
&lt;p&gt;当涉及微服务之间的访问控制时，对于企业而言，重要的是要认识到 Kubernetes 节点之间的流量也能够流入外部物理设备或 VM。这可能会消耗资源并削弱安全性。&lt;/p&gt;
&lt;p&gt;最后，无法在应用程序层检查信息是一个大问题。没有这种可见性，企业可能会错过收集详细分析信息的关键机会。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-和云安全要求&#34;&gt;Kubernetes 和云安全要求&lt;/h2&gt;
&lt;p&gt;到目前为止，我们已经讨论了 Kubernetes 的基本功能以及它所带来的挑战。现在，基于 &lt;a href=&#34;https://www.a10networks.com/&#34;&gt;A10 Networks&lt;/a&gt; 15年的经验，我们将继续讨论 Kubernetes 和云安全性的要求。&lt;/p&gt;
&lt;p&gt;我们将讨论如下七点要求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;高级应用程序交付控制器（ADC）&lt;/li&gt;
&lt;li&gt;使负载均衡器（LB）配置与基础架构保持同步&lt;/li&gt;
&lt;li&gt;南北向流量的安全&lt;/li&gt;
&lt;li&gt;为大规模部署准备的中央控制器&lt;/li&gt;
&lt;li&gt;微服务之间的访问控制&lt;/li&gt;
&lt;li&gt;东西向流量加密&lt;/li&gt;
&lt;li&gt;应用流量分析&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;1-高级应用程序交付控制器adc&#34;&gt;1. 高级应用程序交付控制器（ADC）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://tvax4.sinaimg.cn/large/ad5fbf65gy1gc0ldvmd2ij20r30bjad0.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;虽然企业可能已经在其基础架构的其他区域使用了高级应用程序交付控制器，但也有必要为 Kubernetes 部署一个。默认情况下，这将允许管理员操作在 Kubernetes 前的高级负载均衡器。&lt;/p&gt;
&lt;p&gt;Kubernetes 已经配备了名为 &lt;em&gt;kube-proxy&lt;/em&gt; 的网络代理。它提供了简单的用法：通过在三层中调整 iptables 规则来工作。但这是非常基本的，并与大多数企业操作习惯的有所不同。&lt;/p&gt;
&lt;p&gt;许多人会将 ADC 或负载均衡器放在他们的 Kubernetes 前。这样就可以创建一个静态的虚拟 IP，所有人都可以使用它，并动态配置所有内容。&lt;/p&gt;
&lt;p&gt;随着 Pod 和容器的启动，可以动态配置 ADC，以提供对新应用程序的访问，同时实现网络安全策略，并在某些情况下实施业务数据规则。通常，这是通过使用 “Ingress controller” 来实现的，其可以监控到新的容器和容器的启动，并且可以配置 ADC 以提供对新应用程序的访问权限，或者将更改通知给另一个 “Kubernetes controller” 节点。&lt;/p&gt;
&lt;h3 id=&#34;2-使负载均衡器lb配置与基础架构保持同步&#34;&gt;2. 使负载均衡器（LB）配置与基础架构保持同步&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://tvax1.sinaimg.cn/large/ad5fbf65gy1gc0ll8lr83j20r30aytbc.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;由于在 Kubernetes 中一切都是可以不断变化的，因此位于集群前的负载均衡器是无法追踪所有事情的。除非您有类似上图紫色框所示的东西。&lt;/p&gt;
&lt;p&gt;该紫色框为 Ingress Controller，当容器启动或停止时，会在 Kubernetes 中创建一个事件。然后，Ingress Controller 会识别该事件并做出相应的响应。&lt;/p&gt;
&lt;p&gt;如上图所示，Ingress Controlle 识别到容器已启动，并将其放入负载均衡池。这样，应用程序控制器（无论是在云之上还是内部）都可以保持最新状态。&lt;/p&gt;
&lt;p&gt;这减轻了管理员的负担，并且比手动管理效率更高。&lt;/p&gt;
&lt;h3 id=&#34;3-南北向流量的安全&#34;&gt;3. 南北向流量的安全&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://tvax4.sinaimg.cn/large/ad5fbf65gy1gc1hnwxcqlj20r30bpgon.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;南北和东西方都是用来描述流量流向的通用术语。南北流量是指流量流入和流出 Kubernetes。&lt;/p&gt;
&lt;p&gt;如前所述，企业需要在 Kubernetes 前放置一些设备来监视流量。例如，防火墙，DDoS 防护或任何其他可捕获恶意流量的设备。&lt;/p&gt;
&lt;p&gt;这些设备在流量管理方面也很有用。因此，如果流量需要流向特定的区域，这是理想的选择。Ingress Controller 在这方面也可以提供很多帮助。&lt;/p&gt;
&lt;p&gt;如果企业可以通过统一的解决方案使这种功能自动化，那么他们可以得到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更简化操作&lt;/li&gt;
&lt;li&gt;更好的应用程序性能&lt;/li&gt;
&lt;li&gt;可在不中断前端的情况下进行后端更改&lt;/li&gt;
&lt;li&gt;自动化的安全策略&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-为大规模部署准备的中央控制器&#34;&gt;4. 为大规模部署准备的中央控制器&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://tva4.sinaimg.cn/large/ad5fbf65gy1gc1i8wydpyj20r30bamzf.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;企业还需要考虑到横向扩展，特别是在安全性方面。&lt;/p&gt;
&lt;p&gt;如上图所示，Ingress Controller（由紫色框表示）仍然存在，但是这次它正在处理来自多个 Kubernetes 节点的请求，并且正在观测整个 Kubernetes 集群。&lt;/p&gt;
&lt;p&gt;Ingress Controller 前方的蓝色圆圈是 &lt;a href=&#34;https://www.a10networks.com/products/harmony-controller/&#34;&gt;A10 Networks Harmony Controller&lt;/a&gt;。这种控制器可以实现高效的负载分配，并且可以将信息快速发送到适当的位置。&lt;/p&gt;
&lt;p&gt;使用这样的中央控制器，必须选择一种在现有解决方案上进行少量额外配置，就可进行扩容和缩容的解决方案。&lt;/p&gt;
&lt;h3 id=&#34;5-微服务之间的访问控制&#34;&gt;5. 微服务之间的访问控制&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://tva3.sinaimg.cn/large/ad5fbf65gy1gc1ikekni3j20r30ckjuz.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;与流入和流出 Kubernetes 的南北流量相反，东西向流量在 Kubernetes 节点之间流动。在上图中，您可以看到东西向流量是如何运作的。&lt;/p&gt;
&lt;p&gt;当流量在 Kubernetes 节点之间流动时，可以通过物理网络，虚拟网络或 overlay 网络来发送该流量。如果不通过某种方式来监控那些东西向的流量，那么对流量如何从一个 pod 或容器流向另一个 pod 或容器的了解就变得非常困难。&lt;/p&gt;
&lt;p&gt;另外，它还可能带来严重的安全风险：&lt;strong&gt;获得对一个容器的访问权限的攻击者可以访问整个内部网络&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;幸运的是，企业可以通过“服务网格”（例如 A10 Secure Service Mesh）来解决这个问题。通过充当容器之间的代理以实现安全规则，这可以确保东西向的流量安全，并且还可以帮助扩展，负载均衡，服务监视等。&lt;/p&gt;
&lt;p&gt;此外，服务网格可以在 Kubernetes 内部运行，而无需将流量发送到物理设备或 VM。使用服务网格，东西向的流量状况如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tvax1.sinaimg.cn/large/ad5fbf65gy1gc1ikyysvtj20r30bcn0n.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;通过这种解决方案，像金融机构这样的企业可以轻松地将信息保留在应有的位置，而不用担心影响安全性。&lt;/p&gt;
&lt;h3 id=&#34;6-东西向流量加密&#34;&gt;6. 东西向流量加密&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/ad5fbf65gy1gc1ivrlln4j20r309ojtt.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果没有适当的加密，未加密的信息可能会从一个物理 Kubernetes 节点流到另一个。这是一个严重的问题，特别是对于需要处理特别敏感信息的金融机构和其他企业。&lt;/p&gt;
&lt;p&gt;这就是为什么对于企业而言，在评估云安全产品时，重要的是选择一种可以在离开节点时对流量进行加密，并在进入节点时对其进行解密的方法。&lt;/p&gt;
&lt;p&gt;供应商可以通过两种方式提供这种类型的保护：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://tva4.sinaimg.cn/large/ad5fbf65gy1gc1ixe7n4xj20r30b0aci.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;第一个选择是 Sidecar 代理部署，这种方法也是最受欢迎的。&lt;/p&gt;
&lt;p&gt;通过这样的部署，管理员可以告诉 Kubernetes，每当启动特定 pod 时，应在该 pod 中启动一个或多个其他容器。&lt;/p&gt;
&lt;p&gt;通常，其他容器是某种类型的代理，可以管理从 Pod 流入和流出的流量。&lt;/p&gt;
&lt;p&gt;从上图可以看出，Sidecar 代理部署的不利之处在于，每个 pod 都需要启动一个 Sidecar，因此将占用一定数量的资源。&lt;/p&gt;
&lt;p&gt;另一方面，企业也可以选择中心辐射代理部署。在这种类型的部署中，一个代理会处理从每个 Kubernetes 节点流出的流量。这样只需要较少的资源。&lt;/p&gt;
&lt;h3 id=&#34;7-应用流量分析&#34;&gt;7. 应用流量分析&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://tvax2.sinaimg.cn/large/ad5fbf65gy1gc1j83rredj20r30dfn2i.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;最后一点是，企业了解应用程序层流量的详细信息至关重要。&lt;/p&gt;
&lt;p&gt;有了可同时监控南北和东西向流量的控制器，就已经有了两个理想的点来收集流量信息。&lt;/p&gt;
&lt;p&gt;这样做既可以帮助优化应用程序，又可以提高安全性，还可以拓展多种不同的功能。从最简单到最高级的顺序排列，这些功能可以实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过描述性分析进行&lt;strong&gt;性能监控&lt;/strong&gt;。大多数供应商都提供此功能。&lt;/li&gt;
&lt;li&gt;通过诊断分析&lt;strong&gt;更快地进行故障排除&lt;/strong&gt;。少数供应商提供此功能。&lt;/li&gt;
&lt;li&gt;通过机器学习系统生成的预测分析获得&lt;strong&gt;建议&lt;/strong&gt;。更少的供应商提供此功能。&lt;/li&gt;
&lt;li&gt;通过真实直观的AI生成的规范分析进行&lt;strong&gt;自适应控制&lt;/strong&gt;。只有最好，最先进的供应商才能提供此功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，当企业与供应商交流时，至关重要的是确定他们的产品可以提供哪些功能。&lt;/p&gt;
&lt;p&gt;使用 A10 Networks 的类似产品，可以查看大图分析以及相关的单个数据包，日志条目或问题。具有这种粒度的产品是企业应寻求的产品。&lt;/p&gt;
&lt;h2 id=&#34;关于开发和操作简便性的注意事项&#34;&gt;关于开发和操作简便性的注意事项&lt;/h2&gt;
&lt;p&gt;最后，让我们看一下企业在 Kubernetes 中的流量和安全性方面应该追寻的东西。考虑这些因素还可以为开发和运维团队大大简化工作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;具有统一解决方案的简单体系结构。&lt;/li&gt;
&lt;li&gt;集中管理和控制，便于进行分析和故障排除。&lt;/li&gt;
&lt;li&gt;使用常见的配置格式，例如 YAML 和 JSON。&lt;/li&gt;
&lt;li&gt;无需更改应用程序代码或配置即可实现安全性和收集分析信息。&lt;/li&gt;
&lt;li&gt;自动化应用安全策略。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果公司优先考虑以上这些，则企业可以在使用 Kubernetes 时享受简单、自动化和安全的流量。您的基础设施、架构和运维团队都会对此感到满意。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
</description>
    </item>
    
    <item>
      <title>如何构建混合Kubernetes平台</title>
      <link>https://guoxudong.io/post/how-we-built-our-hybrid-kubernetes-platfor/</link>
      <pubDate>Tue, 06 Aug 2019 14:01:30 +0800</pubDate>
      
      <guid>https://guoxudong.io/post/how-we-built-our-hybrid-kubernetes-platfor/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;随着3年前重构 &lt;a href=&#34;https://www.dailymotion.com/&#34;&gt;Dailymotion&lt;/a&gt; 核心API的决定，我们希望提供一种更有效的方式来托管应用程序，&lt;a href=&#34;https://medium.com/dailymotion/deploying-apps-on-multiple-kubernetes-clusters-with-helm-19ee2b06179e&#34;&gt;促进我们的开发和生产工作流程&lt;/a&gt;。 最终决定使用容器编排平台来实现这一目标，那么自然就选择了 Kubernetes。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么为什么要建立自己的Kubernetes平台？&lt;/p&gt;
&lt;h2 id=&#34;借由-google-cloud-快速推动的-api-投入生产&#34;&gt;借由 Google Cloud 快速推动的 API 投入生产&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;2016年夏&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;三年前，在 &lt;a href=&#34;https://www.vivendi.com/&#34;&gt;Vivendi&lt;/a&gt; 收购 Dailymotion 之后，所有开发团队都专注于一个目标：提供全新的 Dailymotion 产品。&lt;/p&gt;
&lt;p&gt;根据对容器、编排解决方案和以前的经验的分析，使我们确信 Kubernetes 是正确的选择。许多开发人员已经掌握了这一概念并知道如何使用 Kubernetes ，这对我们的基础设施转型来说是一个巨大的优势。在基础架构方面，我们需要一个强大而灵活的平台来托管这些新型的云原生应用程序。而公有云为我们提供了极大的便利，于是我们决定在 Google Kubernetes Engine 上部署我们的应用程序，即使之后我们也会在自己的数据中心中进行混合部署。&lt;/p&gt;
&lt;h3 id=&#34;为何选择-gke-&#34;&gt;为何选择 GKE ？&lt;/h3&gt;
&lt;p&gt;我们做出这个选择主要是出于技术原因，但也因为我们需要快速提供基础设施来满足 Dailymotion 的业务需求。并且对托管的应用程序（如地理分布，可伸缩性和弹性）有一些要求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ws2.sinaimg.cn/large/ad5fbf65gy1g5py1vm2k2j20hd0bbjtq.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Dailymotion 作为一个全球性的视频平台，需要通过减少延迟来改善用户体验。之前我们仅在巴黎提供 &lt;a href=&#34;https://developer.dailymotion.com/&#34;&gt;API&lt;/a&gt; ，但这样并非最佳，我们希望能够在欧洲、亚洲以及美国托管我们的应用程序。&lt;/p&gt;
&lt;p&gt;这种延迟限制意味着我们在平台的网络设计方面面临着巨大的挑战。大多数云供应商要求我们在每个地区创建一个网络，并将所有这些网络通过 VPN 与托管服务互连，但 Google Cloud 允许我们在所有 Google 地区创建一个完全路由的单一网络，该网络在运营方面提供了便利并提高了效率。&lt;/p&gt;
&lt;p&gt;此外，Google Cloud 的网络和负载均衡服务非常棒。它可以将我们的用户路由到最近的集群，并且在发生故障的情况下，流量会自动路由到另一个区域而无需任何人为干预。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wx4.sinaimg.cn/large/ad5fbf65gy1g5pytelbwnj20jg0avq4x.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;我们的平台同样需要使用 GPU，而 Google Cloud 允许我们以非常有效的方式直接在我们的 Kubernetes 集群中使用它们。&lt;/p&gt;
&lt;p&gt;所有这一切使我们在启动后6个月开始接入 Google Cloud 基础架构上的生产流量。&lt;/p&gt;
&lt;p&gt;但是，尽管具有整体优势，但使用共有云服务还是要花费不少成本。这就是为什么我们要评估采取的每项托管服务，以便将来将其内部化。事实上，我们在2016年底开始构建我们的本地集群，并启动了我们的混合策略。&lt;/p&gt;
&lt;h2 id=&#34;在-dailymotion-的内部构建容器编排平台&#34;&gt;在 Dailymotion 的内部构建容器编排平台&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;2016年秋&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看到整个技术栈已经准备好在生产环境中应用，但&lt;a href=&#34;https://tartiflette.io/&#34;&gt;API仍在开发中&lt;/a&gt;，这使得我们有时间专注搭建我们的本地集群。&lt;/p&gt;
&lt;p&gt;Dailymotion 多年来在全球拥有自己的内容分发网络，每月有超过30亿的视频播放量。显然，我们希望利用现有的优势并在我们现有的数据中心部署自己的 Kubernetes 集群。&lt;/p&gt;
&lt;p&gt;我的目前拥有6个数据中心的2500多台服务器。所有这些都使用 Saltstack 进行配置，我们开始准备所有需要的公式来创建主节点、工作节点以及 Etcd 集群。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wx2.sinaimg.cn/large/ad5fbf65gy1g5pzm4m985j20jg06tgm7.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;网络部分&#34;&gt;网络部分&lt;/h3&gt;
&lt;p&gt;我们的网络是一个完全路由的网络。每个服务器使用Exabgp通过网络广播自己的IP。我们比较了几个网络插件， &lt;a href=&#34;https://www.projectcalico.org/&#34;&gt;Calico&lt;/a&gt; 使用的是三层网络，因此这是唯一满足我们需求的网络插件。&lt;/p&gt;
&lt;p&gt;由于我们想要重用基础架构中的所有现有工具，首先要解决的问题是插入一个自制网络工具（我们所有服务器都使用它），通过我们的 Kubernetes 节点通过网络广播 IP 范围。我们让 Calico 为 pod 分配 IP，但不使用它与我们的网络设备进行BGP会话。路由实际上是由Exabgp处理的，它宣布了Calico使用的子网。这使我们可以从内部网络访问任何pod，尤其是来自我们的负载均衡器。&lt;/p&gt;
&lt;h3 id=&#34;我们如何管理入口流量&#34;&gt;我们如何管理入口流量&lt;/h3&gt;
&lt;p&gt;为了将传入的请求路由到正确的服务，我们希望使用 Ingress Controllers 与 Kubernetes 的入口资源集成。&lt;/p&gt;
&lt;p&gt;3年前，nginx-ingress-controller 是最成熟的控制器 ，并且 Nginx 已经使用多年，并以其稳定性和性能而闻名。&lt;/p&gt;
&lt;p&gt;在我们的设计中，我们决定在专用的 10Gbps 刀片服务器上托管我们的控制器。每个控制器都插入其所属集群的 kube-apiserver 端点。在这些服务器上，我们还使用Exabgp来广播公共或私有IP。我们的网络拓扑允许我们使用来自这些控制器的BGP将所有流量直接路由到我们的pod，而无需使用NodePort服务类型。这样可以避免节点之间的水平流量，从而提高效率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ws3.sinaimg.cn/large/ad5fbf65gy1g5q05ex27bj20in0fbt9q.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;现在我们已经看到了我们如何构建混合平台，我们可以深入了解流量迁移本身。&lt;/p&gt;
&lt;h2 id=&#34;将流量从-google-cloud-迁移到-dailymotions-基础架构&#34;&gt;将流量从 Google Cloud 迁移到 Dailymotions 基础架构&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;2018年秋&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经过近2年的构建、测试和微调，我们发现自己拥有完整的 Kubernetes 技术栈，可以接收部分流量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wx2.sinaimg.cn/large/ad5fbf65gy1g5q0b3o8laj20jg06sq36.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;目前，我们的路由策略非常简单，但足以解决我们的问题。除了我们的公共IP（Google Cloud和Dailymotion）之外，我们还使用AWS Route 53 来定义策略并将终端用户流量引入我们选择的集群。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ws2.sinaimg.cn/large/ad5fbf65gy1g5q0ds3spjj20jg07a0tk.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;在 Google Cloud 上很简单，因为我们为所有群集使用唯一的IP，并且用户被路由到他最近的 GKE 群集。对于我们来说，我们不使用相同的技术，因此我们每个群集都有不同的IP。&lt;/p&gt;
&lt;p&gt;在此次迁移过程中，我们将目标国家逐步纳入我们的集群并分析其收益。&lt;/p&gt;
&lt;p&gt;由于我们的GKE集群配置了自动调节自定义指标，因此它们会根据传入流量进行扩展/缩小。&lt;/p&gt;
&lt;p&gt;在正常模式下，区域的所有流量都路由到我们的内部部署集群，而GKE集群则使用Route 53提供的运行状况检查作为故障转移。&lt;/p&gt;
&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;
&lt;p&gt;我们接下来的步骤是完全自动化我们的路由策略，以实现自动混合策略，不断增强我们的用户体验。在效益方面，我们大大降低了云的成本，甚至改善了API响应时间。我们相信我们的云平台足以在需要时处理更多流量。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用 Helm 在多集群部署应用</title>
      <link>https://guoxudong.io/post/deploying-apps-on-multiple-kubernetes-clusters-with-hel/</link>
      <pubDate>Sun, 14 Jul 2019 14:16:56 +0800</pubDate>
      
      <guid>https://guoxudong.io/post/deploying-apps-on-multiple-kubernetes-clusters-with-hel/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.dailymotion.com/&#34;&gt;Dailymotion&lt;/a&gt; 在生产环境使用 Kubernetes 已经3年了，但是也面临着多集群部署应用的挑战，这也是在过去的几年中我一直努力优化工具和改进工作流的原因。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;本文将重点介绍我们如何在全球多个 Kubernetes 集群上部署我们的应用程序。&lt;/p&gt;
&lt;p&gt;为了将应用一次部署到多个 Kubernetes 集群，我们使用了 &lt;a href=&#34;https://helm.sh/&#34;&gt;Helm&lt;/a&gt;，并将所有 chart 存储在一个 git 仓库中。我们使用 &lt;strong&gt;umbrella&lt;/strong&gt; 来部署由多个服务组成的完整应用程序，这基本上是一个声明依赖关系的 chart ，其允许我们在单个命令行中引导我们的 API 及其服务。&lt;/p&gt;
&lt;p&gt;此外，我们在使用 Helm 之前会运行一个 python 脚本，用来进行检查，构建 chart ，添加 secrets 并部署我们的应用程序。所有这些任务都是使用 docker 镜像在 CI 平台上完成的。&lt;/p&gt;
&lt;p&gt;下面就进行详细介绍&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意！：&lt;/strong&gt; 当你阅读这篇博文的时候，Helm 3 的第一个 &lt;a href=&#34;https://github.com/helm/helm/releases/tag/v3.0.0-alpha.1&#34;&gt;release&lt;/a&gt; 已经发布。这个版本带来了一系列增强功能，肯定会解决我们过去遇到的一些问题。&lt;/p&gt;
&lt;h2 id=&#34;preview_only-false&#34;&gt;image:
caption: &amp;ldquo;Image from: &lt;a href=&#34;https://www.pexels.com&#34;&gt;&lt;strong&gt;Pexels&lt;/strong&gt;&lt;/a&gt;&amp;rdquo;
focal_point: &amp;quot;&amp;rdquo;
preview_only: false&lt;/h2&gt;
&lt;h2 id=&#34;charts-开发流程&#34;&gt;Charts 开发流程&lt;/h2&gt;
&lt;p&gt;在开发应用程序时，我们使用&lt;a href=&#34;https://git-scm.com/book/en/v2/Git-Branching-Branching-Workflows&#34;&gt;分支工作流&lt;/a&gt;，开发 chart 时也使用相同流程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，&lt;strong&gt;dev&lt;/strong&gt; 分支用于构建要在开发集群上进行测试的 chart 。&lt;/li&gt;
&lt;li&gt;然后，当发起 PR 请求到 &lt;strong&gt;master&lt;/strong&gt; 分支时，将发布到演示环境中进行验证。&lt;/li&gt;
&lt;li&gt;最终，我们将 PR 请求提交的修改合并到 &lt;strong&gt;prod&lt;/strong&gt; 分支，将这个修改应用于生产环境。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们使用 &lt;a href=&#34;https://chartmuseum.com/&#34;&gt;Chartmuseum&lt;/a&gt; 作为私有仓库来存储 chart ，每个环境都有一个 。这样我们就可以在__环境之间实现明确的隔离__，并且确保该 chart 在生产环境中使用之前已经过测试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wx2.sinaimg.cn/large/ad5fbf65gy1g50h10d4xbj20ys0ee75e.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;值得注意的是，当开发人员 push 代码到他们的 dev 分支时，他们的 chart 版本也会自动 push 到 dev 环境的 Chartmuseum 。因此，所有开发人员都使用相同的 dev 存储库，他们必须小心的指定自己的 chart 版本，以避免使用其他人的对 chart 的更改。&lt;/p&gt;
&lt;p&gt;此外，我们的 python 脚本通过使用 &lt;a href=&#34;https://kubeval.instrumenta.dev/&#34;&gt;Kubeval&lt;/a&gt; 在它们推送到 Chartmusem 之前验证 Kubernetes 对象与 Kubernetes OpenAPI 规范。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;chart 开发工作流&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://ws3.sinaimg.cn/large/ad5fbf65gy1g50hg9gmh2j20gr047t8o.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据 &lt;a href=&#34;https://gazr.io/&#34;&gt;gazr.io&lt;/a&gt; 规范设置我们的 pipeline 任务（lint，unit-test）。&lt;/li&gt;
&lt;li&gt;push docker 镜像，该镜像包含部署应用程序的 Python 工具。&lt;/li&gt;
&lt;li&gt;根据分支名称设置相应环境。&lt;/li&gt;
&lt;li&gt;使用 Kubeval 检查 Kubernetes yamls 。&lt;/li&gt;
&lt;li&gt;自动增加 chart 版本及其父项（取决于更改的 chart ）。&lt;/li&gt;
&lt;li&gt;将 chart push 到与其环境对应的 Chartmuseum 。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;管理集群差异&#34;&gt;管理集群差异&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Cluster federation&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们使用 &lt;a href=&#34;https://kubernetes.io/docs/concepts/cluster-administration/federation/&#34;&gt;Kubernetes cluster federation&lt;/a&gt;，它允许我们从单个 API 端声明 Kubernetes 对象。但是我们遇到的问题是，无法在 federation 端中创建某些 Kubernetes 对象，因此很难维护 federation 对象和其他的群集对象。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，我们决定独立管理我们的集群，反而使这个过程变得更加容易（我们使用的是 federation v1，v2 可能有所改善）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;平台地理分布&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前，我们的平台分布在6个地区，3个在自己的数据中心，3个在公有云。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/ad5fbf65gy1g50klup6yaj212w0ftq4h.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;Helm global values&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;4个全局的 Helm value 定义集群间的差异。这些是我们所有 chart 的最小默认值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;global&lt;/span&gt;:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;cloud&lt;/span&gt;: True
        &lt;span style=&#34;color:#66d9ef&#34;&gt;env&lt;/span&gt;: staging
        &lt;span style=&#34;color:#66d9ef&#34;&gt;region&lt;/span&gt;: us-central1
        &lt;span style=&#34;color:#66d9ef&#34;&gt;clusterName&lt;/span&gt;: staging-us-central1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;这些信息有助于我们为应用程序定义上下文，它们可用于监控，跟踪，记录，进行外部调用，扩展等许多内容&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;cloud&lt;/strong&gt;：我们有一个混合 Kubernetes 集群。例如，我们的 API 部署在 GCP 和我们自己的数据中心。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;env&lt;/strong&gt;：对于非生产环境，某些值可能会发生变化。本质上是资源定义和自动扩展配置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;region&lt;/strong&gt;：此信息用于标识群集的位置，并可用于定义外部服务的最近端点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;clusterName&lt;/strong&gt;：如果我们想要为每个群集定义一个值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是一个具体的示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;{{/* Returns Horizontal Pod Autoscaler replicas for GraphQL&lt;span style=&#34;color:#75715e&#34;&gt;*/}}&lt;/span&gt;
{{- define &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;graphql.hpaReplicas&amp;#34;&lt;/span&gt; -}}
{{- if eq .Values.global.env &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;prod&amp;#34;&lt;/span&gt; }}
{{- if eq .Values.global.region &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;europe-west1&amp;#34;&lt;/span&gt; }}
&lt;span style=&#34;color:#66d9ef&#34;&gt;minReplicas&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;40&lt;/span&gt;
{{- else }}
&lt;span style=&#34;color:#66d9ef&#34;&gt;minReplicas&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;150&lt;/span&gt;
{{- end }}
&lt;span style=&#34;color:#66d9ef&#34;&gt;maxReplicas&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;1400&lt;/span&gt;
{{- else }}
&lt;span style=&#34;color:#66d9ef&#34;&gt;minReplicas&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;maxReplicas&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;
{{- end }}
{{- end -}}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;请注意，此逻辑在帮助模板中定义，以保持 Kubernetes YAML 的可读性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;声明应用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们的部署工具基于几个 YAML 文件，下面是我们声明服务及其每个集群的扩展拓扑（副本数量）的示例。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;releases&lt;/span&gt;:
  - foo.world
 
&lt;span style=&#34;color:#66d9ef&#34;&gt;foo.world&lt;/span&gt;:                &lt;span style=&#34;color:#75715e&#34;&gt;# Release name&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;services&lt;/span&gt;:               &lt;span style=&#34;color:#75715e&#34;&gt;# List of dailymotion&amp;#39;s apps/projects&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;foobar&lt;/span&gt;:
      &lt;span style=&#34;color:#66d9ef&#34;&gt;chart_name&lt;/span&gt;: foo-foobar
      &lt;span style=&#34;color:#66d9ef&#34;&gt;repo&lt;/span&gt;: git@github.com:dailymotion/foobar
      &lt;span style=&#34;color:#66d9ef&#34;&gt;contexts&lt;/span&gt;:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;prod-europe-west1&lt;/span&gt;:
          &lt;span style=&#34;color:#66d9ef&#34;&gt;deployments&lt;/span&gt;:
            - &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: foo-bar-baz
              &lt;span style=&#34;color:#66d9ef&#34;&gt;replicas&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt;
            - &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: another-deployment
              &lt;span style=&#34;color:#66d9ef&#34;&gt;replicas&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;这是部署工作流的所有步骤，最后一步将在多个生产集群上同时部署应用程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/ad5fbf65gy1g50ldllp33j20mw0bxglz.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;secrets-怎么办&#34;&gt;Secrets 怎么办&lt;/h2&gt;
&lt;p&gt;在安全领域，我们专注于跟踪可能在不同位置传播的所有的 Secrets ，并将其存储在巴黎的 &lt;a href=&#34;https://www.vaultproject.io/&#34;&gt;Vault&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;我们的部署工具负责从 Vault 检索加密的值，并在部署时将其注入 Helm 。&lt;/p&gt;
&lt;p&gt;为此，我们定义了存储在 Vault 中的 Secrets 与我们的应用程序所需的 Secrets 之间的映射，如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;secrets&lt;/span&gt;: 
     - &lt;span style=&#34;color:#66d9ef&#34;&gt;secret_id&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;stack1-app1-password&amp;#34;&lt;/span&gt;
       &lt;span style=&#34;color:#66d9ef&#34;&gt;contexts&lt;/span&gt;:
         - &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;default&amp;#34;&lt;/span&gt;
           &lt;span style=&#34;color:#66d9ef&#34;&gt;vaultPath&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/kv/dev/stack1/app1/test&amp;#34;&lt;/span&gt;
           &lt;span style=&#34;color:#66d9ef&#34;&gt;vaultKey&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt;
         - &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cluster1&amp;#34;&lt;/span&gt;
           &lt;span style=&#34;color:#66d9ef&#34;&gt;vaultPath&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/kv/dev/stack1/app1/test&amp;#34;&lt;/span&gt;
           &lt;span style=&#34;color:#66d9ef&#34;&gt;vaultKey&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;定义将 Secrets 写入 Vault 时要遵循的通用规则。&lt;/li&gt;
&lt;li&gt;如果 Secrets 有特定的上下文/集群，则必须添加特定条目。&lt;/li&gt;
&lt;li&gt;否则，将使用默认值。&lt;/li&gt;
&lt;li&gt;对于此列表中的每个项目，将在 Kubernetes Secrets 中插入一个 key/value 。这样我们 chart 中的 Secrets 模板非常简单。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;apiVersion&lt;/span&gt;: v1
&lt;span style=&#34;color:#66d9ef&#34;&gt;data&lt;/span&gt;:
{{- range $key,$value := .Values.secrets }}
  {{ &lt;span style=&#34;color:#66d9ef&#34;&gt;$key }}&lt;/span&gt;: {{ $value | b64enc | quote }}
{{ end }}
&lt;span style=&#34;color:#66d9ef&#34;&gt;kind&lt;/span&gt;: Secret
&lt;span style=&#34;color:#66d9ef&#34;&gt;metadata&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{{ .Chart.Name }}&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;labels&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;chartVersion&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{{ .Chart.Version }}&amp;#34;&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;tillerVersion&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{{ .Capabilities.TillerVersion.SemVer }}&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt;: Opaque
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;警告与限制&#34;&gt;警告与限制&lt;/h2&gt;
&lt;h2 id=&#34;preview_only-false-1&#34;&gt;image:
caption: &amp;ldquo;Image from: &lt;a href=&#34;https://www.pexels.com&#34;&gt;&lt;strong&gt;Pexels&lt;/strong&gt;&lt;/a&gt;&amp;rdquo;
focal_point: &amp;quot;&amp;rdquo;
preview_only: false&lt;/h2&gt;
&lt;h3 id=&#34;操作多个存储库&#34;&gt;操作多个存储库&lt;/h3&gt;
&lt;p&gt;目前，chart 和应用程序开发是分离的。这意味着开发人员必须处理两个 git 存储库，一个用于应用程序，另一个用于定义如何在 Kubernetes 上部署。而2个 git 存储库意味着两个工作流程，这对于新手来说可能相当复杂。&lt;/p&gt;
&lt;h3 id=&#34;管理-umbrella-charts-可能很棘手&#34;&gt;管理 umbrella charts 可能很棘手&lt;/h3&gt;
&lt;p&gt;如前所述，umbrella charts 非常适合定义依赖关系并快速部署多个应用程序。同时我们使用 &lt;code&gt;--reuse-values&lt;/code&gt; 选项，以避免每次部署作为 umbrella charts 一部分的应用程序时都要传递所有值。&lt;/p&gt;
&lt;p&gt;在我们的 CD 工作流中，只有2个值会定期更改：副本数量和镜像标签（版本）。对于其他更稳定的值，需要手动更新，而且这些值并不是很容易弄清楚。此外，我们曾遇到过部署 umbrella charts 的一个错误导致严重的中断。&lt;/p&gt;
&lt;h3 id=&#34;更新多个配置文件&#34;&gt;更新多个配置文件&lt;/h3&gt;
&lt;p&gt;添加新应用程序时，开发人员必须更改多个文件：应用程序声明， Secrets 列表，如果应用程序是 umbrella charts 的一部分，则将其添加到依赖。&lt;/p&gt;
&lt;h3 id=&#34;在-vault-上-jenkins-权限过大&#34;&gt;在 Vault 上， Jenkins 权限过大&lt;/h3&gt;
&lt;p&gt;目前，我们有一个 &lt;a href=&#34;https://www.vaultproject.io/docs/auth/approle.html&#34;&gt;AppRole&lt;/a&gt; 可以读取 Vault 的所有 Secrets 。&lt;/p&gt;
&lt;h3 id=&#34;回滚过程不是自动化的&#34;&gt;回滚过程不是自动化的&lt;/h3&gt;
&lt;p&gt;回滚需要在多个集群上运行该命令，这可能容易出错。我们制作本操作手册是因为我们要确保应用正确的版本 ID 。&lt;/p&gt;
&lt;h2 id=&#34;gitops-实践&#34;&gt;GitOps 实践&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;目标&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们的想法是将 chart 放回到它部署的应用程序的存储库下。工作流程与应用同时开发，例如，无论何时在主服务器上合并分支，都会自动触发部署。这种方法与当前工作流程的主要区别在于，所有内容都将通过 git 进行管理（应用程序本身以及我们在 Kubernetes 中部署它的方式）。&lt;/p&gt;
&lt;p&gt;这样做优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从开发人员的角度来看，更容易理解。学习如何在本地 chart 中应用更改将更容易。&lt;/li&gt;
&lt;li&gt;将服务 deployment 定义在与此服务的代码相同的位置。&lt;/li&gt;
&lt;li&gt;移除 umbrella charts 管理。服务将拥有自己的 Helm 版本。这使得应用程序生命周期管理（回滚，升级）形成闭环，不会影响其他服务。&lt;/li&gt;
&lt;li&gt;git 功能对 chart 管理的好处：回滚，审计日志&amp;hellip;&amp;hellip;如果要还原 chart 更改，可以使用 git 进行更改。同时部署将自动触发。&lt;/li&gt;
&lt;li&gt;我们考虑使用 Skaffold 等工具改进开发工作流程，这些工具允许开发人员在类似于生产的环境中测试他们的更改。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;2步迁移&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们的开发人员已使用上述工作流程2年，因此我们需要尽可能顺利地进行迁移。这就是为什么我们决定在达到目标之前添加一个中间步骤。&lt;/p&gt;
&lt;p&gt;第一步很简单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们将保留一个类似的结构来配置我们的应用程序部署，但是在名为 “DailymotionRelease” 的单个对象中&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;apiVersion&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;v1&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;kind&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;DailymotionRelease&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;metadata&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;app1.ns1&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;environment&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;dev&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;branch&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;mybranch&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;spec&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;slack_channel&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;#admin&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;chart_name&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;app1&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;scaling&lt;/span&gt;:
    - &lt;span style=&#34;color:#66d9ef&#34;&gt;context&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;dev-us-central1-0&amp;#34;&lt;/span&gt;
      &lt;span style=&#34;color:#66d9ef&#34;&gt;replicas&lt;/span&gt;:
        - &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hermes&amp;#34;&lt;/span&gt;
          &lt;span style=&#34;color:#66d9ef&#34;&gt;count&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
    - &lt;span style=&#34;color:#66d9ef&#34;&gt;context&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;dev-europe-west1-0&amp;#34;&lt;/span&gt;
      &lt;span style=&#34;color:#66d9ef&#34;&gt;replicas&lt;/span&gt;:
        - &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;app1-deploy&amp;#34;&lt;/span&gt;
          &lt;span style=&#34;color:#66d9ef&#34;&gt;count&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;secrets&lt;/span&gt;:
    - &lt;span style=&#34;color:#66d9ef&#34;&gt;secret_id&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;app1&amp;#34;&lt;/span&gt;
      &lt;span style=&#34;color:#66d9ef&#34;&gt;contexts&lt;/span&gt;:
        - &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;default&amp;#34;&lt;/span&gt;
          &lt;span style=&#34;color:#66d9ef&#34;&gt;vaultPath&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/kv/dev/ns1/app1/test&amp;#34;&lt;/span&gt;
          &lt;span style=&#34;color:#66d9ef&#34;&gt;vaultKey&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt;
        - &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;dev-europe-west1-0&amp;#34;&lt;/span&gt;
          &lt;span style=&#34;color:#66d9ef&#34;&gt;vaultPath&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/kv/dev/ns1/app1/test&amp;#34;&lt;/span&gt;
          &lt;span style=&#34;color:#66d9ef&#34;&gt;vaultKey&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;每个应用程序一个版本（不再使用 umbrella charts ）&lt;/li&gt;
&lt;li&gt;将 chart 加入应用程序 git 存储库中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们已经开始向所有开发人员科普这个词，并且迁移过程已经开始。第一步仍然使用 CI 平台进行控制。我将在短期内撰写另一篇博文，介绍第二步：我们如何通过 &lt;a href=&#34;https://github.com/weaveworks/flux&#34;&gt;Flux&lt;/a&gt; 实现向 GitOps 工作流程的迁移。将描述我们的设置和面临的挑战（多个存储库，Secrets 等）。 敬请期待！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【转】Kubernetes 儿童插图指南</title>
      <link>https://guoxudong.io/post/the-childrens-illustrated-guide-to-kubernetes/</link>
      <pubDate>Fri, 05 Jul 2019 09:50:58 +0800</pubDate>
      
      <guid>https://guoxudong.io/post/the-childrens-illustrated-guide-to-kubernetes/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;转自掘金社区，原文地址：https://juejin.im/post/5d1b2a656fb9a07edc0b7058&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;kubernetes-儿童插图指南&#34;&gt;Kubernetes 儿童插图指南&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://ws4.sinaimg.cn/large/ad5fbf65gy1g4nwsdbr8wj20qo0hs0w2.jpg&#34; alt=&#34;&#34;&gt;
&lt;img src=&#34;https://wx3.sinaimg.cn/large/ad5fbf65gy1g4nwt5keovj210u0shmyc.jpg&#34; alt=&#34;&#34;&gt;
&lt;img src=&#34;https://wx4.sinaimg.cn/large/ad5fbf65gy1g4nwteb85hj20qo0hsk5v.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;献给所有试图向孩子们解释软件工程的家长。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/ad5fbf65gy1g4nwu2t40sj20qo0hswqv.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;很久很久以前，有一个叫 Phippy 的应用程序。她是一个简单的应用程序，由 PHP 编写且只有一个页面。她住在一个需要和其他可怕的应用程序分享环境的主机中，她不认识这些应用程序并且不愿意和他们来往。她希望她能拥有一个属于自己的环境：只有她自己和她可以称之为家的 Web 服务器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wx1.sinaimg.cn/large/ad5fbf65gy1g4nwutz6f2j20qo0hsq90.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;每个应用程序都有个运行所依赖的环境。对于 PHP 应用程序来说，这个环境可能包括 Web 服务器，一个可读文件系统和 PHP 引擎本身。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wx2.sinaimg.cn/large/ad5fbf65gy1g4nwvduq0mj20qo0hsdu8.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;有一天，一只善良的鲸鱼出现了。他建议小 Phippy 住在容器里，这样可能会更快乐。所以应用程序 Phippy 迁移到了容器中。这个容器很棒，但是……它有点像一个漂浮在大海中央的豪华起居室。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wx2.sinaimg.cn/large/ad5fbf65gy1g4nwwr0uk3j20qo0hs0zi.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;容器提供了一个独立的环境，应用程序可以在这个环境中运行。但是这些孤立的容器常常需要被管理并与外面的世界连接。对于孤立的容器而言，共享文件系统、网络通信、调度、负载均衡和分发都是要面对的挑战。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wx4.sinaimg.cn/large/ad5fbf65gy1g4nwx3kj32j20qo0hswr7.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;鲸鱼耸了耸肩。“对不起，孩子。”他说着，消失在海面下。就在 Phippy 甚至开始绝望时，一位驾驶着巨轮的船长出现在海平线上。这艘船由几十个绑在一起的木筏组成，但从外面来看，它就像一艘巨轮。
“你好呀，这位 PHP 应用程序朋友。我是 Kube 船长。”睿智的老船长说。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wx3.sinaimg.cn/large/ad5fbf65gy1g4nwxm9w44j20qo0hsn3b.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;“Kubernetes” 在希腊语中是船长的意思。我们可以从这个单词中得到 Cybernetic 和 Gubernatorial 这两个词组。Kubernetes 项目专注于构建一个健壮的平台，用于在生产环境中运行数千个容器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wx2.sinaimg.cn/large/ad5fbf65gy1g4nwxzqi7vj20qo0hsgxn.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;“我是 Phippy。”小应用程序说。&lt;/p&gt;
&lt;p&gt;“很高兴认识你。”船长一边说，一边在她身上贴上了一张标有姓名的标签。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wx3.sinaimg.cn/large/ad5fbf65gy1g4nwygks8xj20qo0hs0zy.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Kubernetes 使用标签作为“名牌”来标识事物。它可以根据这些标签进行查询。标签是开放性的：你可以用他们来表示角色、稳定性或其他重要的属性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/ad5fbf65gy1g4nwyt7gtqj20qo0hsdso.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;船长建议应用程序把她的容器搬到船上的一个船舱中。Phippy 很高兴地把她的容器搬到 Kube 船长巨轮的船舱内。Phippy 觉得这里像家一样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/ad5fbf65gy1g4nwzc5uqej20qo0hswlp.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在 Kubernetes 中，Pod 代表一个可运行的工作单元。通常，你会在 Pod 中运行一个容器。但是对于一些容器紧密耦合的情况，你可以选择在同一个 Pod 中运行多个容器。Kubernetes 负责将你的 Pod 和网络以及 Kubernetes 的其余环境相连。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wx2.sinaimg.cn/large/ad5fbf65gy1g4nwztzwfsj20qo0hsqdi.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Phippy 有一些不同寻常的兴趣，她很喜欢遗传学和绵羊。所以她问船长：“如果我想克隆我自己，是否可以根据需求克隆任意次数呢？”&lt;/p&gt;
&lt;p&gt;“这很容易。”船长说。船长把 Phippy 介绍给了 Replication Controller。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ws4.sinaimg.cn/large/ad5fbf65gy1g4nx08r8toj20qo0hsdnl.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Replication Controller 提供一种管理任意数量 Pod 的方法。一个 Replication Controller 包含一个 Pod 模板，该模板可以被复制任意次数。通过 Replication Controller，Kubernetes 将管理 Pod 的生命周期，包括伸缩、滚动更新和监控。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wx2.sinaimg.cn/large/ad5fbf65gy1g4nx0phj56j20qo0hsnb3.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;无数个日夜，小应用程序在她的船舱中与她的复制品相处十分愉快。但与自己为伍并没有所说的那么好……即使你拥有 N 个自己的克隆体。
Kube 船长慈祥地笑了笑：“我正好有一样东西。”
他刚开口，在 Phippy 的 Replication Controller 和船的其他部分之间打开了一条隧道。Kube 船长笑着说：“即使你的复制品来了又去，这条隧道始终会留在这里，你可以通过它发现其他 Pod，其他 Pod 也可以发现你！”&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ws2.sinaimg.cn/large/ad5fbf65gy1g4nx160hjkj20qo0hsjyp.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;服务告知 Kubernetes 环境的其余部分（包括其他 Pod 和 Replication Controller）你的应用程序包含了哪些服务，当 Pod 来来往往，服务的 IP 地址和端口始终保持不变。其他应用程序可以通过 Kurbenetes 服务发现找到你的服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wx2.sinaimg.cn/large/ad5fbf65gy1g4nx1kbahcj20qo0hsk2e.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;多亏了这些服务，Phippy 开始探索船的其他部分。不久之后，Phippy 遇到了 Goldie。他们成了最好的朋友。有一天，Goldie 做了一件不同寻常的事。她送给 Phippy 一件礼物。Phippy 看了礼物一眼，悲伤的泪水夺眶而出。
“你为什么这么伤心呢？”Goldie 问道。
“我喜欢这个礼物，但我没有地方可以放它！”Phippy 抽噎道。
但 Goldie 知道该怎么做。“为什么不把它放入卷中呢？”&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ws4.sinaimg.cn/large/ad5fbf65gy1g4nx2ibi95j20qo0hsdnp.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;卷表示容器可以访问和存储信息的位置。对于应用程序，卷显示为本地文件系统的一部分。但卷可以由本地存储、Ceph、Gluster、持久性块存储，以及其他存储后端支持。
Phippy 喜欢在 Kube 船长的船上生活，她很享受来自新朋友的陪伴（Goldie 的每个克隆人都同样令人愉悦）。但是，当她回想起在可怕的主机度过的日子，她想知道她是否也可以拥有一点自己的隐私。
“这听起来像是你所需要的，”Kube 船长说，“这是一个命名空间。”&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ws2.sinaimg.cn/large/ad5fbf65gy1g4nx2nyz4uj20qo0hs10l.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;命名空间是 Kubernetes 内部的分组机制。服务、Pod、Replication Controller 和卷可以在命名空间内部轻松协作，但命名空间提供了与集群其他部分一定程度的隔离。
Phippy 与她的新朋友一起乘坐 Kube 船长的巨轮航行于大海之上。她经历了许多伟大的冒险，但最重要的是，Phippy 找到了自己的家。
所以 Phippy 从此过上了幸福的生活。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ws2.sinaimg.cn/large/ad5fbf65gy1g4nx34vepkj21120shwek.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>什么是 DevOps ？DevOps 是如何工作的？</title>
      <link>https://guoxudong.io/post/all-about-devops-fundamentalsyou-ever-wanted-to-know/</link>
      <pubDate>Thu, 09 May 2019 09:55:11 +0800</pubDate>
      
      <guid>https://guoxudong.io/post/all-about-devops-fundamentalsyou-ever-wanted-to-know/</guid>
      <description>&lt;p&gt;在当前的 IT 实践中，为了支持高效和快捷的软件开发，出现了巨大的转变：在单体应用的软件架构正在逐渐被微服务架构取代的情况下，开发、 QA 和运维团队为了摆脱了之前相互孤立的状况，开始相互关联并融合统一，我们将其称为DevOps。&lt;/p&gt;
&lt;p&gt;当今如果一个技术驱动型企业想要以客户为导向来进行快速的软件迭代，那么他们需要更快速的软件开发和交付周期。而这些需求直接导致了 DevOps 文化的核心 CI/CD 实践的诞生。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;CI 持续集成：一种专注于使发布更容易的软件开发实践。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;CD 持续交付：是持续集成的延伸，以确保您可以以可持续的方式快速向客户发布新的更改。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;早期整个 SDLC 都是线性和顺序的，这拉长了产品的发布周期。但随着快速变化的市场动态、激烈的竞争和多变的客户需求，这些都会导致公司无法继续使用原先开发流程。他们必须更贴近客户，需要不断创新以保持他们的参与。而 DevOps 为此提供了解决方案，并被技术驱动的公司广泛采用，用来改进其快速交付的流程和实践。&lt;/p&gt;
&lt;p&gt;那么让我们试着了解什么是 DevOps ？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DevOps 定义：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提到 DevOps 我经常引用 w.r.t 的话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;任何公司在学会使用最佳 DevOps 实践进行协作、统一和自动化所有开发和运维流程之前，都将无法扩展和维持。这是一种将每个人联系在一起实现共同目标的文化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是时候让所有团队成员与他们的部门密切合作，采用工具和实践来高效地交付软件产品。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://www.atlassian.com/devops&#34;&gt;Atlassian 将 DevOps 定义为&lt;/a&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;DevOps 是一组软件开发和运维团队之间的自动化流程实践，以便他们可以快速、可靠地构建，测试和发布软件。DevOps 的概念建立在为过去相对孤立的团队之间建立合作文化的基础上。其带来的好处包括更加可靠、更快的软件发布，快速解决关键问题的能力，以及更好地管理计划外的工作。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Amazon 将 DevOps 定义为：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;文化理念、实践和工具的结合，提高了团队的高速交付应用程序和服务的能力：与使用单体应用的软件开发架构管理流程的团队相比，以更快的速度开发和改进产品。这种速度使团队能够更好地为客户服务，并在市场竞争中占据有利地位。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Microsoft 以更简化的方式定义 DevOps：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;“DevOps 可以为我们的终端客户持续提供价值的人员，流程和产品的结合。”&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我认为 DevOps 的最佳解释为：它是一种文化，是一种将人放在首位团队理念，为他们提供适宜的环境，使他们能够蓬勃发展，因此无论他们属于什么部门，都可以通过明确的流程进行协作和沟通，从而实现目标。&lt;/p&gt;
&lt;h2 id=&#34;devops-是如何工作的&#34;&gt;DevOps 是如何工作的？&lt;/h2&gt;
&lt;p&gt;如上所述，DevOps 没有任何固定的规则和实践，但它更像是通过来自不同部门具有不同的技能的团队在一起以实现预期的结果的文化。那么它实际上是如何工作的，让我通过下图简要解释一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ws2.sinaimg.cn/large/ad5fbf65gy1g2v3dnchftj20jg065dgv.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;因此，开发人员，QA 和运维团队使用 CI/CD 实践来实现客户的预期目标。开发人员编写代码并将其提交到 GitHub 等源码控制工具。DevOps 工程师使用 CI 工具来提取代码，来进行自动化测试，并通过 CD 工具部署到处理生产或测试服务器。&lt;/p&gt;
&lt;p&gt;开发和运维人员一起工作，并使用各种工具进行 CI/CD 和监控，以快速响应客户需求并修复问题和错误。&lt;/p&gt;
&lt;h2 id=&#34;devops工具在devops周期的各个阶段&#34;&gt;DevOps工具在DevOps周期的各个阶段：&lt;/h2&gt;
&lt;p&gt;如下所示：
&lt;img src=&#34;https://ws2.sinaimg.cn/large/ad5fbf65gy1g2v3ukk6kzj20xc0e5dvj.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;DevOps 工程师可以使用多种工具在整个 DevOps 生命周期的每个阶段获取期望的结果。&lt;/p&gt;
&lt;h3 id=&#34;计划&#34;&gt;计划：&lt;/h3&gt;
&lt;p&gt;您可以使用 &lt;strong&gt;Jira&lt;/strong&gt; 或 &lt;strong&gt;Azure DevOps Board&lt;/strong&gt; 以敏捷方式管理和规划您的工作。&lt;/p&gt;
&lt;h3 id=&#34;开发&#34;&gt;开发：&lt;/h3&gt;
&lt;p&gt;对于代码管理， &lt;strong&gt;Git&lt;/strong&gt; 以分布式方式管理代码版本历史、分支、推送和拉取机制的首要工具。您还可以使用 &lt;strong&gt;Microsoft TFVC&lt;/strong&gt;（Team Foundation Version Control），这是一个集中版本控制系统。&lt;/p&gt;
&lt;h3 id=&#34;测试&#34;&gt;测试：&lt;/h3&gt;
&lt;p&gt;要进行自动化测试，您可以使用 &lt;strong&gt;Selenium&lt;/strong&gt; 、 &lt;strong&gt;JUnit&lt;/strong&gt; 和 &lt;strong&gt;Apache JMeter&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;集成&#34;&gt;集成：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Jenkins&lt;/strong&gt; 是目前最受欢迎的 CI 工具之一，它可以做到无缝地集成开发和运维流程。&lt;/p&gt;
&lt;p&gt;其他 CI 工具还有 &lt;strong&gt;Travis&lt;/strong&gt; ＆ &lt;strong&gt;Bamboo&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;部署和配置管理&#34;&gt;部署和配置管理：&lt;/h3&gt;
&lt;p&gt;Docker 是最受欢迎和广泛使用的持续部署工具之一。它也是软件容器化工具。&lt;/p&gt;
&lt;p&gt;其他部署和配置管理工具还有 &lt;strong&gt;Kubernetes&lt;/strong&gt; 、 &lt;strong&gt;Chef&lt;/strong&gt; 、&lt;strong&gt;Ansible&lt;/strong&gt; 和 &lt;strong&gt;Puppet&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Kubernetes 是一个开源容器管理（编排）工具。其容器管理职责包括容器部署，容器扩展和伸缩以及容器的负载均衡。&lt;/p&gt;
&lt;h3 id=&#34;监控&#34;&gt;监控：&lt;/h3&gt;
&lt;p&gt;将产品部署到正确的位置后，持续的监控就变得至关重要。 &lt;strong&gt;Nagios&lt;/strong&gt; 、 &lt;strong&gt;Splunk&lt;/strong&gt; 和 &lt;strong&gt;New Relics&lt;/strong&gt; 是广泛使用的持续监控工具。&lt;/p&gt;
&lt;h2 id=&#34;devops-最佳实践&#34;&gt;DevOps 最佳实践：&lt;/h2&gt;
&lt;p&gt;正如文章开头所讨论的那样，为了使技术驱动的公司变得更加以客户为导向，他们需要将自己从单体应用的软件开发实践转变为为客户发布产品的敏捷方式。让我们试着了解他们需要采用的最佳 DevOps实践：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;持续集成&lt;/li&gt;
&lt;li&gt;持续交付&lt;/li&gt;
&lt;li&gt;微服务&lt;/li&gt;
&lt;li&gt;基础设施即代码&lt;/li&gt;
&lt;li&gt;监控和日志&lt;/li&gt;
&lt;li&gt;沟通与协作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;让我简要解释一下&lt;/p&gt;
&lt;h3 id=&#34;1-持续集成&#34;&gt;1. 持续集成：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Amazon 将 CI 定义为：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DevOps 软件开发实践，开发人员定期将代码修改合并到中央存储库，然后运行自动构建和测试。持续集成通常是指软件发布过程的构建或集成阶段，并且需要自动化组件（例如，CI 或构建服务）。持续集成的目的是更快地发现和解决问题，提高软件质量，并减少验证和发布新软件更新所需的时间。&lt;/p&gt;
&lt;h3 id=&#34;2持续交付&#34;&gt;2.持续交付：&lt;/h3&gt;
&lt;p&gt;持续交付是一种软件开发实践，其中开发人员完成的任何代码更改都会自动为发布到生产环境做好准备。&lt;/p&gt;
&lt;p&gt;通过在构建阶段之后将所有的代码更改部署到测试环境或生产环境，持续交付可在持续集成时进行扩展。&lt;/p&gt;
&lt;h3 id=&#34;3-微服务敏捷开发的架构&#34;&gt;3. 微服务：敏捷开发的架构&lt;/h3&gt;
&lt;p&gt;这是一种新的软件设计方法，您可以将单个应用程序拆分为一组小型服务/模块。与单体应用架构将所有前端和后端代码库以及数据库都全部部署在同一个服务器地址中相比，基于微服务架构的应用程序被分解为服务，其中每个服务器都在其中运行使用基于 HTTP 的应用程序编程接口（API），通过定义良好的接口使自己与其他服务进行通信。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;按照 Amazon 的介绍：&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;微服务是围绕业务能力构建的; 每项服务的范围都是一个简单的用途。您可以使用不同的框架或编程语言来编写微服务并将它们作为单个服务或一组服务独立部署。&lt;/p&gt;
&lt;h3 id=&#34;4-基础设施即代码iac&#34;&gt;4. 基础设施即代码：IaC&lt;/h3&gt;
&lt;p&gt;是通过机器可读定义文件（代码库）管理和配置计算机数据中心的过程，而不是物理硬件配置或交互式配置工具。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wx1.sinaimg.cn/large/ad5fbf65gy1g2v5f38rbij20sg0g0764.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Amazon 定义 IaC 为：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作为使用代码和软件开发技术（例如版本控制和持续集成）来配置和管理基础架构的实践。云服务的 API 驱动模型使开发人员和系统管理员能够以编程方式大规模地与基础架构交互，而不需要手动设置和配置资源。&lt;/p&gt;
&lt;p&gt;因此，开发人员可以使用基于代码的工具与基础架构进行交互，使其更像应用程序。这使得可以使用标准化模式快速部署基础架构和服务器，使用最新的补丁和版本进行更新，或以副本的方式进行复制部署。&lt;/p&gt;
&lt;p&gt;传统的服务（生命周期）自动化和配置管理工具用于完成IaC。现在企业也在使用连续配置自动化工具或独立的 IaC 框架，例如 &lt;strong&gt;Microsoft 的 PowerShell DSC&lt;/strong&gt; 或 &lt;strong&gt;AWS CloudFormation&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;5-监控与日志&#34;&gt;5. 监控与日志&lt;/h3&gt;
&lt;p&gt;公司可以通过监控指标和日志，来了解其应用程序和基础架构的运行情况。APM（&lt;strong&gt;Application performance management&lt;/strong&gt; 应用程序性能管理）将 IT 指标转换为有意义的业务指标，致力于检测和诊断复杂的应用程序性能问题，以维持预期的服务等级。&lt;/p&gt;
&lt;p&gt;通过捕获、分类、分析应用程序和基础架构生成的数据和日志，团队可以了解更新是如何影响用户的，从而深入了解问题或报错的根本原因。&lt;/p&gt;
&lt;p&gt;wiki 中介绍：&lt;/p&gt;
&lt;p&gt;密切监控两组性能指标。第一组性能指标定义了应用程序终端用户所体验的性能。性能的一个示例是峰值负载下的平均响应时间，包括加载和响应时间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;负载是应用程序处理的事务量，例如，每秒事务数（tps）、每秒请求数、每秒页数。在没有被计算机的搜索、计算、传输等需求加载的情况下，大多数应用程序都足够快，这就是开发人员在开发过程中可能无法捕获性能问题的原因。&lt;/li&gt;
&lt;li&gt;响应时间是应用程序在此类负载下响应用户操作所需的时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;6-沟通与协作&#34;&gt;6. 沟通与协作&lt;/h3&gt;
&lt;p&gt;在我看来：&lt;/p&gt;
&lt;p&gt;团队中的 DevOps 作为一种实践取得成功，需要2个基本支柱：沟通和协作，才能非常有效地工作。如果没有这种感觉并理解紧密结合团队工作的重要性，那么采用 DevOps 最佳实践将非常困难。&lt;/p&gt;
&lt;p&gt;增加团队中的沟通和协作是 DevOps文化 的关键方面之一。有了这种文化，团队就会以良好的态度和动力聚集在一起，围绕信息共享建立强有力的文化规范，并通过沟通工具和应用促进沟通，使团队的所有部门能够更加紧密地协调共同的目标。&lt;/p&gt;
&lt;h2 id=&#34;为何选择devops它的好处是什么&#34;&gt;为何选择DevOps？它的好处是什么？&lt;/h2&gt;
&lt;p&gt;要了解 DevOps 提升的价值已经其如何被公司所采用：&lt;/p&gt;
&lt;p&gt;让我们看看由 veritis 带给您的以下信息图表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ws4.sinaimg.cn/large/ad5fbf65gy1g390lc1h7jj20rs2ffapj.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;以上给出的图表清楚地阐述了 DevOps 实践的主要好处：&lt;/p&gt;
&lt;h3 id=&#34;速度&#34;&gt;速度&lt;/h3&gt;
&lt;p&gt;DevOps 促进团队的高速开发，以便您可以更快地为客户进行创新，更好地适应不断变化的市场，并在推动业务成果方面提高效率。&lt;/p&gt;
&lt;h3 id=&#34;快速交付&#34;&gt;快速交付&lt;/h3&gt;
&lt;p&gt;通过基于 CI/CD 的 DevOps 文化，缩短了应用程序发布周期，允许更快的客户反馈和有意义的创新在团队内的蓬勃发展。您可以更快地发布新功能并修复错误，更快地响应客户的需求并建立竞争优势。&lt;/p&gt;
&lt;h3 id=&#34;可靠性&#34;&gt;可靠性&lt;/h3&gt;
&lt;p&gt;DevOps 使您能够通过持续集成和持续交付等实践不断提高您的软件质量，以测试每项变更的功能和安全性。这造就了可靠和经过测试的应用程序和强大的基础设施的开发。DevOps 持续监控和记录实践可以帮助您实时了解软件的性能。&lt;/p&gt;
&lt;h3 id=&#34;文化&#34;&gt;文化&lt;/h3&gt;
&lt;p&gt;DevOps 培养了一种伟大的工作文化，在其文化模式下建立更有效的团队，强调所有权和责任等价值观。&lt;/p&gt;
&lt;h3 id=&#34;安全&#34;&gt;安全&lt;/h3&gt;
&lt;p&gt;通过采用 DevOps 模型，组织可以使用基础架即代码和策略即代码，在不牺牲安全性的情况下大规模定义和跟踪合规性。他们可以在保持控制和合规性的同时快速进步。&lt;/p&gt;
&lt;h2 id=&#34;devops-的挑战&#34;&gt;DevOps 的挑战&lt;/h2&gt;
&lt;p&gt;在团队中实施 DevOps 文化并不容易。没有标准的规则可以参考，它更像是改变个人和团队的心态的游戏。这就像要求人们离开他们的舒适区。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“当你试图在团队中带来任何相当大的变化时，一开始可能看起来很难，但当你有足够大的意愿时，就会发生变化，并渐进达成目标。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此，让我们看看采用 DevOps 作为文化的一些常见挑战。&lt;/p&gt;
&lt;h3 id=&#34;1-dev-vs-ops-心态&#34;&gt;1. Dev Vs Ops 心态&lt;/h3&gt;
&lt;p&gt;由于长期的开发和运维团队一直在孤立地工作，完成不同的任务。所以他们经过精心调整，以不同的方式思考和行动。开发人员试图尽快创新并做出改变，运维人员则试图保持 100％ 的服务可用性。他们的目标和优先事项是不同的，所以如果我们必须将 DevOps 作为团队中的文化实践，那么如果他们的心态还是两个孤立的部分，那么 DevOps 必将黯然失色。&lt;/p&gt;
&lt;p&gt;DevOps 的实践就是将团队整合在一起，打破 IT 组织内部的孤岛。因此，将它们整合为统一单元以实现共同目标是任何公司在采用 DevOps 实践时需要克服的第一个障碍。&lt;/p&gt;
&lt;h3 id=&#34;2-从传统基础设施转向微服务架构&#34;&gt;2. 从传统基础设施转向微服务架构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://wx2.sinaimg.cn/large/ad5fbf65gy1g390r8z5r5j21fp0otjwk.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;多年来，这些公司一直存在遗留的基础设施，但如果他们必须快速创新，他们必须摆脱这种方法并采用更具可扩展性的微服务架构。将基础设施即代码与微服务一起使用是迈向持续创新未来的又一步。&lt;/p&gt;
&lt;p&gt;然而，将架构变为微服务架构系统存在很大的障碍。采用微服务架构需要采用最佳的 DevOps 实践以及 CI/CD 实践。这为团队带来了巨大的工作量和运维挑战，同时也增加了成本因素。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;确实，将开发与部署转变为现代的软件开发方案可能会很痛苦，但一旦采用就可以使您的团队变得更加高效与可扩展。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-开发和运维工具集的冲突&#34;&gt;3. 开发和运维工具集的冲突&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://ws2.sinaimg.cn/large/ad5fbf65gy1g390s7jogmj20p00egjsv.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;开发团队的目标和指标完全不同，因此他们可能需要一个运维团队可能不需要的工具集。因此，必须将两个团队聚集在一起，以了解他们两者可以合作的位置，并整合对他们两者都有意义的工具，并统一他们可以监控的目标和指标。&lt;/p&gt;
&lt;p&gt;一些团队可能不愿意使用传统工具，这些工具不仅技术上较差，而且由于兼容性问题也会降低整个基础架构的速度。因此，请确保正在使用的工具与公司的产品愿景保持一致。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;无论我们在公司方面与个人方面有多么不同，我们都必须摒弃差异并作为一个整体来实现客户需求和解决客户的问题。如果我们能够在我们团队的工作文化中吸收这种理念，那么 DevOps 将成为重视过程和收益的宝贵实践。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>8分钟入门 K8S</title>
      <link>https://guoxudong.io/post/an-8-minute-introduction-to-k8s/</link>
      <pubDate>Tue, 30 Apr 2019 13:38:12 +0800</pubDate>
      
      <guid>https://guoxudong.io/post/an-8-minute-introduction-to-k8s/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;读完 &lt;a href=&#34;https://www.amazon.com/Kubernetes-Running-Dive-Future-Infrastructure/dp/1491935677&#34;&gt;Kubernetes: Up and Running&lt;/a&gt; 后，我写下了这篇文章。旨在为那些认为文章 &lt;a href=&#34;https://blog.maoxianplay.com/posts/cant/&#34;&gt;TL;DR&lt;/a&gt; 的人进行一些总结，这同时也是一种强迫自己检查所阅读内容的好方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基于 Google &lt;a href=&#34;https://kubernetes.io/blog/2015/04/borg-predecessor-to-kubernetes/&#34;&gt;Borg&lt;/a&gt; 的开源系统 K8S( Kubernetes ) 是一个非常强大的容器编排调度系统。 其整个生态系统，包括：工具，模块，附加组件等，都是使用 Golang 语言编写的，这使得 K8S 及其周边生态系统基本上是面向 API 对象、运行速度非常快的二进制文件的集合，并且这些二进制文件都有很好的文档记录，易于编写和构建应用程序。&lt;/p&gt;
&lt;p&gt;在深入了解之前，我想先介绍一下 K8S 的竞争对手：ECS 、 Nomad 和 Mesos 。ECS 是 AWS 自己的业务编排解决方案，而最近 AWS 上也引入了一个托管的 K8S 系统 &amp;ndash; EKS 。两者都提供 &lt;a href=&#34;https://aws.amazon.com/fargate/&#34;&gt;FARGATE&lt;/a&gt; ，允许用户运行其应用并忽略其运行物理资源。&lt;/p&gt;
&lt;p&gt;K8S 作为一个开源系统，在采用量上毫无疑问是最大赢家，同时它也可以以托管形式在三个主要云提供商上提供服务。然而，它比其他系统更加复杂。K8S 可以处理几乎任何类型的容器化工作负载，但这并不意味着每个人都需要它。用户也可以选择其他解决方案，例如，单独部署在 AWS 上的互联网产品可以在生产环境很好的使用 ECS 而非 K8S。&lt;/p&gt;
&lt;p&gt;话虽如此，k8s也有其神奇之处 &amp;ndash; 它可以在任何地方部署，同时拥有一个活跃的社区和数百个核心开发人员，以及其广泛生态系统中的数千个其他开源贡献者。它快速、新颖、模块化和面向 API ，使其成为对于构建插件和服务非常友好的系统。&lt;/p&gt;
&lt;h2 id=&#34;话不多说这里把-k8s-分为的11个部分介绍&#34;&gt;话不多说，这里把 K8S 分为的11个部分介绍&lt;/h2&gt;
&lt;h3 id=&#34;1-pods&#34;&gt;1. Pods&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Pods&lt;/strong&gt; 是 K8S 中创建或部署的最小基本单位。一个 pod 可以由多个容器组成，这些容器将形成一个部署在单个节点上的单元。一个 pod 包含一个容器之间共享的 IP。在微服务中， pod 将是执行某些后端工作或提供传入请求的微服务的单个实例。&lt;/p&gt;
&lt;h3 id=&#34;2-nodes&#34;&gt;2. Nodes&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Node&lt;/strong&gt; 就是服务器。它们是 K8S 部署其 pod 的“裸机”（也可以是虚拟机）。Nodes 为 K8S 提供可用的群集资源，以保持数据，运行作业，维护工作负载和创建网络路由。&lt;/p&gt;
&lt;h3 id=&#34;3-labels--annotations&#34;&gt;3. Labels &amp;amp; Annotations&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Labels&lt;/strong&gt; 是 K8S 及其终端用户过滤和筛选系统中类似资源的方式，也是一个资源需要“访问”或与另一个资源关联的粘合剂。例如：一个 Service 想要开放 Deployment 的端口。无论是监控，记录，日志，测试，任何k8s资源都应添加 Labels 以供进一步检查。例如： &lt;code&gt;app=worker&lt;/code&gt; ，一个给系统中所有工作 pod 的标签，稍后可以使用 &lt;code&gt;kubectl&lt;/code&gt; 工具或 k8s api 使用 &lt;code&gt;--selector&lt;/code&gt; 字段进行选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Annotations&lt;/strong&gt; 与 Labels 非常类似，但是它通常以字符串的形式用于存储元数据，但他不能用于标识和选择对象，通常也不会被 Kubernetes 直接使用，其主要目的是方便工具或用户的阅读和查找等。&lt;/p&gt;
&lt;h3 id=&#34;4-服务发现&#34;&gt;4. 服务发现&lt;/h3&gt;
&lt;p&gt;作为编排调度器，控制不同工作负载的资源，K8S 管理 pods 、jobs 和其他任何需要网络通信的物理资源。 K8S 使用 &lt;a href=&#34;https://kubernetes.io/docs/concepts/overview/components/#etcd&#34;&gt;etcd&lt;/a&gt; 管理这些。 etcd 是 K8S 的“内部”数据库， Master 节点使用它来知道一切资源都在哪里。K8S 还为您的服务提供了实时的 “服务发现” - 所有 Pod 都使用的自定义 DNS 服务（CoreDNS），您可以通过解析其他服务的名称来获取其 IP 地址和端口。它不需要任何设置，在 K8S 集群中“开箱即用”。&lt;/p&gt;
&lt;h3 id=&#34;5-replicasets&#34;&gt;5. ReplicaSets&lt;/h3&gt;
&lt;p&gt;虽然 pod 运行任务，但通常单个实例是不够的。出于对冗余和负载处理的考虑，需要进行复制容器，即“弹性缩放”。K8S 使用 &lt;strong&gt;ReplicaSet&lt;/strong&gt; 来实现伸缩扩展。根据副本的数量来表示系统的期望状态，并且在任何给定时刻保持系统的当前状态。&lt;/p&gt;
&lt;p&gt;这也是配置自动扩展的地方，在系统负载高时创建新的副本，以及在不再需要这些资源来支持运行工作负载时减少扩展。简单的讲就是：少则增加，多增删除。&lt;/p&gt;
&lt;h3 id=&#34;6-daemonsets&#34;&gt;6. DaemonSets&lt;/h3&gt;
&lt;p&gt;有时，某些应用程序在每个节点上只需要一个实例。最好的例子就是像 &lt;a href=&#34;https://www.elastic.co/products/beats/filebeat&#34;&gt;FileBeat&lt;/a&gt; 这样的日志采集组件。为了让 agent 从节点上收集日志，它需要运行在所有节点上，但只需要一个实例即可。为了创建满足上面需求的的工作负载，K8S 使用 &lt;strong&gt;DaemonSets&lt;/strong&gt; 来完成这个工作。&lt;/p&gt;
&lt;h3 id=&#34;7-statefulsets&#34;&gt;7. StatefulSets&lt;/h3&gt;
&lt;p&gt;虽然大多数微服务都是无状态的应用程序，但是还是有一部分并不是。有状态的工作负载需要由某种可靠的磁盘卷来支持。虽然应用程序容器本身可以是不变的，并且可以用更新的版本或更健康的实例来替换它们，但是即使使用其他副本也是需要持久化的数据。为此，&lt;strong&gt;StatefulSets&lt;/strong&gt; 允许部署整个生命周期内需要运行在同一节点的应用程序。它还保留了它的 “名称” ; 容器内的 &lt;code&gt;hostname&lt;/code&gt; 和整个集群中服务发现的名称。一个包含3个 ZooKeeper 的 StatefulSet 可以命名为 &lt;code&gt;zk-1&lt;/code&gt; ，&lt;code&gt;zk-2&lt;/code&gt; 和 &lt;code&gt;zk-3&lt;/code&gt; 还可以扩展为包含其他成员，如 &lt;code&gt;zk-4&lt;/code&gt; ， &lt;code&gt;zk-5&lt;/code&gt; 等&amp;hellip; StatefulSets 还需要管理 PVC 。&lt;/p&gt;
&lt;h3 id=&#34;8-jobs&#34;&gt;8. Jobs&lt;/h3&gt;
&lt;p&gt;K8S 核心团队考察了绝大多数需要使用编排系统的应用程序。虽然大多数应用程序需要持续的正常运行时间来处理服务请求，例如 Web 服务，但有时也需要运行批量任务并在任务完成后进行清理。如果您愿意，可以使用小型无服务器环境。而在 K8S 中实现这一功能，可以使用 &lt;strong&gt;Job&lt;/strong&gt; 资源。Jobs 正是听起来的那样，一个工作负载容器来完成特定的工作，并在成功后被销毁。一个很好的例子是设置一组 worker ，从要处理和存储的队列中读取任务。一旦队列为空，直到下一批准备好进行处理，都不再需要启动 worker。&lt;/p&gt;
&lt;h3 id=&#34;9-configmaps--secrets&#34;&gt;9. ConfigMaps &amp;amp; Secrets&lt;/h3&gt;
&lt;p&gt;如果您还不熟悉 &lt;a href=&#34;https://12factor.net/&#34;&gt;Twelve-Factor App manifest&lt;/a&gt; 《&lt;a href=&#34;../12-factor&#34;&gt;十二要素应用&lt;/a&gt;》 ，可以点击链接了解一下。现代应用程序的一个关键概念是无环境，可通过注入的环境变量进行配置。应用程序应完全与其所在位置无关。&lt;strong&gt;ConfigMaps&lt;/strong&gt; 在 K8S 中实现这一重要概念。其本质上是环境变量的 key-value 列表，这些变量被传递给正在运行的工作负载以确定不同的 runtime 行为。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Secrets&lt;/strong&gt; 与 &lt;strong&gt;ConfigMaps&lt;/strong&gt; 类似，通过加密的方式防止密钥、密码、证书等敏感信息泄漏。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我个人认为在任何系统上使用密码的最佳选择是 Hashicorp 的 Vault 。请务必阅读我去年写的关于它的&lt;a href=&#34;https://medium.com/prodopsio/security-for-dummies-protecting-application-secrets-made-easy-5ef3f8b748f7&#34;&gt;文章&lt;/a&gt;，关于 Vault 可以为你的产品提供的功能，以及我的一位同事写的另一篇更具技术性的[文章](&lt;a href=&#34;https://medium.com/prodopsio/taking-your-hashicorp-vault-to-the-next-level-8549e7988b24&#34;&gt;https://medium.com/prodopsio/taking-your-hashicorp-vault-to-the-next-level-8549e7988b24&lt;/a&gt;）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;10-deployments&#34;&gt;10. Deployments&lt;/h3&gt;
&lt;p&gt;为了使新版本快速替换原有的应用程序，我们希望将构建、测试和发布在一块来实现 &lt;a href=&#34;https://www.ibm.com/developerworks/community/blogs/beingagile/entry/short_feedback_loops_everywhere?lang=en&#34;&gt;short feedback loops&lt;/a&gt; 。K8S 使用 Deployments 来不断部署新软件，Deployments 是一组用来描述特定运行工作负载的元数据。例如：发布新版本，bug 修复，甚至是回滚（这是k8s的另一个内部选项）。&lt;/p&gt;
&lt;p&gt;在 K8S 中部署软件有两个主要__策略__：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Replacement&lt;/strong&gt;：将使用新副本替换您的整个工作负载，整个过程需要强制停机。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;RollingUpdate&lt;/strong&gt;：k8s通过两种特定配置来实现使用新的 Pods 实例滚动更新：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;MaxAvailable&lt;/code&gt; ： 该设置表示在部署新版本时可用的工作负载的百分比（或确切数量），100％表示“我有2个容器，保持2个存活并在整个部署期间正常提供服务”。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MaxSurge&lt;/code&gt; ： 该设置表示升级期间总 Pod 数最多可以超出期望的百分比（或数量），100％表示“我有 X 个容器，再部署 X 个容器，然后开始推出旧容器”。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;11-storage&#34;&gt;11. Storage&lt;/h3&gt;
&lt;p&gt;K8S 在存储上添加了一层抽象，工作负载可以为不同的任务请求特定的存储，甚至可以管理持续的时间可以超过某个pod的生命周期。为了简短起见，我想向您介绍我最近发布的关于k8s存储的&lt;a href=&#34;https://medium.com/prodopsio/k8s-will-not-solve-your-storage-problems-5bda2e6180b5&#34;&gt;文章&lt;/a&gt;，特别是为什么它不能完全解决数据库部署等数据持久性要求。&lt;/p&gt;
&lt;h2 id=&#34;概念性理解&#34;&gt;概念性理解&lt;/h2&gt;
&lt;p&gt;K8S 是根据一些指导方向设计和开发的，考虑到社区的性质，每个特征、概念和想法都被内置于系统中。此外，终端用户会以某种方式使用该系统，作为一个开源和免费的系统，不属于任何人，你可以用它做任何你想要做的事。&lt;/p&gt;
&lt;p&gt;面向 API ：系统中的每个部分都以一种可通过记录良好且可操作的 API 进行交互的方式进行构建。核心开发人员确保作为终端用户的您可以进行更改，查询和更新，用来提供更好的用户体验。&lt;/p&gt;
&lt;p&gt;工具友好 ： 作为上面一点的衍生，K8S 是热衷于在其 API 周围创建工具的。它将自身做为一个原始平台，以可定制的方式构建，以供其他人使用，并进一步开发用于不同的工具。有些已经变得非常有名并被广泛使用，如 Spinnaker ，Istio 和许多其他功工具。&lt;/p&gt;
&lt;p&gt;声明性状态 ： 鼓励用户使用具有声明性描述的系统而不是命令式描述。这意味着系统的状态和组件最好被描述为在某种版本控制（如 git ）中管理的代码，而不会因为某一处手动更改也对整体有影响。这样，k8s更容易&lt;a href=&#34;https://en.wikipedia.org/wiki/Disaster_recovery&#34;&gt;灾难恢复&lt;/a&gt; ，易于在团队之间分享和传递。&lt;/p&gt;
&lt;h2 id=&#34;最后&#34;&gt;最后&lt;/h2&gt;
&lt;p&gt;本文试图将重点放在 K8S 的介绍和主要概念上，当然，K8S 还有其他非常重要的领域，比如物理系统构建模块，如 &lt;code&gt;kubelet&lt;/code&gt;， &lt;code&gt;kube-proxy&lt;/code&gt; ， &lt;code&gt;api-server&lt;/code&gt; 和终端操作工具：&lt;code&gt;kubectl&lt;/code&gt;。我将在下一篇文章中讨论以及介绍这些很酷的功能。&lt;/p&gt;
&lt;p&gt;原文地址： &lt;a href=&#34;https://medium.com/prodopsio/an-8-minute-introduction-to-k8s-94fda1fa5184&#34;&gt;https://medium.com/prodopsio/an-8-minute-introduction-to-k8s-94fda1fa5184&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>困难的 Kubernetes</title>
      <link>https://guoxudong.io/post/kubernetes-is-har/</link>
      <pubDate>Wed, 24 Apr 2019 10:18:46 +0800</pubDate>
      
      <guid>https://guoxudong.io/post/kubernetes-is-har/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;虽然 Kubernetes 赢得了容器之站，但是其仍然很难使用并且时长引起事故。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我想我应该给这篇文章做一点序言。 &lt;a href=&#34;https://kubernetes.io/&#34;&gt;kubernetes&lt;/a&gt; 为许多应用程序提供新的 runtime ，如果使用得当，它可以成为一个强大的工具，并且可以将您冲复杂的开发生命周期中解放出来。然而在过去的几年里，我看到很多人和公司都会搭建他们的 Kubernetes ，但常常只是处于测试阶段，从未进入到生产。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-是如何运作的&#34;&gt;Kubernetes 是如何运作的？&lt;/h2&gt;
&lt;p&gt;粗略的讲， Kubernetes 或者 K8S 看起来十分简单。您运行的 Kubernetes 节点至少被分为两类：Master 和 Workers。Master 节点通常不运行任何真实的工作负载，那是 Workers 节点的工作。&lt;/p&gt;
&lt;p&gt;Kubernetes 的 Master 节点包含一个名叫 API server 的组件，其提供的 API 可以通过 &lt;code&gt;kubectl&lt;/code&gt; 调用。此外还包括一个 scheduler ，负责调度容器，决定容器运行在哪个节点。最后一个组件是 controller-manager ，它实际上是一组多个控制器，负责处理节点中断、复制、加入 services 和 pods ，并且处理授权相关内容。所有的数据都存储在 etcd 中，这是一个可信赖的分布式键值存储服务（包含一些非常酷的功能）。总而言之，Master 节点负责管理集群，这里没什么特别大的惊喜。&lt;/p&gt;
&lt;p&gt;另一方面， 真实的工作负载运行在 Worker 节点上。为此，它还包括许多组件。首先，Worker 节点上会运行 &lt;em&gt;&lt;strong&gt;kubelet&lt;/strong&gt;&lt;/em&gt; ，它是与该节点上的容器一起运行的 API ，负责与管控组件沟通，并按照管控组件指示管理 Worker 节点。另一个组件就是 &lt;em&gt;&lt;strong&gt;kube-proxy&lt;/strong&gt;&lt;/em&gt; ，其负责转发网络连接，根据您的配置运行容器。可能还有其他东西，如 &lt;em&gt;&lt;strong&gt;kube-dns&lt;/strong&gt;&lt;/em&gt; 或 &lt;em&gt;&lt;strong&gt;gVisor&lt;/strong&gt;&lt;/em&gt;。您还需要集成某种 &lt;em&gt;&lt;strong&gt;overlay network&lt;/strong&gt;&lt;/em&gt; 或底层网络设置，以便 Kubernetes 可以管理您的 pod 之间的网络。&lt;/p&gt;
&lt;p&gt;如果您想要一个更完整的概述，建议去看 Kelsey Hightowers 的 &lt;a href=&#34;https://github.com/kelseyhightower/kubernetes-the-hard-way&#34;&gt;Kubernetes  -  The Hard Way&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;生产就绪的-kubernetes&#34;&gt;生产就绪的 Kubernetes&lt;/h2&gt;
&lt;p&gt;到目前为止，这听起来并不太糟糕。只是安装几个程序、配置、证书等。不要误会我的意思，这仍然是一个学习曲线，但这也不是系统管理员不能处理的问题。&lt;/p&gt;
&lt;p&gt;然而，简单地手动安装 Kubernetes 并不代表其已经完全准备就绪，所以让我们谈谈让这个东西运行起来所需的步骤。&lt;/p&gt;
&lt;p&gt;首先，&lt;strong&gt;安装&lt;/strong&gt;。如果您想要某种自动安装，无论是使用 Ansible ， Terraform 还是其他工具。&lt;a href=&#34;https://github.com/kubernetes/kops&#34;&gt;kops&lt;/a&gt; 可以帮助您解决这个问题，但是使用 kops 意味着您将不知道它是如何设置的，并且当您以后想要调试某些东西时可能会引起一些其他问题。应对此自动化进行测试，并定期进行检查。&lt;/p&gt;
&lt;p&gt;其次，您需要&lt;strong&gt;监控&lt;/strong&gt;您的 Kubernetes 安装。所以您需要 &lt;a href=&#34;https://prometheus.io/&#34;&gt;Prometheus&lt;/a&gt; 、 &lt;a href=&#34;https://grafana.com/&#34;&gt;Grafana&lt;/a&gt; 等工具。您是在 Kubernetes 里面运行它吗？ 如果您的 Kubernetes 有问题，那么您的监控是否会也会挂掉？ 或者您单独运行它？ 如果是，那么您在哪里运行它？&lt;/p&gt;
&lt;p&gt;另外值得注意的是&lt;strong&gt;备份&lt;/strong&gt;。如果您的 Master 崩溃，数据无法恢复并且您需要重新配置系统上的所有 pod ，您会怎么做？您是否测试了再次运行 CI 系统中所有作业所需的时间？您有灾难恢复计划吗？&lt;/p&gt;
&lt;p&gt;现在，既然我们在谈论 CI 系统，那么您需要为您的镜像运行 Docker 镜像仓库。当然，您可以再次在 Kubernetes 上做，但如果 Kubernetes 崩溃&amp;hellip;&amp;hellip;您知道这个后果。当然，CI 系统与运行版本控制系统都有这个问题。理想情况下，这些系统是与生产环境隔离的，以便在系统出现问题时，至少可以访问 git ，来进行重新部署等操作。&lt;/p&gt;
&lt;h2 id=&#34;数据存储&#34;&gt;数据存储&lt;/h2&gt;
&lt;p&gt;最后，我们来谈谈最重要的部分：存储。Kubernetes 本身并不提供存储解决方案。当然，您可以将存储挂载到主机安装目录，但这既不推荐也不简单。&lt;/p&gt;
&lt;p&gt;基本上需要在 Kubernetes 下使用某种存储。例如，&lt;a href=&#34;https://rook.io/&#34;&gt;rook&lt;/a&gt; 使得运行 &lt;a href=&#34;https://ceph.com/&#34;&gt;Ceph&lt;/a&gt; 作为底层块存储需求的变得相对简单，但我对 Ceph 的体验是它还有有很多地方需要调整，所以您绝不是只需点击下一步就能走出困境。&lt;/p&gt;
&lt;h2 id=&#34;调试&#34;&gt;调试&lt;/h2&gt;
&lt;p&gt;在与开发人员谈论 Kubernetes 时，一种常见的回答经常出现：在使用 Kubernetes 时，人们常常在调试应用程序时遇到问题。即使是一个例如容器未能启动的简单问题，也会引起混乱。&lt;/p&gt;
&lt;p&gt;当然，这是一个教育问题。在过去的几十年中，开发人员已经学会了调试的“经典”步骤：在 &lt;code&gt;/vat/log/&lt;/code&gt; 中查看日志等。但是对于容器，我们甚至不知道容器运行在哪个服务器上，因此它呈现出了一种范式转换。&lt;/p&gt;
&lt;h2 id=&#34;问题复杂&#34;&gt;问题：复杂&lt;/h2&gt;
&lt;p&gt;您可能已经注意到我正在跳过共有云提供商给您的东西，即使它不是一个完整的托管 Kubernetes。当然，如果您使用托管的 Kubernetes 解决方案，这很好，除了调试之外，您不需要处理上面这些问题。&lt;/p&gt;
&lt;p&gt;Kubernetes 拥有许多可以移动组件，但 Kubernetes 本身也并不能提供完整的解决方案。例如，&lt;a href=&#34;https://www.openshift.com/&#34;&gt;RedHat OpenShift&lt;/a&gt; 可以，但它需要花钱，并且仍然需要添加自己的东西。&lt;/p&gt;
&lt;p&gt;现在Kubernetes正处于 &lt;a href=&#34;https://www.gartner.com/en/research/methodologies/gartner-hype-cycle&#34;&gt;Gartner hype cycle&lt;/a&gt; 的顶峰，每个人都想要它，但很少有人真正理解它。在接下来的几年里，不少公司必须意识到 Kubernetes 并不是银弹，而如何正确有效地使用它才是关键。&lt;/p&gt;
&lt;p&gt;我认为，如果您有能力将 Ops 团队专门用于为开发人员来维护底层平台，那么运行自己的 Kubernetes 是值得的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文作者：&lt;a href=&#34;https://pasztor.at/&#34;&gt;Janos Pasztor&lt;/a&gt;  2018-12-04&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原文地址：https://pasztor.at/blog/kubernetes-is-hard&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>什么的容器？Docker 工作原理及容器化简易指南</title>
      <link>https://guoxudong.io/post/what-are-containers-a-simple-guide-to-containerization-and-how-docker-works/</link>
      <pubDate>Sat, 20 Apr 2019 19:54:50 +0800</pubDate>
      
      <guid>https://guoxudong.io/post/what-are-containers-a-simple-guide-to-containerization-and-how-docker-works/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Docker 非常棒！&lt;/strong&gt; 它使软件开发者无需担心配置和依赖性，在任何地方打包，发送和运行他们的应用程序。而在与 kubernetes 相结合后，它使应用集群部署和管理变得更方便。这使得 Docker 深受软件开发者的喜爱，越来越多的开发者开始使用 Docker。&lt;/p&gt;
&lt;p&gt;那么 Docker 到底是什么？&lt;/p&gt;
&lt;p&gt;它是构建、测试、部署和发布&lt;strong&gt;容器化&lt;/strong&gt;应用的&lt;strong&gt;平台&lt;/strong&gt;。称其为平台是因为 Docker 其实是一套用于管理与容器相关的所有事物的工具。作为 Docker 的核心，接下来我们将深入探讨容器。&lt;/p&gt;
&lt;h2 id=&#34;什么是容器&#34;&gt;什么是容器？&lt;/h2&gt;
&lt;p&gt;容器提供了在计算机上的隔离环境中安装和运行应用程序的方法。在容器内运行的应用程序仅可使用于为该容器分配的资源，例如：CPU，内存，磁盘，进程空间，用户，网络，卷等。在使用有限的容器资源的同时，并不与其他容器冲突。您可以将容器视为简易计算机上运行应用程序的隔离沙箱。&lt;/p&gt;
&lt;p&gt;这个概念听起来很熟悉，有些类似于虚拟机。但它们有一个关键的区别：容器使用的一种非常不同的，轻量的技术来实现资源隔离。容器利用了底层 Linux 内核的功能，而不是虚拟机采用的  &lt;a href=&#34;https://en.wikipedia.org/wiki/Hypervisor&#34;&gt;hypervisor&lt;/a&gt; 的方法。换句话说，容器调用 Linux 命令来分配和隔离出一组资源，然后在此空间中运行您的应用程序。我们快速来看下两个这样的功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;namespaces&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单的讲就是，&lt;a href=&#34;http://man7.org/linux/man-pages/man7/namespaces.7.html&#34;&gt;Linux namespace&lt;/a&gt; 允许用户在独立进程之间隔离 CPU 等资源。进程的访问权限及可见性仅限于其所在的 namespaces 。因此，用户无需担心在一个 namespace 内运行的进程与在另一个 namespace 内运行的进程冲突。甚至可以同一台机器上的不同容器中运行具有相同 PID 的进程。同样的，两个不同容器中的应用程序可以使用相同的端口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;cgroups&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://man7.org/linux/man-pages/man7/cgroups.7.html&#34;&gt;cgroups&lt;/a&gt; 允许对可用资源设置限制和约束。例如，您可以在一台拥有 16G 内存的计算机上创建一个 namespace ，限制其内部进程可用内存为 1GB。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;到这，您可能已经猜到 Docker 的工作原理了。当您请求 Docker 运行容器时，Docker 会在您的计算机上设置一个资源隔离的环境。然后 Docker 会将打包的应用程序和关联的文件复制到 namespace 内的文件系统中，此时环境的配置就完成了。之后 Docker 会执行您指定的命令运行应用程序。&lt;/p&gt;
&lt;p&gt;简而言之，Docker 通过使用 Linux namespace 和 cgroup（以及其他一些命令）来协调配置容器，将应用程序文件复制到为容器分配的磁盘，然后运行启动命令。Docker 还附带了许多其他用于管理容器的工具，例如：列出正在运行的容器，停止容器，发布容器镜像等许多其他工具。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://wx4.sinaimg.cn/large/ad5fbf65gy1g2a8h1rc6lj211a0rcjsu.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;p&gt;与虚拟机相比，容器更轻量且速度更快，因为它利用了 Linux 底层操作系统在隔离的环境中运行。虚拟机的 hypervisor 创建了一个非常牢固的边界，以防止应用程序突破它，而&lt;a href=&#34;https://sysdig.com/blog/container-isolation-gone-wrong/&#34;&gt;容器的边界不那么强大&lt;/a&gt;。另一个区别是，由于 namespace 和 cgroups 功能仅在 Linux 上可用，因此容器无法在其他操作系统上运行。此时您可能想知道 Docker 如何在 macOS 或 Windows 上运行？ Docker 实际上使用了一个技巧，并在非 Linux 操作系统上安装 Linux 虚拟机，然后在虚拟机内运行容器。&lt;/p&gt;
&lt;p&gt;让我们利用目前为止学到的所有内容，从头开始创建和运行 Docker 容器。如果你还没有将 Docker 安装在你的机器上，可以参考&lt;a href=&#34;https://docs.docker.com/install/&#34;&gt;这里&lt;/a&gt;安装 Docker 。在这个示例中，我们将创建一个 Docker 容器，下载一个用 C语言 写的 Web 服务，编译并运行它，然后使用浏览器访问这个 Web 服务。&lt;/p&gt;
&lt;p&gt;我们将从所有 Docker 项目开始的地方：创建一个 &lt;code&gt;Dockerfile&lt;/code&gt; 开始。此文件描述了如何创建用于运行容器的 docker 镜像。既然我们还没有聊到镜像，那么让我们看一下&lt;a href=&#34;https://docs.docker.com/get-started/#images-and-containers&#34;&gt;镜像的官方定义&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;镜像是一个可执行包，其包含运行应用程序所需的代码、运行时、库、环境变量和配置文件，容器是镜像的运行时实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单的讲，当你要求 Docker 运行一个容器时，你必须给它一个包含如下内容的镜像：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;包含应用程序及其所有依赖的&lt;strong&gt;文件系统快照&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;容器启动时的运行命令。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 Docker 的世界，使用别人的镜像作为基础镜像来创建自己的镜像是十分普遍的。例如，官方 reds Docker 镜像就是基于 Debian 文件系统快照（&lt;a href=&#34;http://www.ethernetresearch.com/geekzone/building-linux-rootfs-from-scratch/&#34;&gt;rootfs tarball&lt;/a&gt;），并安装在其上配置 Redis。&lt;/p&gt;
&lt;p&gt;在我们的示例中，我们选择 &lt;a href=&#34;https://hub.docker.com/_/alpine&#34;&gt;Alpine Linux&lt;/a&gt; 为基础镜像。当您在 Docker 中看到 “alpine” 时，它通常意味着一个精简的基本镜像。 Alpine Linux 镜像大小只有约为5 MB！&lt;/p&gt;
&lt;p&gt;在您的计算机创建一个新目录（例如 &lt;code&gt;dockerprj&lt;/code&gt; ），然后新建一个 &lt;code&gt;Dockerfile&lt;/code&gt; 文件。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;umermansoor:dockerprj$ touch Dockerfile
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将如下内容粘贴到 &lt;code&gt;Dockerfile&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-docker&#34; data-lang=&#34;docker&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Use Alpine Linux rootfs tarball to base our image on&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; alpine:3.9 &lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Set the working directory to be &amp;#39;/home&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WORKDIR&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; &amp;#39;/home&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Setup our application on container&amp;#39;s file system&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;RUN&lt;/span&gt; wget http://www.cs.cmu.edu/afs/cs/academic/class/15213-s00/www/class28/tiny.c &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; apk add build-base &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; gcc tiny.c -o tiny &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Hello World&amp;#39;&lt;/span&gt; &amp;gt;&amp;gt; index.html&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Start the web server. This is container&amp;#39;s entry point&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CMD&lt;/span&gt; [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;./tiny&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;8082&amp;#34;&lt;/span&gt;]&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Expose port 8082&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;EXPOSE&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; 8082 &lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个 &lt;code&gt;Dockerfile&lt;/code&gt; 包含创建镜像的内容说明。我们创建镜像基于 Alpine Linux（&lt;a href=&#34;http://www.ethernetresearch.com/geekzone/building-linux-rootfs-from-scratch/&#34;&gt;rootfs tarball&lt;/a&gt;），并将工作目录设置为 &lt;code&gt;/home&lt;/code&gt; 。接下来下载，编译并创建了一个用C编写的简单 Web 服务器的可执行文件，然后指定在运行容器时要执行的命令，并将容器端口8082暴露给主机。&lt;/p&gt;
&lt;p&gt;现在，我们就可以构建镜像了。在 &lt;code&gt;Dockerfile&lt;/code&gt; 的同级目录运行 &lt;code&gt;docker build&lt;/code&gt; 命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;umermansoor:dockerprj$ docker build -t codeahoydocker .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果这个命令成功了，您将看到：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;Successfully tagged codeahoydocker:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此时我们的镜像就创建成功了，该镜像主要包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文件系统快照（Alpine Linux 和 我们安装的 Web 服务）&lt;/li&gt;
&lt;li&gt;启动命令（&lt;code&gt;./tiny 8092&lt;/code&gt;）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;http://wx4.sinaimg.cn/large/ad5fbf65gy1g2aakgpe16j20zo0bqjt5.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;p&gt;既然成功构建了镜像，那么我们可以使用如下命令运行容器。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;umermansoor:dockerprj$ docker run -p 8082:8082 codeahoydocker:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;让我们了解下这里发生了什么。&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;docker run&lt;/code&gt; 命令，我们请求 Docker 基于 &lt;code&gt;codeahoydocker:latest&lt;/code&gt; 镜像创建和启动一个容器。&lt;code&gt;-p 8082:8082&lt;/code&gt; 将本地的8082端口映射到容器的8082端口（容器内的 Web 服务器正在监听8082端口上的连接）。打开你的浏览器并访问 localhost:8082/index.html 。你将可以看到 &lt;em&gt;&lt;strong&gt;Hello World&lt;/strong&gt;&lt;/em&gt; 信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://wx4.sinaimg.cn/large/ad5fbf65gy1g2aazadeamj20yo0rcq5e.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;p&gt;最后我想补充一点，虽然 Docker 非常棒，而且对于大多数项目来说它是一个不错的选择，但我们并非处处都要使用它。在我的工作中，Docker 与 Kubernetes 结合使用，可以非常轻松地部署和管理后端微服务，我们不必为每个服务配置新的运行环境。另一方面，对于性能密集型应用程序，Docker 可能不是最佳选择。我经手的其中一个项目必须处理来自移动游戏客户端的 TCP 长连接（每台机器1000个），这时 Docker 网络出现了很多问题，导致无法将它用于该项目。&lt;/p&gt;
&lt;p&gt;希望上面这些内容有用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这篇文章由 &lt;a href=&#34;https://www.linkedin.com/in/umansoor&#34;&gt;Umer Mansoor&lt;/a&gt; 撰写，可以在 &lt;a href=&#34;https://www.facebook.com/codeahoy&#34;&gt;Facebook&lt;/a&gt; 或 &lt;a href=&#34;https://twitter.com/codeahoy&#34;&gt;Twitter&lt;/a&gt; 上关注并留下评论。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原文地址： &lt;a href=&#34;https://codeahoy.com/2019/04/12/what-are-containers-a-simple-guide-to-containerization-and-how-docker-works/&#34;&gt;https://codeahoy.com/2019/04/12/what-are-containers-a-simple-guide-to-containerization-and-how-docker-works/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kustomize: 无需模板定制你的 kubernetes 配置</title>
      <link>https://guoxudong.io/post/introducing-kustomize-template-free-configuration-customization-for-kubernetes/</link>
      <pubDate>Mon, 15 Apr 2019 17:23:21 +0800</pubDate>
      
      <guid>https://guoxudong.io/post/introducing-kustomize-template-free-configuration-customization-for-kubernetes/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;作者：Jeff Regan (Google), Phil Wittrock (Google) 2018-05-29&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你在运行 kubernetes 集群，你可能会拷贝一些包含 kubernetes API 对象的 YAML 文件，并且根据你的需求来修改这些文件，通过这些 YAML 文件来定义你的 kubernetes 配置。&lt;/p&gt;
&lt;p&gt;但是这种方法存在很难找到配置的源头并对其进行改进。今天 Google 宣布推出 &lt;strong&gt;Kustomize&lt;/strong&gt; ，一个作为 &lt;a href=&#34;https://github.com/kubernetes/community/tree/master/sig-cli&#34;&gt;SIG-CLI&lt;/a&gt; 子项目的命令行工具。这个工具提供了一个全新的、纯粹的声明式的方法来定制 kubernetes 配置，遵循并利用我们熟悉且精心设计的 Kubernetes API。&lt;/p&gt;
&lt;p&gt;有这样一个常见的场景，在互联网上可以看到别人的 CMS（content management system，内容管理系统）的 kubernetes 配置，这个配置是一组包括 Kubernetes API 对象的 YAML 描述文件。然后，在您自己公司的某个角落，您找到一个你非常了解的数据库，希望用它来该 CMS 的数据。&lt;/p&gt;
&lt;p&gt;你希望同时使用它们，此外，你希望自定义配置文件以便你的资源实例在集群中显示，并通过添加一个标签来区分在同一集群中做同样事情的其他资源。同时也希望为其配置适当的 CPU 、内存和副本数。&lt;/p&gt;
&lt;p&gt;此外，你还想要配置整个配置的多种变化：一个专门用于测试和实验的小服务实例（就计算资源而言），或更大的用于对外提供服务的生产级别的服务实例。同时，其他的团队也希望拥有他们自己的服务实例。&lt;/p&gt;
&lt;h2 id=&#34;定制就是复用&#34;&gt;定制就是复用&lt;/h2&gt;
&lt;p&gt;kubernetes 的配置并不是代码（是使用 YAML 描述的 API 对象，严格来说应该是数据），但是配置的生命周期与代码的生命周期有许多相似之处。&lt;/p&gt;
&lt;p&gt;你需要在版本控制中保留配置。所有者的配置不必与使用者的配置相同。配置可以作为整体的一部分。而用户希望为在不同的情况下复用这些配置。&lt;/p&gt;
&lt;p&gt;与代码复用相同，一种复用配置的方法是简单的全部拷贝并进行自定义。像代码一样，切断与源代码的联系使得从改进变的十分困难。许多团队和环境都使用这种方法，每个团队和环境都拥有自己的配置，这使得简单的升级变得十分棘手。&lt;/p&gt;
&lt;p&gt;另一种复用方法是将源代码抽象为参数化模板。使用一个通过执行脚本来替换所需参数的模板处理工具生成配置，通过为同一模板设置不同的值来达到复用的目的。而这种方式面临的问题是模板和参数文件并不在 kubernetes API 资源的规范中，这种方式必定是一种包装了 kubernetes API 的新东西、新语言。虽然这种方式很强大，但是也带来了学习成本和安装工具的成本。不同的团队需要不同的更改，因此几乎所有可以包含在 YAML 文件中的规范都会需要抽象成参数。&lt;/p&gt;
&lt;h2 id=&#34;自定义配置的新选择&#34;&gt;自定义配置的新选择&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;kustomize&lt;/strong&gt; 中工具的声明与规范是由名为 &lt;code&gt;kustomization.yaml&lt;/code&gt; 的文件定义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;kustomize&lt;/strong&gt; 将会读取声明文件和 Kubernetes API 资源文件，将其组合然后将完整的资源进行标准化的输出。输出的文本可以被其他工具进一步处理，或者直接通过 &lt;strong&gt;kubectl&lt;/strong&gt; 应用于集群。&lt;/p&gt;
&lt;p&gt;例如，如果 &lt;code&gt;kustomization.yaml&lt;/code&gt; 文件包括：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;commonLabels&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;app&lt;/span&gt;: hello
&lt;span style=&#34;color:#66d9ef&#34;&gt;resources&lt;/span&gt;:
- deployment.yaml
- configMap.yaml
- service.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;确保这三个文件与 &lt;code&gt;kustomization.yaml&lt;/code&gt; 位于同一目录下，然后运行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;kustomize build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将创建包含三个资源的 YAML 流，其中 &lt;code&gt;app: hello&lt;/code&gt; 为每个资源共同的标签。&lt;/p&gt;
&lt;p&gt;同样的，你可以使用 &lt;em&gt;&lt;strong&gt;commonAnnotations&lt;/strong&gt;&lt;/em&gt; 字段给所有资源添加注释， &lt;em&gt;&lt;strong&gt;namePrefix&lt;/strong&gt;&lt;/em&gt; 字段为所有的资源添加共同的前缀名。这些琐碎而有常见的定制只是一个开始。&lt;/p&gt;
&lt;p&gt;一个更常见的例子是，你需要为一组相同资源设置不同的参数。例如：开发、演示和生产的参数。&lt;/p&gt;
&lt;p&gt;为此，&lt;strong&gt;Kustomize&lt;/strong&gt; 允许用户以一个应用描述文件 （YAML 文件）为基础（Base YAML），然后通过 Overlay 的方式生成最终部署应用所需的描述文件。两者都是由 kustomization 文件表示。基础（Base）声明了共享的内容（资源和常见的资源配置），Overlay 则声明了差异。&lt;/p&gt;
&lt;p&gt;这里是一个目录树，用于管理集群应用程序的 &lt;em&gt;&lt;strong&gt;演示&lt;/strong&gt;&lt;/em&gt; 和 &lt;em&gt;&lt;strong&gt;生产&lt;/strong&gt;&lt;/em&gt; 配置参数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;someapp/
├── base/
│   ├── kustomization.yaml
│   ├── deployment.yaml
│   ├── configMap.yaml
│   └── service.yaml
└── overlays/
    ├── production/
    │   └── kustomization.yaml
    │   ├── replica_count.yaml
    └── staging/
        ├── kustomization.yaml
        └── cpu_count.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;someapp/base/kustomization.yaml&lt;/code&gt; 文件指定了公共资源和常见自定义配置（例如，它们一些相同的标签，名称前缀和注释）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;someapp/overlays/production/kustomization.yaml&lt;/code&gt; 文件的内容可能是：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;commonLabels&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;env&lt;/span&gt;: production
&lt;span style=&#34;color:#66d9ef&#34;&gt;bases&lt;/span&gt;:
- ../../base
&lt;span style=&#34;color:#66d9ef&#34;&gt;patches&lt;/span&gt;:
- replica_count.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个 kustomization 指定了一个 &lt;em&gt;&lt;strong&gt;patch&lt;/strong&gt;&lt;/em&gt; 文件 &lt;code&gt;replica_count.yaml&lt;/code&gt; ，其内容可能是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;apiVersion&lt;/span&gt;: apps/v1
&lt;span style=&#34;color:#66d9ef&#34;&gt;kind&lt;/span&gt;: Deployment
&lt;span style=&#34;color:#66d9ef&#34;&gt;metadata&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;name&lt;/span&gt;: the-deployment
&lt;span style=&#34;color:#66d9ef&#34;&gt;spec&lt;/span&gt;:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;replicas&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;patch&lt;/strong&gt;&lt;/em&gt; 是部分的资源声明，在这个例子中是 Deployment 的补丁 &lt;code&gt;someapp/base/deployment.yaml&lt;/code&gt; ，仅修改了副本数用以处理生产流量。&lt;/p&gt;
&lt;p&gt;该补丁不仅仅是一个无上下文 {parameter name，value} 元组。其作为部分 deployment spec，可以通过验证，即使与其余配置隔离读取，也具有明确的上下文和用途。&lt;/p&gt;
&lt;p&gt;要为生产环境创建资源，请运行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;kustomize build someapp/overlays/production
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行结果将作为一组完整资源打印到标准输出，并准备应用于集群。可以用类似的命令定义演示环境的配置。&lt;/p&gt;
&lt;h2 id=&#34;综上所述&#34;&gt;综上所述&lt;/h2&gt;
&lt;p&gt;使用 &lt;strong&gt;kustomize&lt;/strong&gt; ，您可以仅使用 Kubernetes API 资源文件就可以管理任意数量的 Kubernetes 定制配置。kustomize 的每个产物都是纯 YAML 的，每个都可以进行验证和运行的。&lt;strong&gt;kustomize&lt;/strong&gt; 鼓励通过 fork/modify/rebase 这样的&lt;a href=&#34;https://github.com/kubernetes-sigs/kustomize/blob/master/docs/workflows.md&#34;&gt;工作流&lt;/a&gt;来管理海量的应用描述文件。&lt;/p&gt;
&lt;p&gt;尝试&lt;a href=&#34;https://github.com/kubernetes-sigs/kustomize/tree/master/examples/helloWorld&#34;&gt;hello world&lt;/a&gt;示例，开始使用 &lt;strong&gt;kustomize&lt;/strong&gt; 吧！有关的反馈与讨论，可以通过加入&lt;a href=&#34;https://groups.google.com/forum/#!forum/kustomize&#34;&gt;邮件列表&lt;/a&gt;或提 &lt;a href=&#34;https://github.com/kubernetes-sigs/kustomize/issues/new&#34;&gt;issue&lt;/a&gt;，欢迎提交PR。&lt;/p&gt;
&lt;h2 id=&#34;译者按&#34;&gt;译者按&lt;/h2&gt;
&lt;p&gt;随着 kubernetes 1.14 的发布，kustomize 被集成到 &lt;code&gt;kubectl&lt;/code&gt; 中，用户可以利用 &lt;code&gt;kubectl apply -k dir/&lt;/code&gt; 将指定目录的 &lt;code&gt;kustomization.yaml&lt;/code&gt; 提交到集群中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原文链接&lt;/strong&gt; &lt;a href=&#34;https://kubernetes.io/blog/2018/05/29/introducing-kustomize-template-free-configuration-customization-for-kubernetes/&#34;&gt;https://kubernetes.io/blog/2018/05/29/introducing-kustomize-template-free-configuration-customization-for-kubernetes/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Devops入门手册</title>
      <link>https://guoxudong.io/post/devops-tutorial/</link>
      <pubDate>Tue, 09 Apr 2019 13:21:56 +0800</pubDate>
      
      <guid>https://guoxudong.io/post/devops-tutorial/</guid>
      <description>&lt;h1 id=&#34;devops-是什么&#34;&gt;DevOps 是什么？&lt;/h1&gt;
&lt;p&gt;“DevOps” 这个词是 &lt;code&gt;development&lt;/code&gt; 和 &lt;code&gt;operations&lt;/code&gt; 这两个词的组合。它是一种促进开发和运维团队之间的协作，以自动化和可重复的方式更快地将代码部署到生产中的&lt;strong&gt;文化&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;DevOps 帮助团体提高软件和服务的交付速度。它使团队能够更好地为客户服务，并提高在市场中的竞争力。&lt;/p&gt;
&lt;p&gt;简而言之， DevOps 可以定义为通过更好的沟通和协作，使开发和运维保持一致。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://wx4.sinaimg.cn/large/ad5fbf65gy1g1wbobryucj20db07dq2w.jpg&#34; alt=&#34;what is devops&#34;&gt;&lt;/p&gt;
&lt;p&gt;本手册中，您将学到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#devops-%E6%98%AF%E4%BB%80%E4%B9%88&#34;&gt;DevOps 是什么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-devops&#34;&gt;为什么需要 DevOps ？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#devops-%E4%B8%8E%E4%BC%A0%E7%BB%9F%E8%BF%90%E7%BB%B4%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C&#34;&gt;DevOps 与传统运维有什么不同？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-devops&#34;&gt;为什么使用 DevOps ？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#devops-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&#34;&gt;DevOps 的生命周期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#devops-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81&#34;&gt;DevOps 的工作流&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;devops-%E4%B8%8E%E6%95%8F%E6%8D%B7%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C-devops-vs-agile&#34;&gt;DevOps 与敏捷有什么不同？ DevOps VS Agile&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#devops-%E5%8E%9F%E5%88%99&#34;&gt;DevOps 原则&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B0%81%E5%8F%AF%E4%BB%A5%E5%81%9A-devops-%E5%B7%A5%E7%A8%8B%E5%B8%88&#34;&gt;谁可以做 DevOps 工程师？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#devops-%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%A7%92%E8%89%B2-%E8%81%8C%E8%B4%A3%E5%92%8C%E6%8A%80%E8%83%BD&#34;&gt;DevOps 工程师的角色、职责和技能&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#devops-%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%8F%AF%E4%BB%A5%E6%8C%A3%E5%A4%9A%E5%B0%91%E9%92%B1&#34;&gt;DevOps 工程师可以挣多少钱？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#devops-%E5%9F%B9%E8%AE%AD%E8%AE%A4%E8%AF%81&#34;&gt;DevOps 培训认证&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#devops-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7&#34;&gt;DevOps 自动化工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#devops-%E7%9A%84%E6%9C%AA%E6%9D%A5%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84&#34;&gt;DevOps 的未来是怎样的？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%80%BB%E7%BB%93&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;为什么需要-devops-&#34;&gt;为什么需要 DevOps ？&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;在实行 DevOps 之前，开发和运维团队是完全孤立的。&lt;/li&gt;
&lt;li&gt;测试和部署是设计在构建之后完成的独立活动。因此，他们比实际构建周期消耗更多时间。&lt;/li&gt;
&lt;li&gt;在不使用 DevOps 的情况下，团队成员将大量时间花在测试，部署和设计上，而不是构建项目。&lt;/li&gt;
&lt;li&gt;手动部署代码会导致生产中出现人为错误。&lt;/li&gt;
&lt;li&gt;开发和运维团队都有各自的时间表，时间的不同步导致生产交付进一步延误。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;提高软件交付率是业务方最迫切的需求。根据 Forrester Consulting Study 统计，只有17％的团队可以足够快地交付软件。更是证明了这一痛点。&lt;/p&gt;
&lt;h1 id=&#34;devops-与传统运维有什么不同&#34;&gt;DevOps 与传统运维有什么不同？&lt;/h1&gt;
&lt;p&gt;让我们将传统软件瀑布开发模型与 DevOps 进行比较，以了解 DevOps 带来的变化。&lt;/p&gt;
&lt;p&gt;我们假设有一个应用程序计划在2周内上线，代码完成80％。该应用程序是一个新的发布，从购买服务器开始&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;瀑布式开发&lt;/th&gt;
&lt;th&gt;DevOps&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;订购新服务器后，开发团队需要进行测试。运维团队根据需求文档开始部署基础设施。&lt;/td&gt;
&lt;td&gt;订购新服务器后，开发和运维团队根据需求文档共同调试部署新服务器。这样开发人员可以更好地了解服务器的基础架构。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;关于故障转移，冗余策略，数据中心位置和存储要求的规划存在偏差，因为开发人员对应用程序有深入了解，但他们无法提供任何协助。&lt;/td&gt;
&lt;td&gt;由于开发人员的加入，有关故障转移，冗余策略，灾难恢复，数据中心位置和存储要求的规划非常准确。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;运维团队对开发团队的进展一无所知。只能根据运维团队理解制定监控计划。&lt;/td&gt;
&lt;td&gt;在 DevOps 中，运维团队完全了解开发人员的进展。通过互动，共同制定满足运维和业务需求的监控计划。他们还使用应用程序性能监视（APM）工具以优化应用。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;在上线之前，压力测试使应用程序崩溃。发布延迟了。&lt;/td&gt;
&lt;td&gt;在上线之前，压力测试使应用程序有点慢。开发团队迅速解决了瓶颈问题。该应用程序按时发布。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;为什么使用-devops-&#34;&gt;为什么使用 DevOps ？&lt;/h1&gt;
&lt;p&gt;DevOps 允许敏捷开发团队实施持续集成和持续交付。这有助于他们更快地将产品推向市场。&lt;/p&gt;
&lt;p&gt;其他重要原因是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;可预测性：&lt;/strong&gt; DevOps 可以显着降低新版本的故障率。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自愈性：&lt;/strong&gt; 可以随时将应用回滚到较早的版本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可维护性：&lt;/strong&gt; 在新版本崩溃或当前系统不可用的情况下，可以毫不费力地进行恢复。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;上线时间：&lt;/strong&gt; DevOps 通过简化软件交付流程将上线时间缩短至50％。对于互联网和移动应用时间更短。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更高的质量：&lt;/strong&gt; DevOps 帮助团队提高应用程序开发的质量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;降低风险：&lt;/strong&gt; DevOps 在软件交付的生命周期中包含安全检查。它有助于减少整个软件生命周期中的安全风险。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;弹性：&lt;/strong&gt; 软件系统的运行状态更稳定，更安全，更改是可审计的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;成本效益：&lt;/strong&gt; DevOps 在软件开发过程中提供了成本效益，这始终是互联网公司管理层所期望的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;将大的代码库分成小块：&lt;/strong&gt; DevOps 是基于敏捷编程方法的。因此，它允许将大的代码库分解为更小且易于管理的块。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;什么时候使用-devops-&#34;&gt;什么时候使用 DevOps ？&lt;/h3&gt;
&lt;p&gt;DevOps 应该用于大型分布式应用程序，例如电子商务站点或托管在云平台上的应用程序。&lt;/p&gt;
&lt;h3 id=&#34;什么时候不使用-devops&#34;&gt;什么时候不使用 DevOps？&lt;/h3&gt;
&lt;p&gt;它不应该用于关键任务应用程序，如银行，电力设施和其他敏感数据站点。此类应用程序需要对生产环境进行严格的访问控制，详细的变更管理策略，完善的数据中心访问控制策略。&lt;/p&gt;
&lt;h1 id=&#34;devops-的生命周期&#34;&gt;DevOps 的生命周期&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;http://wx3.sinaimg.cn/large/ad5fbf65gy1g1wekkedpcj20k509mjrp.jpg&#34; alt=&#34;devops Lifecycle&#34;&gt;&lt;/p&gt;
&lt;p&gt;DevOps 是开发和运维之间的深度集成。在不了解 DevOps 生命周期的情况下，是无法真正理解 DevOps 的。&lt;/p&gt;
&lt;p&gt;以下是有关 DevOps生命周期的简要信息：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;开发&lt;/p&gt;
&lt;p&gt;在此阶段，整个开发过程分为小的开发周期。这有利于 DevOps 团队加快软件开发和交付过程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;p&gt;QA 团队使用 &lt;code&gt;Selenium&lt;/code&gt; 等自动化测试工具来识别和修复新代码中的错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;集成&lt;/p&gt;
&lt;p&gt;在此阶段，新功能与主分支代码集成，并进行测试。只有持续集成和测试才能实现持续交付。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;部署&lt;/p&gt;
&lt;p&gt;在此阶段，部署过程持续进行。它的执行方式是任何时候在代码中进行的任何更改都不应影响高流量网站的运行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;监测&lt;/p&gt;
&lt;p&gt;在此阶段，运维团队将负责处理不合适的系统行为或生产中发现的错误。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;devops-的工作流&#34;&gt;DevOps 的工作流&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;http://wx4.sinaimg.cn/large/ad5fbf65gy1g1wewdq1elj20g009fa9y.jpg&#34; alt=&#34; DevOps Work Flow &#34;&gt;&lt;/p&gt;
&lt;p&gt;工作流允许排列和分离用户最需要的任务。它还能够在配置任务时反应其最理想过程。&lt;/p&gt;
&lt;h1 id=&#34;devops-与敏捷有什么不同-devops-vs-agile&#34;&gt;DevOps 与敏捷有什么不同？ DevOps VS Agile&lt;/h1&gt;
&lt;p&gt;这是一个典型的IT流程&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://wx4.sinaimg.cn/large/ad5fbf65gy1g1wfmrcbafj20nq05wdg0.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;敏捷解决了客户和开发人员沟通中的问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://wx4.sinaimg.cn/large/ad5fbf65gy1g1wfn81bchj20no05q3ys.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;DevOps 解决了开发人员运维人员沟通中的问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://wx4.sinaimg.cn/large/ad5fbf65gy1g1wfnk7fi3j20nt05vt90.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;敏捷&lt;/th&gt;
&lt;th&gt;DevOps&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;强调打破开发人员和管理层之间的障碍。&lt;/td&gt;
&lt;td&gt;DevOps 是关于软件开发和运维团队的。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;解决客户需求与开发团队之间的距离。&lt;/td&gt;
&lt;td&gt;解决开发和运维团队之间的距离。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;重点关注功能和非功能准备。&lt;/td&gt;
&lt;td&gt;它侧重于运维和业务准备。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;敏捷开发主要涉及公司对开发方式的思考。&lt;/td&gt;
&lt;td&gt;DevOps 强调以最可靠和最安全的方式部署软件，而这些方式并不总是最快的。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;敏捷开发非常注重培训所有团队成员，使他们拥有各种相同的技能。因此，当出现问题时，任何团队成员都可以在没有团队领导的情况下从别的成员那里获得帮助。&lt;/td&gt;
&lt;td&gt;DevOps 在开发和运维团队之间传播技能，并保持一致的沟通。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;敏捷开发管理 “sprint” ，意味着时间更短（不到一个月），并且在此期间将产生和发布多个功能。&lt;/td&gt;
&lt;td&gt;DevOps 努力争取主要版本的稳定可靠，而不是更小和更频繁的发布版本。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;devops-原则&#34;&gt;DevOps 原则&lt;/h1&gt;
&lt;p&gt;这里有六个在采用 DevOps 时必不可少的原则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;以客户为中心：&lt;/strong&gt; DevOps 团队必须以客户为中心，因为是他们不断向我的产品和服务投资。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;端到端的责任：&lt;/strong&gt; DevOps 团队需要在产品的整个生命周期提供性能支持。这提高了产品的水平和质量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;持续改进：&lt;/strong&gt; DevOps 文化专注于持续改进，以尽量减少浪费。它不断加快产品或服务改进的速度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动化一切：&lt;/strong&gt; 自动化是 DevOps 流程的重要原则。这不仅适用于软件开发，同时也适用于整个基础架构环境。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;作为一个团队工作：&lt;/strong&gt; 在 DevOps 文化角色中，设计人员，开发人员和测试人员已经定义。他们所需要做的就是作为一个团队完成合作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;监控和测试所有内容：&lt;/strong&gt; DevOps 团队拥有强大的监控和测试程序是非常重要的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;谁可以做-devops-工程师&#34;&gt;谁可以做 DevOps 工程师？&lt;/h1&gt;
&lt;p&gt;DevOps 工程师是一名IT专业人员，他与软件开发人员，系统运维人员和其他IT人员一起管理代码发布。DevOps 应具备与开发，测试和运维团队进行沟通和协作的硬技能和软技能。&lt;/p&gt;
&lt;p&gt;DevOps 方法需要对代码版本进行频繁的增量更改，这意味着频繁的部署和测试方案。尽管 DevOps 工程师需要偶尔从头开始编码，但重要的是他们应该具备软件开发语言的基础知识。&lt;/p&gt;
&lt;p&gt;DevOps 工程师将与开发团队的工作人员一起解决连接代码的元素（如库或软件开发工具包）所需的编码和脚本。&lt;/p&gt;
&lt;h1 id=&#34;devops-工程师的角色职责和技能&#34;&gt;DevOps 工程师的角色、职责和技能&lt;/h1&gt;
&lt;p&gt;DevOps 工程师负责软件应用程序平台的生产和持续维护。&lt;/p&gt;
&lt;p&gt;以下是 DevOps 工程师的一些角色，职责和技能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能够跨平台和应用程序域执行系统故障排除和问题解决。&lt;/li&gt;
&lt;li&gt;通过开放的，标准的平台有效管理项目。&lt;/li&gt;
&lt;li&gt;提高项目可见性和可追溯性。&lt;/li&gt;
&lt;li&gt;通过协作提高开发质量并降低开发成本。&lt;/li&gt;
&lt;li&gt;分析、设计和评估自动化脚本和系统。&lt;/li&gt;
&lt;li&gt;通过使用最佳的云安全解决方案确保系统的安全。&lt;/li&gt;
&lt;li&gt;DevOps 工程师应该具备问题解决者和快速学习者的软技能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;devops-工程师可以挣多少钱&#34;&gt;DevOps 工程师可以挣多少钱？&lt;/h1&gt;
&lt;p&gt;DevOps 是最热门的IT专业之一。这就是为什么那里都有很多机会的原因。因此，即使是初级DevOps工程师的薪酬水平也相当高。在美国，初级DevOps工程师的平均年薪为78,696美元。&lt;/p&gt;
&lt;h1 id=&#34;devops-培训认证&#34;&gt;DevOps 培训认证&lt;/h1&gt;
&lt;p&gt;DevOps 培训认证可以帮助任何渴望成为 DevOps 工程师职业的人。认证可从 Amazon web services 、 Red Hat 、 Microsoft Academy 、 DevOps Institute 获得。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://aws.amazon.com/cn/certification/certified-devops-engineer-professional/&#34;&gt;AWS Certified DevOps Engineer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;此 DevOps 工程师证书将测试您如何使用最常见的 DevOps 模式在 AWS 上开发，部署和维护应用程序。它还会评估 DevOps 方法的核心原则。&lt;/p&gt;
&lt;p&gt;该认证有两个必要条件：认证费用为300美元，持续时间为170分钟。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.redhat.com/en/services/training-and-certification&#34;&gt;Red Hat Certification&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;红帽为 DevOps 专业人士提供不同级别的认证，如下所示:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Red Hat Certificate of Expertise in Platform-as-a-Service&lt;/li&gt;
&lt;li&gt;Red Hat Certificate of Expertise in Containerized Application Development&lt;/li&gt;
&lt;li&gt;Red Hat Certificate of Expertise in Ansible Automation&lt;/li&gt;
&lt;li&gt;Red Hat Certificate of Expertise in Configuration Management&lt;/li&gt;
&lt;li&gt;Red Hat Certificate of Expertise in Container Administration&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;http://devopsinstitute.com/&#34;&gt;Devops Institute&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Devops Institute是围绕新兴 DevOps 实践的全球学习社区。该组织正在为 DevOps 能力资格设置质量标准。Devops Institute目前提供三个课程和认证。&lt;/p&gt;
&lt;p&gt;公司提供的认证课程有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DevOps Foundation&lt;/li&gt;
&lt;li&gt;DevOps Foundation Certified&lt;/li&gt;
&lt;li&gt;Certified Agile Service Manager&lt;/li&gt;
&lt;li&gt;Certified Agile Process Owner&lt;/li&gt;
&lt;li&gt;DevOps Test Engineering&lt;/li&gt;
&lt;li&gt;Continuous Delivery Architecture&lt;/li&gt;
&lt;li&gt;DevOps Leader&lt;/li&gt;
&lt;li&gt;DevSecOps Engineering&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;devops-自动化工具&#34;&gt;DevOps 自动化工具&lt;/h1&gt;
&lt;p&gt;所有测试流程自动化并对其进行配置以实现至关重要的速度和灵活性。此过程称为 DevOps 自动化。&lt;/p&gt;
&lt;p&gt;维护庞大的IT基础架构的大型 DevOps 团队面临的困难可以简要分为六个不同的类别。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基础设施自动化&lt;/li&gt;
&lt;li&gt;配置管理&lt;/li&gt;
&lt;li&gt;部署自动化&lt;/li&gt;
&lt;li&gt;性能管理&lt;/li&gt;
&lt;li&gt;日志管理&lt;/li&gt;
&lt;li&gt;监测&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;让我们看看每个类别中的工具以及它们如何解决痛点：&lt;/p&gt;
&lt;h3 id=&#34;基础设施自动化&#34;&gt;基础设施自动化&lt;/h3&gt;
&lt;p&gt;亚马逊网络服务（AWS）：作为云服务，您无需建立实际的数据中心。此外，它们易于按需扩展。没有前期硬件成本。它可以配置为自动根据流量配置更多服务器。&lt;/p&gt;
&lt;h3 id=&#34;配置管理&#34;&gt;配置管理&lt;/h3&gt;
&lt;p&gt;Chef：它是一个有用的 DevOps 工具，用于提升速度，规模和一致性。它可用于简化复杂任务并执行配置管理。使用此工具，DevOps 团队可以避免在一万台服务器上进行更改。相反，只需要在一个地方进行更改，这些更改会自动反映在其他服务器中。&lt;/p&gt;
&lt;h3 id=&#34;部署自动化&#34;&gt;部署自动化&lt;/h3&gt;
&lt;p&gt;Jenkins：该工具有助于持续集成和测试。通过在部署构建后快速查找问题，更​​轻松地集成项目更改。&lt;/p&gt;
&lt;h3 id=&#34;日志管理&#34;&gt;日志管理&lt;/h3&gt;
&lt;p&gt;Splunk：可以解决在一个地方聚合，存储和分析所有日志的问题的工具。&lt;/p&gt;
&lt;h3 id=&#34;性能管理&#34;&gt;性能管理&lt;/h3&gt;
&lt;p&gt;App Dynamic：它是一个 DevOps 工具，提供实时性能监控。此工具收集的数据可帮助开发人员在发生问题时进行调试。&lt;/p&gt;
&lt;h3 id=&#34;监控&#34;&gt;监控&lt;/h3&gt;
&lt;p&gt;Nagios：在基础架构和相关服务出现故障时通知相关人员也很重要。Nagios 就是这样一种工具，它可以帮助 DevOps 团队找到并纠正问题。&lt;/p&gt;
&lt;h1 id=&#34;devops-的未来是怎样的&#34;&gt;DevOps 的未来是怎样的？&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;团队将代码部署周期转换为数周和数月，而不是数年。&lt;/li&gt;
&lt;li&gt;很快就会看到，DevOps 工程师可以比企业中的任何其他人更多地接近和管理终端用户。&lt;/li&gt;
&lt;li&gt;DevOps 正在成为IT人员的重要技能。例如，Linux 招聘进行的一项调查发现，25％的受访者的求职者寻求 DevOps 工作。&lt;/li&gt;
&lt;li&gt;DevOps 和持续交付将继续存在。因为公司需要发展，他们别无选择，只能改变。然而，DevOps 概念的主流化则需要5到10年。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;DevOps 是一种促进开发和运维团队之间的协作，以自动化和可重复的方式更快地将代码部署到生产中的&lt;strong&gt;文化&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;在 DevOps 出现之前运维和开发团队完全独立。&lt;/li&gt;
&lt;li&gt;手动部署代码会导致生产中出现人为错误。&lt;/li&gt;
&lt;li&gt;在旧的软件开发流程中，运维团队不了解开发团队的进度。因此，运维团队只能根据他们自己的理解制定了基础设施的购买和监控计划。&lt;/li&gt;
&lt;li&gt;在 DevOps 流程中，运维团队充分了解开发人员的进度。采购和监控计划准确无误。&lt;/li&gt;
&lt;li&gt;DevOps 提供可维护性，可预测性，更高质量的代码和更准确的上线时间。&lt;/li&gt;
&lt;li&gt;敏捷流程侧重于功能和非功能准备，而 DevOps 则侧重于IT基础架构方面。&lt;/li&gt;
&lt;li&gt;DevOps 生命周期包括开发，测试，集成，部署和监控。&lt;/li&gt;
&lt;li&gt;DevOps 工程师将与开发团队工作人员合作，以解决编码和脚本编写需求。&lt;/li&gt;
&lt;li&gt;DevOps 工程师应该具备问题解决者的软技能，并且是一个快速学习者。&lt;/li&gt;
&lt;li&gt;DevOps 认证可从 Amazon web services，Red Hat，Microsoft Academy，DevOps Institute 获得&lt;/li&gt;
&lt;li&gt;DevOps 可帮助团队将代码部署周期转换为数周和数月，而不是数年。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;原文链接&lt;/strong&gt; &lt;a href=&#34;https://www.guru99.com/devops-tutorial.html&#34;&gt;https://www.guru99.com/devops-tutorial.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh是什么，我们又为什么需要它</title>
      <link>https://guoxudong.io/post/whats-a-service-mesh-and-why-do-i-need-one/</link>
      <pubDate>Mon, 25 Mar 2019 18:17:20 +0800</pubDate>
      
      <guid>https://guoxudong.io/post/whats-a-service-mesh-and-why-do-i-need-one/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;作者：William Morgan 发表于2017年4月25日，2018年11月26日有所修改。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Service Mesh 是一个专门使服务与服务之间的通信变得安全、快速和可靠的的基础设施。如果你正在在构建一个云原生（ Cloud Native ）应用，那么你一定需要 Service Mesh 。&lt;/p&gt;
&lt;p&gt;在过去的一年中， Service Mesh 成为了云原生技术栈的关键组件。像 Paypal ,  Ticketmaster 和 Credit Karma 这样的大厂，已经将 Service Mesh 加入到他们的全部应用中。并且在2017年1月，开源的 Service Mesh 软件 Linkerd 加入云原生基金会（ CNCF ），成为云原生基金会（ CNCF ）的官方项目。但是什么是真正的 Service Mesh ？它又为何突然变的如此重要？&lt;/p&gt;
&lt;p&gt;在这篇文章，我会讲解 Service Mesh 的定义，并通过应用服务架构过去十年的发展追溯其起源。并将 Service Mesh 与其他相似的概念（包括 API 网关，边缘代理以及 ESB （enterprise service bus））进行区分。最终，将会描述 Service Mesh 的发展方向，以及随着云原生概念的普及，Service Mesh 发生的变化。&lt;/p&gt;
&lt;h2 id=&#34;什么是-service-mesh&#34;&gt;什么是 Service Mesh&lt;/h2&gt;
&lt;p&gt;Service Mesh 这个服务网络专注于处理服务和服务间的通讯。其主要负责构造一个稳定可靠的服务通讯的基础设施，并让整个架构更为的先进和 Cloud Native。在工程中，Service Mesh 基本来说是一组轻量级的服务代理和应用逻辑的服务在一起，并且对于应用服务是透明的。&lt;/p&gt;
&lt;p&gt;Service Mesh 作为独立层的概念与云原生应用的兴起有关。在云原生模式，单个应用可能有数百个服务组成，每个服务又可能有上千个实例，而每个实例都有可能被像 kubernetes 这样的服务调度器不断调度从而不断变化状态。而这些复杂的通信又普遍是服务运行时行为的一部分，这时确保端到端的通信的性能和可靠性就变的至关重要。&lt;/p&gt;
&lt;h2 id=&#34;service-mesh-就是一个网络模型吗&#34;&gt;Service Mesh 就是一个网络模型吗？&lt;/h2&gt;
&lt;p&gt;Service Mesh 是一个位于 TCP/IP 上的抽象层的网络模型。它假定底层 L3/L4 网络存在并且能够从一点向另一点传输数据。（它还假定这个网络和环境的其他方面一样不可靠，所以 Service Mesh 也必须能够处理网络故障。）&lt;/p&gt;
&lt;p&gt;在某些方面，Service Mesh 就像是网络七层模型中的第四层 TCP 协议。其把底层的那些非常难控制的网络通讯方面的控制面的东西都管了（比如：丢包重传、拥塞控制、流量控制），而更为上面的应用层的协议，只需要关心自己业务应用层上的事了。&lt;/p&gt;
&lt;p&gt;与 TCP 不同的是， Service Mesh 想要达成的目的不仅仅是正常的网络通讯。它为应用提供了统一的，可视化的以及可控制的控制平面。Service Mesh 是要将服务间的通信从无法发现和控制的基础设施中分离出来，并对其进行监控、管理和控制。&lt;/p&gt;
&lt;h2 id=&#34;service-mesh-实际上做了什么&#34;&gt;Service Mesh 实际上做了什么？&lt;/h2&gt;
&lt;p&gt;在云原生应用中传递可靠的请求是十分复杂的。而 &lt;a href=&#34;https://linkerd.io/#_ga=2.114183109.310878331.1553762133-1927878916.1553476024&#34;&gt;Linkerd&lt;/a&gt; 提供了服务熔断、重试、负载均衡、熔断降级等功能，通过其强大的功能来管理那些必须运行在复杂环境中的服务。&lt;/p&gt;
&lt;p&gt;这里列举一个通过 Linkerd 向服务发出请求的简单流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过 Linkerd 的动态路由规则来确定打算连接哪个服务。这个请求是要路由到生产环境还是演示环境？是请求本地数据中心的服务还是云上的服务？是请求正在测试的最新版的服务还是已经在生产中经过验证的老版本？所有的这些路由规则都是动态配置的，可以全局应用也可以部分应用。&lt;/li&gt;
&lt;li&gt;找到正确的目的服务后， Linkerd 从一个或几个相关的服务发现端点检索实例池。如果这些信息与 Linkerd 的服务发现信息不同， Linkerd 会决定信任哪些信息来源。&lt;/li&gt;
&lt;li&gt;Linkerd 会根据观察到的最近的响应延迟来选择速度最快的实例。&lt;/li&gt;
&lt;li&gt;Linkerd 发送请求给这个实例，记录延迟和响应类型。&lt;/li&gt;
&lt;li&gt;如果这个实例挂了、无响应或者无法处理请求， Linkerd 会再另一个实例上重试这个请求。（但只有在请求是幂等的时候）&lt;/li&gt;
&lt;li&gt;如果一个实例一直请求失败， Linkerd 会将其移出定时重试的负载均衡池。&lt;/li&gt;
&lt;li&gt;如果请求超时， Linkerd 会主动将请求失效，而不是进一步重试从而增加负载。&lt;/li&gt;
&lt;li&gt;Linkerd 会记录指标和分布式的追踪上述行为的各个方面，将他们保存在集中的指标系统中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上只是简化版的介绍， Linkerd 还可以启动和重试 TLS ，执行协议升级，动态切换流量，甚至在故障之后数据中心的切换。
&lt;img src=&#34;http://wx4.sinaimg.cn/large/ad5fbf65ly1g1in1q1jnuj20sg0gbt99.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;p&gt;值得注意的是，这些功能旨在为每个实例和应用程序提供弹性伸缩。而大规模的分布式系统（无论是如何构建的）都有一个共同特点：都会因为许多小的故障，而升级为全系统灾难性的故障。Service Mesh 则被设计为通过快速的失效和减少负载来保护整个系统免受这样灾难性的故障。&lt;/p&gt;
&lt;h2 id=&#34;为什么-service-mesh-是必要的&#34;&gt;为什么 Service Mesh 是必要的？&lt;/h2&gt;
&lt;p&gt;Service Mesh 本质上并不是什么新技术，而是功能所在位置的转变。Web 应用需要管理复杂的服务通信，Service Mesh 模式的起源和演变过程可以追溯到15年前。&lt;/p&gt;
&lt;p&gt;参考2000年左右中型 Web 应用的典型三层架构，在这个架构中，应用被分为三层：应用逻辑、web 服务逻辑、存储逻辑。层之间的通信虽然复杂，但是毕竟范围有限，最多只有2跳。这里并不是 “Mesh” 的，但在每层中处理跳转的代码是存在通信逻辑的。&lt;/p&gt;
&lt;p&gt;当这种架构向更大规模发展的时候，这种通信方式就无以为继了。像 Google , Netflix , 和 Twitte ，在面临巨大的请求流量的时候，他们的实现了云原生应用的前身：应用被分割成了许多服务（现在称作“微服务”），这些服务组成了一种网格结构。在这些系统中，通用通信层突然兴起，表现为“胖客户端”的形式 - Twitter 的 Finagle, Netflix 的 Hystrix 和 Google 的 Stubby 都是很典型的例子。&lt;/p&gt;
&lt;p&gt;现在看来，像 Finagle 、Stubby 和 Hystrix 这样的库就是最早的 Service Mesh。虽然它们是为特定环境、语言和框架定制了，但都是作为基础设施专门用于管理服务间的通信，并（在 Finagle 和 Hystrix 开源的情况下）在其他公司的应用中被使用。&lt;/p&gt;
&lt;p&gt;这三个组件都有应用自适应机制，以便在负载中进行拓展，并处理在云环境中的部分故障。但是对于数百个服务或数千个实例，以及不时需要重新调度的业务层实例，单个请求通过的调用链可能变的非常复杂，而且服务可能由不同的语言编写，这时基于库的解决方案可能就不再适用了。&lt;/p&gt;
&lt;p&gt;服务通信的复杂性和重要性导致我们急需一个专门的基础设施层来处理服务间的通信，该层需要与业务代码解耦，并且具有捕获底层环境的动态机制。这就是 Service Mesh 。&lt;/p&gt;
&lt;h2 id=&#34;service-mesh-的未来&#34;&gt;Service Mesh 的未来&lt;/h2&gt;
&lt;p&gt;Service Mesh 在云生态下迅速的成长，并且有着令人激动的未来等待探索。对无服务器计算（Serverless， 例如 Amazon 的 &lt;a href=&#34;https://aws.amazon.com/lambda/&#34;&gt;Lambda&lt;/a&gt;）适用的 Service Mesh 网络模型，在云生态系统中角色的自然拓展。Service Mesh 可能成为服务身份和访问策略这些在云原生领域还是比较新的技术的基础。最后，Service Mesh ，如之前的TCP / IP，将推进加入到底层的基础架构中。就像 Linkerd 是由像 Finagle 这样的系统发展而来，Service Mesh 将作为单独的用户空间代理添加到云原生技术栈中继续发展。&lt;/p&gt;
&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;
&lt;p&gt;Service Mesh 是云原生技术栈的关键技术。Linkerd 成立仅1年就成为了云原生基金会（CNCF）的一部分，拥有蓬勃发展的社区和贡献者。使用者从像 Monzo 这样颠覆英国银行业的创业公司，到像 Paypal、 Ticketmaster 和 Credit Karma 这样的互联网大厂，再到像 Houghton Mifflin Harcourt 这样经营了数百年的公司。&lt;/p&gt;
&lt;p&gt;使用者和贡献者每天都在 Linkerd 社区展示 Service Mesh 创造的价值。我们将致力于打造这一令人惊叹的产品，并继续发展壮大我们的社区，&lt;a href=&#34;https://linkerd.io/#_ga=2.40265824.310878331.1553762133-1927878916.1553476024&#34;&gt;加入我们吧&lt;/a&gt;！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原文链接&lt;/strong&gt; &lt;a href=&#34;https://buoyant.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/&#34;&gt;https://buoyant.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
